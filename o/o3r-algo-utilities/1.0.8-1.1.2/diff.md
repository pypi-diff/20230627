# Comparing `tmp/o3r_algo_utilities-1.0.8-py3-none-any.whl.zip` & `tmp/o3r_algo_utilities-1.1.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,15 +1,16 @@
-Zip file size: 24322 bytes, number of entries: 13
--rw-rw-rw-  2.0 fat      152 b- defN 23-Feb-28 16:51 o3r_algo_utilities/__init__.py
--rw-rw-rw-  2.0 fat     9623 b- defN 23-Feb-28 16:51 o3r_algo_utilities/o3r_uncompress_di.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Feb-28 16:51 o3r_algo_utilities/calib/__init__.py
--rw-rw-rw-  2.0 fat    26875 b- defN 23-Feb-28 16:51 o3r_algo_utilities/calib/calibration.py
--rw-rw-rw-  2.0 fat    11458 b- defN 23-Feb-28 16:51 o3r_algo_utilities/calib/point_correspondences.py
--rw-rw-rw-  2.0 fat     8891 b- defN 23-Feb-28 16:51 o3r_algo_utilities/calib/sources.py
--rw-rw-rw-  2.0 fat    11357 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/LICENSE
--rw-rw-rw-  2.0 fat      778 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/METADATA
--rw-rw-rw-  2.0 fat       57 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/NOTICE
--rw-rw-rw-  2.0 fat       97 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       83 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat       19 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1211 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/RECORD
-13 files, 70601 bytes uncompressed, 22244 bytes compressed:  68.5%
+Zip file size: 28066 bytes, number of entries: 14
+-rw-rw-rw-  2.0 fat      152 b- defN 23-Jun-13 11:31 o3r_algo_utilities/__init__.py
+-rw-rw-rw-  2.0 fat    15177 b- defN 23-Jun-13 11:31 o3r_algo_utilities/o3r_uncompress_di.py
+-rw-rw-rw-  2.0 fat     5073 b- defN 23-Jun-13 11:31 o3r_algo_utilities/rotmat.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-13 11:31 o3r_algo_utilities/calib/__init__.py
+-rw-rw-rw-  2.0 fat    25601 b- defN 23-Jun-13 11:31 o3r_algo_utilities/calib/calibration.py
+-rw-rw-rw-  2.0 fat     3072 b- defN 23-Jun-13 11:31 o3r_algo_utilities/calib/corner_detector.py
+-rw-rw-rw-  2.0 fat    10285 b- defN 23-Jun-13 11:31 o3r_algo_utilities/calib/point_correspondences.py
+-rw-rw-rw-  2.0 fat    11425 b- defN 23-Jun-13 11:31 o3r_algo_utilities/calib/sources.py
+-rw-rw-rw-  2.0 fat    11357 b- defN 23-Jun-13 11:38 o3r_algo_utilities-1.1.2.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat      823 b- defN 23-Jun-13 11:38 o3r_algo_utilities-1.1.2.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       57 b- defN 23-Jun-13 11:38 o3r_algo_utilities-1.1.2.dist-info/NOTICE
+-rw-rw-rw-  2.0 fat       97 b- defN 23-Jun-13 11:38 o3r_algo_utilities-1.1.2.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       19 b- defN 23-Jun-13 11:38 o3r_algo_utilities-1.1.2.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     1292 b- defN 23-Jun-13 11:38 o3r_algo_utilities-1.1.2.dist-info/RECORD
+14 files, 84430 bytes uncompressed, 25872 bytes compressed:  69.4%
```

## zipnote {}

```diff
@@ -1,40 +1,43 @@
 Filename: o3r_algo_utilities/__init__.py
 Comment: 
 
 Filename: o3r_algo_utilities/o3r_uncompress_di.py
 Comment: 
 
+Filename: o3r_algo_utilities/rotmat.py
+Comment: 
+
 Filename: o3r_algo_utilities/calib/__init__.py
 Comment: 
 
 Filename: o3r_algo_utilities/calib/calibration.py
 Comment: 
 
-Filename: o3r_algo_utilities/calib/point_correspondences.py
+Filename: o3r_algo_utilities/calib/corner_detector.py
 Comment: 
 
-Filename: o3r_algo_utilities/calib/sources.py
+Filename: o3r_algo_utilities/calib/point_correspondences.py
 Comment: 
 
-Filename: o3r_algo_utilities-1.0.8.dist-info/LICENSE
+Filename: o3r_algo_utilities/calib/sources.py
 Comment: 
 
-Filename: o3r_algo_utilities-1.0.8.dist-info/METADATA
+Filename: o3r_algo_utilities-1.1.2.dist-info/LICENSE
 Comment: 
 
-Filename: o3r_algo_utilities-1.0.8.dist-info/NOTICE
+Filename: o3r_algo_utilities-1.1.2.dist-info/METADATA
 Comment: 
 
-Filename: o3r_algo_utilities-1.0.8.dist-info/WHEEL
+Filename: o3r_algo_utilities-1.1.2.dist-info/NOTICE
 Comment: 
 
-Filename: o3r_algo_utilities-1.0.8.dist-info/entry_points.txt
+Filename: o3r_algo_utilities-1.1.2.dist-info/WHEEL
 Comment: 
 
-Filename: o3r_algo_utilities-1.0.8.dist-info/top_level.txt
+Filename: o3r_algo_utilities-1.1.2.dist-info/top_level.txt
 Comment: 
 
-Filename: o3r_algo_utilities-1.0.8.dist-info/RECORD
+Filename: o3r_algo_utilities-1.1.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## o3r_algo_utilities/o3r_uncompress_di.py

```diff
@@ -113,30 +113,30 @@
     n = width * height        
     A[...] = np.reshape(amplitude_u16[:n].astype(np.float32), (height, width))
     A -= 1
     mask = (A >= 0)
     A[mask] **= 2
     A[mask] *= amplitudeResolution
     return A
-    
-def evalIntrinsic(intrinsicModelID, intrinsicModelParameters, width, height):
+
+def evalIntrinsicCoords(intrinsicModelID, intrinsicModelParameters, iy, ix):
     """
-    Returns unit vectors for images with the given size calculated from the given unprojection model. 
-    This function is automatically called from xyzdFromDistance.
+    Returns unit vectors for coordinates given in points. 
     
     :param intrinsicModelID         : modelID of intrinsic calibration
     :param intrinsicModelParameters : parameters of intrinsicModel (32 element float32 array)
-    :param width                    : width of the images
-    :param height                   : height of the images
+    :param iy                       : y coordinates of points to be evaluated
+    :param ix                       : x coordinates of points to be evaluated
     :return: vx, vy, vz the x, y and z components of the normalized unit vectors
     """
+    iy = np.asarray(iy)
+    ix = np.asarray(ix)
     if intrinsicModelID == 0:
         # see https://polarionsy.intra.ifm/polarion/redirect/project/O3Rx_01/workitem?id=O3R-3131
         fx, fy, mx, my, alpha, k1, k2, k3, k4, k5 = intrinsicModelParameters[:10]
-        iy, ix = np.indices((height, width))
         cx = (ix + 0.5 - mx)/fx
         cy = (iy + 0.5 - my)/fy
         cx -= alpha*cy
         r2 = cx**2 + cy**2
         fradial = 1 + r2*(k1 + r2*(k2 + r2*k5))
         h = 2*cx*cy
         tx = k3*h + k4*(r2 + 2*cx**2)
@@ -147,15 +147,14 @@
         vx = fnorm*dx
         vy = fnorm*dy
         vz = fnorm
         return vx, vy, vz
     elif intrinsicModelID == 2:
         # see https://polarionsy.intra.ifm/polarion/redirect/project/O3Rx_01/workitem?id=O3R-6922
         fx, fy, mx, my, alpha, k1, k2, k3, k4, theta_max = intrinsicModelParameters[:10]
-        iy, ix = np.indices((height, width))
         cx = (ix + 0.5 - mx)/fx
         cy = (iy + 0.5 - my)/fy
         cx -= alpha*cy
         theta_s = np.sqrt(cx**2 + cy**2)
         phi_s = np.minimum(theta_s, theta_max)
         p_radial = 1 + phi_s**2*(k1 + phi_s**2*(k2 + phi_s**2*(k3 + phi_s**2*k4)))
         theta = theta_s*p_radial
@@ -163,14 +162,157 @@
         vx = np.choose( (theta_s > 0), (0, (cx / theta_s) * np.sin(theta)) )
         vy = np.choose( (theta_s > 0), (0, (cy / theta_s) * np.sin(theta)) )
         vz = np.cos(theta)
         return vx, vy, vz
     else:
         raise RuntimeError("Unknown model %d" % intrinsicModelID)
 
+def evalIntrinsicCoordsReverse(intrinsicModelID, intrinsicModelParameters, vx, vy, vz):
+    """
+    Returns coordinates corresponding to 3D points.
+    
+    Supports both the inverse intrinsic models, which are faster and the intrinsic models (which
+    use a linearized inversion model of the distortion)
+    
+    :param intrinsicModelID         : modelID of intrinsic calibration
+    :param intrinsicModelParameters : parameters of intrinsicModel (32 element float32 array)
+    :param vx                       : 3D x coordinate of the point to be projected
+    :param vy                       : 3D y coordinate of the point to be projected
+    :param vz                       : 3D z coordinate of the point to be projected
+    :return: iy, ix the row and column coordinates in the image. Note that these coordinates maybe nan if the projection
+             fails
+    """
+    vx = np.asarray(vx, dtype=np.float32)
+    vy = np.asarray(vy, dtype=np.float32)
+    vz = np.asarray(vz, dtype=np.float32)
+    
+    if intrinsicModelID == 1:
+        ixn = vx/vz
+        iyn = vy/vz
+        ixn[vz <= 0] = np.nan
+        iyn[vz <= 0] = np.nan
+
+        fx, fy, mx, my, alpha, k1, k2, k3, k4, k5 = intrinsicModelParameters[:10]
+        
+        rd2 = ixn ** 2 + iyn ** 2
+        radial = rd2 * (k1 + rd2 * (k2 + rd2 * k5)) + 1
+        ixd = ixn * radial
+        iyd = iyn * radial
+        if k3 != 0 or k4 != 0:
+            h = 2 * ixn * iyn
+            tangx = k3 * h + k4 * (rd2 + 2 * ixn ** 2)
+            tangy = k3 * (rd2 + 2 * iyn ** 2) + k4 * h
+            ixd += tangx
+            iyd += tangy
+            
+        ix = (fx * (ixd - alpha * iyd)) + mx - 0.5
+        iy = (fy * (iyd)) + my - 0.5
+        
+        return iy, ix
+        
+    elif intrinsicModelID == 3:
+        fx, fy, mx, my, alpha, k1, k2, k3, k4, theta_max = intrinsicModelParameters[:10]
+        
+        lxy = np.sqrt(vx**2 + vy**2)
+        theta = np.arctan2(lxy, vz)
+        phi = np.minimum(theta, theta_max)**2
+        p_radial = 1 + phi*(k1 + phi*(k2 + phi*(k3 + phi*k4)))
+        theta_s = p_radial * theta
+        f_radial = np.choose(lxy > 0, (0, theta_s/lxy))
+        ixd = f_radial * vx
+        iyd = f_radial * vy
+        
+        ix = (fx * (ixd - alpha * iyd)) + mx - 0.5
+        iy = (fy * (iyd)) + my - 0.5
+        
+        return iy, ix
+    
+    if intrinsicModelID == 0:
+        cx = vx/vz
+        cy = vy/vz
+
+        cx[vz <= 0] = np.nan
+        cy[vz <= 0] = np.nan
+        fx, fy, mx, my, alpha, k1, k2, k3, k4, k5 = intrinsicModelParameters[:10]
+
+        if k3 != 0 or k4 != 0:
+            raise RuntimeError("Tangential distortion is unsupported in reverse mode")
+
+        # the inversion is performed by a linear approximation of the distortion function
+
+        # valid values for r (assuming that mx,my is appr. in the center of the image)
+        r = np.linspace(0, np.sqrt((mx*1.5/fx)**2 + (my*1.5/fy)**2), 1024)
+        # calculate corresponding distortions
+        r_2 = r**2
+        k_radial_r = 1 + r_2 * (k1 + r_2 * (k2 + r_2 * k5))
+        # if the polynomial is not strictly monotonic increasing, cut off the non-increasing part
+        M = r[1:]*k_radial_r[1:] <= r[:-1]*k_radial_r[:-1]
+        if np.sum(M) > 0:
+            n = np.where(M)[0]-1
+        else:
+            n = len(r)
+        r = r[:n]
+        k_radial_r = k_radial_r[:n]
+        # interpolate the distorted radius from the undistorted radius:
+        #   r_dist = r_undist * k_radial(r_undist)
+        r_actual = np.sqrt(cx**2 + cy**2)
+        r_init = np.interp(r_actual, r*k_radial_r, r, right=np.nan)
+        # distort the coordinates
+        cx = cx * r_init / r_actual
+        cy = cy * r_init / r_actual
+
+        cx += alpha * cy
+        ix = cx*fx - 0.5 + mx
+        iy = cy*fy - 0.5 + my
+        
+        return iy, ix
+    
+    elif intrinsicModelID == 2:
+
+        fx, fy, mx, my, alpha, k1, k2, k3, k4, theta_max = intrinsicModelParameters[:10]
+
+        # the inversion is performed by a linear approximation of the distortion function
+        # similar to the intrinsicModelID == 0:
+        #   theta_s = theta * p_radial(theta)
+
+        theta_p = np.linspace(0, theta_max*1.2, 1024)
+        theta_p_2 = np.minimum(theta_p, theta_max)**2
+        p_radial_p = 1 + theta_p_2 * (k1 + theta_p_2 * (k2 + theta_p_2 * (k3 + theta_p_2 * k4)))
+
+        lxy = np.sqrt(vx ** 2 + vy ** 2)
+        theta = np.arctan2(lxy, vz)
+
+        theta_s = np.interp(theta, p_radial_p*theta_p, theta_p, right=np.nan)
+        f_radial = np.choose(lxy > 0, (0, theta_s / lxy))
+        ixd = f_radial * vx
+        iyd = f_radial * vy
+
+        ix = (fx * (ixd - alpha * iyd)) + mx - 0.5
+        iy = (fy * (iyd)) + my - 0.5
+
+        return iy, ix
+
+    else:
+        raise RuntimeError("Unknown model %d" % intrinsicModelID)
+    
+
+def evalIntrinsic(intrinsicModelID, intrinsicModelParameters, width, height):
+    """
+    Returns unit vectors for images with the given size calculated from the given unprojection model. 
+    This function is automatically called from xyzdFromDistance.
+    
+    :param intrinsicModelID         : modelID of intrinsic calibration
+    :param intrinsicModelParameters : parameters of intrinsicModel (32 element float32 array)
+    :param width                    : width of the images
+    :param height                   : height of the images
+    :return: vx, vy, vz the x, y and z components of the normalized unit vectors
+    """
+    iy, ix = np.indices((height, width))
+    return evalIntrinsicCoords(intrinsicModelID, intrinsicModelParameters, iy, ix)
+
 def evalExtrinsic(translation, rotation):
     """
     Converts the extrinsic calibration into a rotation matrix and a translation vector.
     This function is automatically called from xyzdFromDistance.
     
     :param translation  : translational part of the extrinsic calibration [transX, transY, transZ]
     :param rotation     : translational part of the extrinsic calibration [rotX, rotY, rotZ]
@@ -186,9 +328,8 @@
     sy = np.sin(rotY)
     sz = np.sin(rotZ)
     R = np.array([
         [cy*cz, -cy*sz, sy],
         [cx*sz + cz*sx*sy, cx*cz - sx*sy*sz, -cy*sx],
         [sx*sz - cx*cz*sy, cz*sx + cx*sy*sz, cx*cy]
     ], np.float32)
-    return R, t
-
+    return R, t
```

## o3r_algo_utilities/calib/calibration.py

```diff
@@ -3,16 +3,16 @@
 #
 # THE PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.
 #
 
 import logging
 import string
 import numpy as np
-import cv2
 import argparse
+from o3r_algo_utilities.calib.corner_detector import findChessboardCorners 
 from o3r_algo_utilities.calib import sources
 from o3r_algo_utilities.calib import point_correspondences as cpc
 
 logger = logging.getLogger(__name__)
 
 help="""
 IFM ODS CALIBRATION
@@ -296,46 +296,14 @@
         logger.error('Mean error is bigger than `max_allowed_error`: {} > {}'.format(np.nanmean(error), max_allowed_error))
         raise RuntimeError("Validation did not succeed.")
     else:
         logger.info('Error is within tolerance')
         logger.debug('Calibration done')
 
 
-def findChessboardCorners(ampl, pattern_size):
-    '''
-    detects chessboard corners in an amplitude image. The chessboard will be aligned such that the first corner is
-    above the last corner in the image
-    
-    :param ampl: amplitude image as outputted by O3R
-    :param pattern_size: number of inner corners in the chessboard directions
-    :return: corners, gray if the chessboard corners could be detected; otherwise None, gray
-    '''
-    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
-
-    # rescaled amplitude image for coner detection
-    gray = np.interp(ampl, (np.nanpercentile(ampl, 20), np.nanpercentile(ampl, 80)), (40, 215)).astype(np.uint8)
-
-    # Find the chess board corners
-    ret, corners = cv2.findChessboardCorners(gray, pattern_size, None)
-    # If found, add object points, image points (after refining them)
-    if ret == True:
-        # subpixel refinement
-        corners = cv2.cornerSubPix(gray, corners, (3, 3), (-1, -1), criteria)
-        corners = np.array(corners).squeeze().T
-        if corners[1,0] > corners[1,-1]:
-            # this might happen, see here:
-            # https://stackoverflow.com/questions/19190484/what-is-the-opencv-findchessboardcorners-convention
-            logger.info("chessboard corners need reversal shape=%s corners[0]=%s corners[-1]=%s",
-                        corners.shape, corners[:, 0], corners[:, -1])
-            corners = corners[:,::-1]
-        return corners, gray
-    else:
-        return None, gray
-
-
 def world_coordinates_from_corners(A, B, C, D, target_size):
     """
     This functions creates the chessboard world coordinates from
     
     :param A: upper left corner
     :param B: upper right corner
     :param C: lower left corner
@@ -425,15 +393,15 @@
     cC = C - AC*frameSize + CD * frameSize
     cD = D - AC*frameSize - CD * frameSize
     return cA, cB, cC, cD
 
 def calib(source, pattern_corner_coordinates, target_width, target_height,
           frame_size=0.0, fixed_translation=None, verbosity="INFO", graphical=True,
           max_allowed_validation_error=0.06, max_allowed_reconstruction_error=0.4, opt_mode="min",
-          image_selection="amplitude"):
+          image_selection="amplitude", mode="standard_range4m"):
     logging.basicConfig(level=verbosity)
 
     cc = eval("dict(" + pattern_corner_coordinates + ")")
     A, B, C, D = cc_to_coordinates(**cc)
     logger.info("Target coordinates parsed successfully. Target size [m]: AB=%.3f CD=%.3f AC=%.3f BD=%.3f ",
                 np.linalg.norm(A-B), np.linalg.norm(C-D), np.linalg.norm(A-C), np.linalg.norm(B-D))
     derr = np.linalg.norm(A + (B-A) + (C-A) - D)
@@ -451,15 +419,15 @@
     if np.abs(derr) > 0.01:
         logger.error("The target coordinates are inconsistent.")
         return 1
     
     #A, B, C, D = [np.array(coordinate, dtype=float) for coordinate in eval(args.pattern_corner_coordinates)]
     fixed_translation = np.array(eval(fixed_translation)).squeeze() if fixed_translation is not None else None
     
-    frame = sources.getFrame(source)
+    frame = sources.getFrame(source, mode)
 
     if ((not np.all(np.abs(frame["camRefToOpticalSystem"]["trans"]) < 0.08)) or
         (not np.all(np.abs(frame["camRefToOpticalSystem"]["rot"]) < 5*np.pi/180))):
         logger.error("Cam ref to optical system seems to be non-plausible. Please make sure that you have reset the extrinsic calibration before applying the calibration.")
         raise RuntimeError("Calibration is not resetted (trans=%s rot=%s)." % (frame["camRefToOpticalSystem"]["trans"], 
                                                                                frame["camRefToOpticalSystem"]["rot"]))
     try:
@@ -497,20 +465,20 @@
     parser.add_argument('-g', '--graphical', action="store_true", default=False, help="Show plots.")
     parser.add_argument('-tw', '--target_width', default=6, type=int, help="number of inner corners per chessboard row (i.e. in AB direction).")
     parser.add_argument('-th', '--target_height', default=4, type=int, help="number of inner corners per chessboard column (i.e. in AC direction).")
     parser.add_argument('-mve', '--max_allowed_validation_error', default=0.06, type=float, help='Maximum allowed validation error (default: %(default).2f) [m]')
     parser.add_argument('-mre', '--max_allowed_reconstruction_error', default=0.4, type=float, help='Maximum allowed reconstruction error (default: %(default).2f) [px]')
     parser.add_argument('-om', '--opt_mode', default="min", choices=["min", "lsq", "minabs"], help='"min" uses scipy.optimize.minimize and in a least squares setting, "lsq" uses scipy.optimize.least_squares, "minabs" uses scipy.minimize in a mean absolute error setting.')
     parser.add_argument('-is', '--image_selection', default="amplitude", choices=["amplitude", "reflectivity"], help="choose whether to use amplitude or reflectivity image.")
+    parser.add_argument("-m", "--mode", default="standard_range4m", choices=["standard_range4m", "standard_range2m", "extrinsic_calib"], help="choose the mode of the port.")
     parser.add_argument("source", type=str, default="ad://192.168.0.69/port2",
                         help="The source to be used. Currently supported schemes: "
                              "'adlive://<ip>/port<C>' use algo debug input with specified ip address and camera port number C=0..5 (requires imeas)."
                              "'adrec://<h5path> use algo debug input stored in a h5 file."
                              "'ifm3dpy://<ip>/port<C>' use ifm3d library input with specified ip address and camera port number C=0..5 (requires ifm3dpy)."
-
                         )
     # TODO: add vision assist h5 file mode
     args = parser.parse_args()
     calib(**vars(args))
 
 if __name__ == "__main__":
     main()
```

## o3r_algo_utilities/calib/point_correspondences.py

```diff
@@ -3,14 +3,15 @@
 #
 # THE PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.
 #
 import logging
 import numpy as np
 import cv2
 from scipy import optimize
+from o3r_algo_utilities.rotmat import rotMat, rotMatReverse
 
 logger = logging.getLogger(__name__)
 
 def find_transformation(world, imgpoints, invIC, fixed_translation, binning, camRefToOpticalSystem, optMode):
     '''
     Estimates a rotation r, and translation t such that
         inverse_intrinsic_projection(R.T*(world - t)) approx. imgpoints
@@ -129,56 +130,14 @@
     '''
     if inverse:
         return rotMat(*r).T.dot(data - np.array(t)[..., np.newaxis])
     else:
         return rotMat(*r).dot(data) + np.array(t)[..., np.newaxis]
 
 
-def rotMat(*rot_xyz):
-    '''
-    :return: rotation matrix from rotX, rotY, rotZ
-    '''
-    R = np.eye(3)
-    for i, alpha in enumerate(rot_xyz):
-        lr = np.eye(3)
-        lr[(i + 1) % 3, (i + 1) % 3] = np.cos(alpha)
-        lr[(i + 2) % 3, (i + 2) % 3] = np.cos(alpha)
-        lr[(i + 1) % 3, (i + 2) % 3] = -np.sin(alpha)
-        lr[(i + 2) % 3, (i + 1) % 3] = np.sin(alpha)
-        R = R.dot(lr)
-    return R
-
-
-def rotMatReverse(R):
-    '''
-    :return:rotX, rotY, rotZ from a rotation matrix R
-    '''
-    alpha = np.arctan2(R[1, 2], R[2, 2])
-    c2 = np.sqrt(R[0, 0] ** 2 + R[0, 1] ** 2)
-    beta = np.arctan2(-R[0, 2], c2)
-    s1 = np.sin(alpha)
-    c1 = np.cos(alpha)
-    gamma = np.arctan2(s1 * R[2, 0] - c1 * R[1, 0], c1 * R[1, 1] - s1 * R[2, 1])
-    rotX, rotY, rotZ = -alpha, -beta, -gamma
-    if rotX < -np.pi / 2 or rotX > np.pi / 2:
-        if rotX < 0:
-            rotX += np.pi
-        else:
-            rotX -= np.pi
-        rotY = np.pi - rotY
-        if rotY < -np.pi:
-            rotY += 2 * np.pi
-        if rotY > np.pi:
-            rotY -= 2 * np.pi
-        rotZ = rotZ + np.pi
-        if rotZ > np.pi:
-            rotZ -= 2 * np.pi
-    return rotX, rotY, rotZ
-
-
 def inverse_intrinsic_projection(camXYZ, invIC, binning, camRefToOpticalSystem):
     '''
     3D points to pixel coordinates
     :param camXYZ: 3xn camera coordinates
     :param invIC: inverse intrinsic calibration
     :param internalTransRot: (forward) internal TransRot
     :return: 2xn pixel coordinates
```

## o3r_algo_utilities/calib/sources.py

```diff
@@ -1,32 +1,38 @@
 """
 This module encapsulates the different sources which might be used by the calibration.
 """
 import logging
 import struct
 import numpy as np
+import scipy.ndimage as ndi
 import h5py
 from o3r_algo_utilities import o3r_uncompress_di
-import ifm3dpy
+try:
+    import ifm3dpy
+except ImportError:
+    ifm3dpy = None
 
 try:
     from ifm_imeas.imeas_tools import unpack_imeas
 except ImportError:
     # Optional algo debug h5 files / algo debug live input are not supported.
     unpack_imeas = None
 
 try:
     from ifm_o3r_algodebug.Receiver import ADReceiver
 except ImportError:
     # Optional algo debug live input is not supported.
     ADReceiver = None
 
 logger = logging.getLogger(__name__)
-    
-def getFrame(source):
+if ifm3dpy is None:
+    logger.warning("ifm3dpy is not installed. Consider to depend your project to 'o3r_algo_utilities[ifm3dpy]'")
+
+def getFrame(source, mode):
     """
     :param source: Specifies the source the following formats are supported:
         'adrec://<pathToFile>' use an algo debug hdf5 recording stored in <pathToFile> 
             (requires the ifm proprietary library imeas)
         'adlive://<ip>/port<camPort>' use a live connection to the camera specified 
             by <ip> and <camPort> (0..5)
         'ifm3dpy://<ip>/port<camPort>' use a live connection to the camera specified 
@@ -42,26 +48,35 @@
         if ADReceiver is None:
             raise RuntimeError("The tool ifm_o3r_algodebug is required for algo debug live input.")
         ip_port = source[len("adlive://"):]
         ip, port = ip_port.split("/")
         if port.startswith("port"):
             port = port[len("port"):]
         port = int(port)
-        frame = grab_algo_debug(ip, port)
+        frame = grab_algo_debug(ip, port, mode)
     elif source.startswith("ifm3dpy://"):
         ip_port = source[len("ifm3dpy://"):]
         ip, port = ip_port.split("/")
         if port.startswith("port"):
             port = port[len("port"):]
         port = int(port)
 
-        frame = grab_ifm3d_frame(ip,port)
+        frame = grab_ifm3d_frame(ip, port, mode)
         
     else:
-        raise RuntimeError("cannot interpret source.")    
+        raise RuntimeError("cannot interpret source.")
+
+    conf = frame["C"]
+    img = frame["A"]
+    # replace suspect pixel and invalid amplitudes with a median-ed version
+    M = np.logical_or((conf & 128) == 128, img < 0)
+    if np.sum(M) > 0:
+        img[M] = (ndi.median_filter(img, (3, 3)))[M]
+    img[img < 0] = 0
+
     return frame
     
 def load_algo_debug_recording(h5file):
     """
     Parses the last frame of an algo debug measurement while ignoring the referenced calibration.
     
     :param h5file: The path of the h5 file to be read.
@@ -78,110 +93,151 @@
     d,_ = unpack_imeas(f["streams"]["o3r_di_0"][-1][0].tobytes(), add_toplevel_wrapper=False)
     f.close()
     
     ifout_compr = d["irs2381/ifout_compr"]
 
     return proc_algo_debug(calib, ifout_compr)
 
-def grab_algo_debug(ip, port):
+def grab_algo_debug(ip, port, mode):
     calib = None
     ifout_compr = None
-    with ADReceiver(ip, "port%d"%port, autoInterpret=True, xmlrpcTimeout=3, autostart=True) as rcv:
-        logger.debug("receiving frame ...")
-        cnt = 0
-        ifout_compr = None
-        while cnt < 10:
-            data = rcv.get(timeout=3)
-            cnt += 1
-            if "irs2381/calib" in data:
-                calib = data["irs2381/calib"]
-            if "irs2381/ifout_compr" in data:
-                # use 2m mode if available
-                if ifout_compr is None or data["irs2381/ifout_compr"].measurementRangeMax < ifout_compr.measurementRangeMax:
-                    ifout_compr = data["irs2381/ifout_compr"]
-        if calib is None or ifout_compr is None:
-            raise RuntimeError("Could not grab algo debug frame from specified address.")
-
-    return proc_algo_debug(calib, ifout_compr)
+    o3r = ifm3dpy.O3R(ip=ip)
+    oldConfig=o3r.get([f"/ports/port{port}"])
+    try:
+        # setting extrinsic to zero is not strictly necessary for the algo debug frames, but we do it nevertheless to
+        # be similar to ifm3d grabbing
+        o3r=set_extrinsic_zero(o3r, port, mode)
+        with ADReceiver(ip, "port%d"%port, autoInterpret=True, xmlrpcTimeout=3, autostart=True) as rcv:
+            logger.debug("receiving frame ...")
+            cnt = 0
+            ifout_compr = None
+            while cnt < 10:
+                data = rcv.get(timeout=3)
+                cnt += 1
+                if "irs2381/calib" in data:
+                    calib = data["irs2381/calib"]
+                if "irs2381/ifout_compr" in data:
+                    # use 2m mode if available
+                    if ifout_compr is None or data["irs2381/ifout_compr"].measurementRangeMax < ifout_compr.measurementRangeMax:
+                        ifout_compr = data["irs2381/ifout_compr"]
+            if calib is None or ifout_compr is None:
+                raise RuntimeError("Could not grab algo debug frame from specified address.")
+            frame = proc_algo_debug(calib, ifout_compr)
+        
+        # need to grab another frame with "normal" mode for validation purpose
+        o3r=set_extrinsic_zero(o3r, port, "standard_range4m")
+        with ADReceiver(ip, "port%d"%port, autoInterpret=True, xmlrpcTimeout=3, autostart=True) as rcv:
+            logger.debug("receiving frame ...")
+            cnt = 0
+            ifout_compr = None
+            while cnt < 10:
+                data = rcv.get(timeout=3)
+                cnt += 1
+                if "irs2381/calib" in data:
+                    calib = data["irs2381/calib"]
+                if "irs2381/ifout_compr" in data:
+                    # use 2m mode if available
+                    if ifout_compr is None or data["irs2381/ifout_compr"].measurementRangeMax < ifout_compr.measurementRangeMax:
+                        ifout_compr = data["irs2381/ifout_compr"]
+            if calib is None or ifout_compr is None:
+                raise RuntimeError("Could not grab algo debug frame from specified address.")
+            f2 = proc_algo_debug(calib, ifout_compr)
+            frame.update({
+                'D': f2["D"],
+                'X': f2["X"],
+                'Y': f2["Y"],
+                'Z': f2["Z"],
+            })
+        
+    finally:
+        o3r.set(oldConfig)
+    return frame 
 
 def proc_algo_debug(calib, ifout_compr):
     # ignore the currently parametrized calibration
     opticToUserTrans = np.array([getattr(calib.intrinsicCalibration.camRefToOpticalSystem, "trans"+a) for a in "XYZ"])
     opticToUserRot = np.array([getattr(calib.intrinsicCalibration.camRefToOpticalSystem, "rot"+a) for a in "XYZ"])
     X,Y,Z,D = o3r_uncompress_di.xyzdFromDistance(np.array(ifout_compr.distance), ifout_compr.distanceResolution, 
                                                  opticToUserTrans, opticToUserRot,
                                                  ifout_compr.intrinsicCalib.modelID,
                                                  ifout_compr.intrinsicCalib.modelParameters,
                                                  ifout_compr.width, ifout_compr.height)
     A = o3r_uncompress_di.convertAmplitude(np.array(ifout_compr.amplitude), ifout_compr.amplitudeResolution, ifout_compr.width, ifout_compr.height)
     R = np.reshape(ifout_compr.reflectivity, (ifout_compr.height, ifout_compr.width))
-    res = dict(X=X,Y=Y,Z=Z,D=D,A=A,R=R,
+    res = dict(X=X,Y=Y,Z=Z,D=D,A=A,R=R,C=np.reshape(ifout_compr.confidence[:A.size], A.shape),
                camRefToOpticalSystem=dict(trans=opticToUserTrans,rot=opticToUserRot),
                intrinsic=dict(modelID=ifout_compr.intrinsicCalib.modelID,modelParameters=np.array(ifout_compr.intrinsicCalib.modelParameters)),
                inverseIntrinsic=dict(modelID=ifout_compr.inverseIntrinsicCalib.modelID,modelParameters=np.array(ifout_compr.inverseIntrinsicCalib.modelParameters)),
                )
     return res
 
-def set_extrinsic_zero(o3r_object,port):
+def set_extrinsic_zero(o3r_object, port, mode):
     port=f"port{port}"
-    o3r_object.set({'ports':{port:{'state':'CONF'}}})
+    logger.info("Resetting /ports/%s", port)
+    o3r_object.reset("/ports/%s" % port)
+    o3r_object.set({'ports':{port:{'state':'CONF', 'mode': mode}}})
     o3r_object.set({'ports':{port:{'processing':{'extrinsicHeadToUser': {'rotX': 0.0,'rotY': 0.0, 'rotZ': 0.0, 'transX': 0.0, 'transY': 0.0, 'transZ': 0.0}}}}})
     o3r_object.set({'ports':{port:{'state':'RUN'}}})
 
     return o3r_object
 
-def grab_ifm3d_frame(ip,port):
-    ifm3dpy_version = tuple(int(x) for x in ifm3dpy.__version__.split("."))
-    if ifm3dpy_version < (1,0,0):
-        logger.warning("Using ifm3dpy legacy version. Consider updating to a version >= 1.0.1")
-        # legacy API
-        o3r=ifm3dpy.O3RCamera(ip)
-        final_port=o3r.port("port%d" %port).pcic_port
-
-        oldCalib=o3r.get([f"/ports/port{port}/processing/extrinsicHeadToUser"])
-        try:  
-            o3r=set_extrinsic_zero(o3r,port)
-            frame_grabber=ifm3dpy.FrameGrabber(o3r,pcic_port=final_port)
-            im = ifm3dpy.ImageBuffer()
-            if frame_grabber.wait_for_frame(im, 10000)==False:
-                raise ValueError #Exception('fg-timeout on ' + port + ' reached')
-            xyz=im.xyz_image()
-            invIntrinsic=im.inverse_intrinsics()
-            invIntrinsic=np.array(invIntrinsic,dtype=float)
-            frame = {'A': im.amplitude_image(),'D': im.distance_image(),'X':xyz[:,:,0],'Y':xyz[:,:,1],'Z':xyz[:,:,2],'R': np.zeros((172, 224)),'inverseIntrinsic': dict(modelID=1,modelParameters=invIntrinsic),
-                    'camRefToOpticalSystem': dict(trans=np.array(im.extrinsics()[0:3]), rot=np.array(im.extrinsics()[3:6]) )}
-        finally:
-            o3r.set(oldCalib)
-    else:
-        if ifm3dpy_version == (1,0,0):
-            raise RuntimeError("Need a later version due to issues in ifm3dpy 1.0.0")
-        # updated API
-        o3r = ifm3dpy.O3R(ip=ip)
-        final_port = o3r.get([f"/ports/port{port}/data/pcicTCPPort"])["ports"][f"port{port}"]["data"]["pcicTCPPort"]
-        oldCalib=o3r.get([f"/ports/port{port}/processing/extrinsicHeadToUser"])
-        try:  
-            o3r=set_extrinsic_zero(o3r,port)
+def grab_ifm3d_frame(ip, port, mode):
+    ifm3dpy_version = tuple(int(x.split("+")[0]) for x in ifm3dpy.__version__.split(".")[:3])
+    if ifm3dpy_version <= (1,0,0):
+        raise RuntimeError("Need a later version due to issues in ifm3dpy 1.0.0")
+    if mode == "extrinsic_calib" and ifm3dpy_version <= (1,2,2):
+        raise RuntimeError("Need a later version of ifm3dpy for using extrinsic_calib mode")
+    # updated API
+    o3r = ifm3dpy.O3R(ip=ip)
+    final_port = o3r.get([f"/ports/port{port}/data/pcicTCPPort"])["ports"][f"port{port}"]["data"]["pcicTCPPort"]
+    oldConfig=o3r.get([f"/ports/port{port}"])
+    try:
+        o3r=set_extrinsic_zero(o3r, port, mode)
+        frame_grabber=ifm3dpy.FrameGrabber(o3r,pcic_port=final_port)
+        frame_grabber.start()
+        ok, frame = frame_grabber.wait_for_frame().wait_for(timeout_ms=10000)
+        if not ok:
+            raise ValueError #Exception('fg-timeout on ' + port + ' reached')
+        xyz=frame.get_buffer(ifm3dpy.buffer_id.XYZ)
+        ampl=frame.get_buffer(ifm3dpy.buffer_id.NORM_AMPLITUDE_IMAGE)
+        conf=frame.get_buffer(ifm3dpy.buffer_id.CONFIDENCE_IMAGE)
+        dist=frame.get_buffer(ifm3dpy.buffer_id.RADIAL_DISTANCE_IMAGE)
+        refl=frame.get_buffer(ifm3dpy.buffer_id.REFLECTIVITY)
+        invIntrinsic = frame.get_buffer(ifm3dpy.buffer_id.INVERSE_INTRINSIC_CALIBRATION).tobytes()
+        invIntrinsicModelID, *invIntrinsicModelParams = struct.unpack("<I32f", invIntrinsic)
+        extrinsics = frame.get_buffer(ifm3dpy.buffer_id.EXTRINSIC_CALIB).flatten()
+        result = {
+            'A': ampl,
+            'C': conf,
+            'D': dist,
+            'X': xyz[:,:,0],
+            'Y': xyz[:,:,1],
+            'Z': xyz[:,:,2],
+            'R': refl,
+            'inverseIntrinsic': dict(modelID=invIntrinsicModelID,modelParameters=invIntrinsicModelParams),
+            'camRefToOpticalSystem': dict(trans=extrinsics[0:3], rot=extrinsics[3:6])
+        }
+        if mode == "extrinsic_calib":
+            # need to grab another frame with "normal" mode for validation purpose
+            frame_grabber.stop()
             frame_grabber=ifm3dpy.FrameGrabber(o3r,pcic_port=final_port)
+            o3r = set_extrinsic_zero(o3r, port, "standard_range4m")
             frame_grabber.start()
             ok, frame = frame_grabber.wait_for_frame().wait_for(timeout_ms=10000)
             if not ok:
                 raise ValueError #Exception('fg-timeout on ' + port + ' reached')
             xyz=frame.get_buffer(ifm3dpy.buffer_id.XYZ)
-            ampl=frame.get_buffer(ifm3dpy.buffer_id.NORM_AMPLITUDE_IMAGE)
             dist=frame.get_buffer(ifm3dpy.buffer_id.RADIAL_DISTANCE_IMAGE)
-            refl=frame.get_buffer(ifm3dpy.buffer_id.REFLECTIVITY)
             invIntrinsic = frame.get_buffer(ifm3dpy.buffer_id.INVERSE_INTRINSIC_CALIBRATION).tobytes()
             invIntrinsicModelID, *invIntrinsicModelParams = struct.unpack("<I32f", invIntrinsic)
             extrinsics = frame.get_buffer(ifm3dpy.buffer_id.EXTRINSIC_CALIB).flatten()
-            frame = {
-                'A': ampl,
+            result.update({
                 'D': dist,
                 'X': xyz[:,:,0],
                 'Y': xyz[:,:,1],
                 'Z': xyz[:,:,2],
-                'R': refl,
                 'inverseIntrinsic': dict(modelID=invIntrinsicModelID,modelParameters=invIntrinsicModelParams),
                 'camRefToOpticalSystem': dict(trans=extrinsics[0:3], rot=extrinsics[3:6])
-            }
-        finally:
-            o3r.set(oldCalib)
-    return frame
+            })
+    finally:
+        o3r.set(oldConfig)
+    return result
```

## Comparing `o3r_algo_utilities-1.0.8.dist-info/LICENSE` & `o3r_algo_utilities-1.1.2.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `o3r_algo_utilities-1.0.8.dist-info/METADATA` & `o3r_algo_utilities-1.1.2.dist-info/METADATA`

 * *Files 15% similar despite different names*

```diff
@@ -1,23 +1,24 @@
 Metadata-Version: 2.1
 Name: o3r-algo-utilities
-Version: 1.0.8
+Version: 1.1.2
 Summary: Algorithm examples related to the ifm O3R product.
 Home-page: UNKNOWN
 License: Apache 2.0 License
 Keywords: ifm,o3r,point_cloud
 Platform: UNKNOWN
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Programming Language :: Python :: 3
 Requires-Dist: numpy (>=1.11.0)
 Requires-Dist: opencv-python (>=4.5.3)
 Requires-Dist: scipy (>=1.7)
 Requires-Dist: h5py (>=3.2)
 Requires-Dist: matplotlib (>=3.4)
-Requires-Dist: ifm3dpy (>=1.1.1)
+Provides-Extra: ifm3dpy
+Requires-Dist: ifm3dpy (>=1.2.6) ; extra == 'ifm3dpy'
 Provides-Extra: imeas
 Requires-Dist: ifm-imeas (>=4.0) ; extra == 'imeas'
 Requires-Dist: six ; extra == 'imeas'
 Provides-Extra: jupyter
 Requires-Dist: jupyterlab (>=3.1) ; extra == 'jupyter'
 Requires-Dist: ipympl (>=0.7.0) ; extra == 'jupyter'
```

