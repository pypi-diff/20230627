# Comparing `tmp/general_superstaq-0.3.9-py3-none-any.whl.zip` & `tmp/general_superstaq-0.4.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,42 +1,39 @@
-Zip file size: 45833 bytes, number of entries: 40
--rw-r--r--  2.0 unx      902 b- defN 23-Feb-01 20:31 general_superstaq/__init__.py
--rw-r--r--  2.0 unx       64 b- defN 23-Feb-01 20:31 general_superstaq/_init_vars.py
--rw-r--r--  2.0 unx       22 b- defN 23-Feb-01 20:31 general_superstaq/_version.py
--rw-r--r--  2.0 unx      246 b- defN 23-Feb-01 20:31 general_superstaq/_version_test.py
--rw-r--r--  2.0 unx     7009 b- defN 23-Feb-01 20:31 general_superstaq/finance.py
--rw-r--r--  2.0 unx     3872 b- defN 23-Feb-01 20:31 general_superstaq/finance_test.py
--rw-r--r--  2.0 unx     4888 b- defN 23-Feb-01 20:31 general_superstaq/logistics.py
--rw-r--r--  2.0 unx     3258 b- defN 23-Feb-01 20:31 general_superstaq/logistics_test.py
--rw-r--r--  2.0 unx       76 b- defN 23-Feb-01 20:31 general_superstaq/py.typed
--rw-r--r--  2.0 unx     1447 b- defN 23-Feb-01 20:31 general_superstaq/qubo.py
--rw-r--r--  2.0 unx      820 b- defN 23-Feb-01 20:31 general_superstaq/qubo_test.py
--rw-r--r--  2.0 unx      987 b- defN 23-Feb-01 20:31 general_superstaq/resource_estimate.py
--rw-r--r--  2.0 unx      328 b- defN 23-Feb-01 20:31 general_superstaq/resource_estimate_test.py
--rw-r--r--  2.0 unx      801 b- defN 23-Feb-01 20:31 general_superstaq/serialization.py
--rw-r--r--  2.0 unx      271 b- defN 23-Feb-01 20:31 general_superstaq/serialization_test.py
--rw-r--r--  2.0 unx    13618 b- defN 23-Feb-01 20:31 general_superstaq/superstaq_client.py
--rw-r--r--  2.0 unx    22302 b- defN 23-Feb-01 20:31 general_superstaq/superstaq_client_test.py
--rw-r--r--  2.0 unx     1461 b- defN 23-Feb-01 20:31 general_superstaq/superstaq_exceptions.py
--rw-r--r--  2.0 unx     1677 b- defN 23-Feb-01 20:31 general_superstaq/superstaq_exceptions_test.py
--rw-r--r--  2.0 unx     2305 b- defN 23-Feb-01 20:31 general_superstaq/typing.py
--rw-r--r--  2.0 unx     6412 b- defN 23-Feb-01 20:31 general_superstaq/user_config.py
--rw-r--r--  2.0 unx     5530 b- defN 23-Feb-01 20:31 general_superstaq/user_config_test.py
--rw-r--r--  2.0 unx      359 b- defN 23-Feb-01 20:31 general_superstaq/check/__init__.py
--rw-r--r--  2.0 unx     2636 b- defN 23-Feb-01 20:31 general_superstaq/check/all_.py
--rw-r--r--  2.0 unx     1147 b- defN 23-Feb-01 20:31 general_superstaq/check/build_docs.py
--rw-r--r--  2.0 unx     8910 b- defN 23-Feb-01 20:31 general_superstaq/check/check_utils.py
--rw-r--r--  2.0 unx     3774 b- defN 23-Feb-01 20:31 general_superstaq/check/configs.py
--rw-r--r--  2.0 unx     2075 b- defN 23-Feb-01 20:31 general_superstaq/check/coverage_.py
--rw-r--r--  2.0 unx      839 b- defN 23-Feb-01 20:31 general_superstaq/check/flake8_.py
--rw-r--r--  2.0 unx     1699 b- defN 23-Feb-01 20:31 general_superstaq/check/format_.py
--rw-r--r--  2.0 unx      871 b- defN 23-Feb-01 20:31 general_superstaq/check/mypy_.py
--rw-r--r--  2.0 unx     1567 b- defN 23-Feb-01 20:31 general_superstaq/check/pylint_.py
--rw-r--r--  2.0 unx     2794 b- defN 23-Feb-01 20:31 general_superstaq/check/pytest_.py
--rw-r--r--  2.0 unx     9373 b- defN 23-Feb-01 20:31 general_superstaq/check/requirements.py
--rw-r--r--  2.0 unx     2303 b- defN 23-Feb-01 20:31 general_superstaq/check/setup.cfg
--rw-r--r--  2.0 unx    11349 b- defN 23-Feb-01 20:31 general_superstaq-0.3.9.dist-info/LICENSE
--rw-r--r--  2.0 unx     1432 b- defN 23-Feb-01 20:31 general_superstaq-0.3.9.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Feb-01 20:31 general_superstaq-0.3.9.dist-info/WHEEL
--rw-r--r--  2.0 unx       18 b- defN 23-Feb-01 20:31 general_superstaq-0.3.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3615 b- defN 23-Feb-01 20:31 general_superstaq-0.3.9.dist-info/RECORD
-40 files, 133149 bytes uncompressed, 39959 bytes compressed:  70.0%
+Zip file size: 40983 bytes, number of entries: 37
+-rw-r--r--  2.0 unx     1057 b- defN 23-Jun-27 19:52 general_superstaq/__init__.py
+-rw-r--r--  2.0 unx       64 b- defN 23-Jun-27 19:52 general_superstaq/_init_vars.py
+-rw-r--r--  2.0 unx       22 b- defN 23-Jun-27 19:52 general_superstaq/_version.py
+-rw-r--r--  2.0 unx      292 b- defN 23-Jun-27 19:52 general_superstaq/_version_test.py
+-rw-r--r--  2.0 unx       76 b- defN 23-Jun-27 19:52 general_superstaq/py.typed
+-rw-r--r--  2.0 unx      996 b- defN 23-Jun-27 19:52 general_superstaq/qubo.py
+-rw-r--r--  2.0 unx      865 b- defN 23-Jun-27 19:52 general_superstaq/qubo_test.py
+-rw-r--r--  2.0 unx     1029 b- defN 23-Jun-27 19:52 general_superstaq/resource_estimate.py
+-rw-r--r--  2.0 unx      373 b- defN 23-Jun-27 19:52 general_superstaq/resource_estimate_test.py
+-rw-r--r--  2.0 unx      926 b- defN 23-Jun-27 19:52 general_superstaq/serialization.py
+-rw-r--r--  2.0 unx      316 b- defN 23-Jun-27 19:52 general_superstaq/serialization_test.py
+-rw-r--r--  2.0 unx    18523 b- defN 23-Jun-27 19:52 general_superstaq/superstaq_client.py
+-rw-r--r--  2.0 unx    24407 b- defN 23-Jun-27 19:52 general_superstaq/superstaq_client_test.py
+-rw-r--r--  2.0 unx     1560 b- defN 23-Jun-27 19:52 general_superstaq/superstaq_exceptions.py
+-rw-r--r--  2.0 unx     1763 b- defN 23-Jun-27 19:52 general_superstaq/superstaq_exceptions_test.py
+-rw-r--r--  2.0 unx     2232 b- defN 23-Jun-27 19:52 general_superstaq/typing.py
+-rw-r--r--  2.0 unx     8830 b- defN 23-Jun-27 19:52 general_superstaq/user_config.py
+-rw-r--r--  2.0 unx     8537 b- defN 23-Jun-27 19:52 general_superstaq/user_config_test.py
+-rw-r--r--  2.0 unx     2078 b- defN 23-Jun-27 19:52 general_superstaq/validation.py
+-rw-r--r--  2.0 unx     1560 b- defN 23-Jun-27 19:52 general_superstaq/validation_test.py
+-rw-r--r--  2.0 unx      359 b- defN 23-Jun-27 19:52 general_superstaq/check/__init__.py
+-rw-r--r--  2.0 unx     2809 b- defN 23-Jun-27 19:52 general_superstaq/check/all_.py
+-rw-r--r--  2.0 unx     1199 b- defN 23-Jun-27 19:52 general_superstaq/check/build_docs.py
+-rw-r--r--  2.0 unx    11666 b- defN 23-Jun-27 19:52 general_superstaq/check/check_utils.py
+-rw-r--r--  2.0 unx     3820 b- defN 23-Jun-27 19:52 general_superstaq/check/configs.py
+-rw-r--r--  2.0 unx     2117 b- defN 23-Jun-27 19:52 general_superstaq/check/coverage_.py
+-rw-r--r--  2.0 unx      896 b- defN 23-Jun-27 19:52 general_superstaq/check/flake8_.py
+-rw-r--r--  2.0 unx     1873 b- defN 23-Jun-27 19:52 general_superstaq/check/format_.py
+-rw-r--r--  2.0 unx      926 b- defN 23-Jun-27 19:52 general_superstaq/check/mypy_.py
+-rw-r--r--  2.0 unx     1525 b- defN 23-Jun-27 19:52 general_superstaq/check/pylint_.py
+-rw-r--r--  2.0 unx     2404 b- defN 23-Jun-27 19:52 general_superstaq/check/pytest_.py
+-rw-r--r--  2.0 unx     9128 b- defN 23-Jun-27 19:52 general_superstaq/check/requirements.py
+-rw-r--r--  2.0 unx     2562 b- defN 23-Jun-27 19:52 general_superstaq/check/setup.cfg
+-rw-r--r--  2.0 unx     1578 b- defN 23-Jun-27 19:52 general_superstaq-0.4.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-27 19:52 general_superstaq-0.4.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       18 b- defN 23-Jun-27 19:52 general_superstaq-0.4.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3345 b- defN 23-Jun-27 19:52 general_superstaq-0.4.0.dist-info/RECORD
+37 files, 121823 bytes uncompressed, 35537 bytes compressed:  70.8%
```

## zipnote {}

```diff
@@ -6,26 +6,14 @@
 
 Filename: general_superstaq/_version.py
 Comment: 
 
 Filename: general_superstaq/_version_test.py
 Comment: 
 
-Filename: general_superstaq/finance.py
-Comment: 
-
-Filename: general_superstaq/finance_test.py
-Comment: 
-
-Filename: general_superstaq/logistics.py
-Comment: 
-
-Filename: general_superstaq/logistics_test.py
-Comment: 
-
 Filename: general_superstaq/py.typed
 Comment: 
 
 Filename: general_superstaq/qubo.py
 Comment: 
 
 Filename: general_superstaq/qubo_test.py
@@ -60,14 +48,20 @@
 
 Filename: general_superstaq/user_config.py
 Comment: 
 
 Filename: general_superstaq/user_config_test.py
 Comment: 
 
+Filename: general_superstaq/validation.py
+Comment: 
+
+Filename: general_superstaq/validation_test.py
+Comment: 
+
 Filename: general_superstaq/check/__init__.py
 Comment: 
 
 Filename: general_superstaq/check/all_.py
 Comment: 
 
 Filename: general_superstaq/check/build_docs.py
@@ -99,23 +93,20 @@
 
 Filename: general_superstaq/check/requirements.py
 Comment: 
 
 Filename: general_superstaq/check/setup.cfg
 Comment: 
 
-Filename: general_superstaq-0.3.9.dist-info/LICENSE
-Comment: 
-
-Filename: general_superstaq-0.3.9.dist-info/METADATA
+Filename: general_superstaq-0.4.0.dist-info/METADATA
 Comment: 
 
-Filename: general_superstaq-0.3.9.dist-info/WHEEL
+Filename: general_superstaq-0.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: general_superstaq-0.3.9.dist-info/top_level.txt
+Filename: general_superstaq-0.4.0.dist-info/top_level.txt
 Comment: 
 
-Filename: general_superstaq-0.3.9.dist-info/RECORD
+Filename: general_superstaq-0.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## general_superstaq/__init__.py

```diff
@@ -1,39 +1,37 @@
 from general_superstaq._init_vars import API_URL, API_VERSION
 from general_superstaq._version import __version__
 from general_superstaq.resource_estimate import ResourceEstimate
 from general_superstaq.superstaq_exceptions import (
-    SuperstaQException,
-    SuperstaQModuleNotFoundException,
-    SuperstaQNotFoundException,
-    SuperstaQUnsuccessfulJobException,
+    SuperstaqException,
+    SuperstaqModuleNotFoundException,
+    SuperstaqNotFoundException,
+    SuperstaqUnsuccessfulJobException,
 )
+from general_superstaq.typing import MaxSharpeJson, MinVolJson, QuboModel, TSPJson, WareHouseJson
 
-from . import (
-    finance,
-    logistics,
-    qubo,
-    serialization,
-    superstaq_client,
-    superstaq_exceptions,
-    typing,
-    user_config,
-)
+from . import qubo, serialization, superstaq_client, superstaq_exceptions, user_config, validation
 
 __all__ = [
     "__version__",
     "API_URL",
     "API_VERSION",
-    "SuperstaQException",
-    "SuperstaQModuleNotFoundException",
-    "SuperstaQNotFoundException",
-    "SuperstaQUnsuccessfulJobException",
+    "SuperstaqException",
+    "SuperstaqModuleNotFoundException",
+    "SuperstaqNotFoundException",
+    "SuperstaqUnsuccessfulJobException",
+    "MaxSharpeJson",
+    "MinVolJson",
+    "QuboModel",
+    "TSPJson",
+    "WareHouseJson",
     "finance",
     "logistics",
     "qubo",
     "ResourceEstimate",
     "serialization",
     "superstaq_client",
     "superstaq_exceptions",
     "typing",
     "user_config",
+    "validation",
 ]
```

## general_superstaq/_version.py

```diff
@@ -1 +1 @@
-__version__ = "0.3.9"
+__version__ = "0.4.0"
```

## general_superstaq/_version_test.py

```diff
@@ -1,11 +1,11 @@
 import packaging.version
 
 import general_superstaq as gss
 
 
-def test_version() -> None:
+def test_version() -> None:  # pylint: disable=missing-function-docstring
     assert (
         packaging.version.Version("0.1.0")
         < packaging.version.parse(gss.__version__)
         < packaging.version.Version("1.0.0")
     )
```

## general_superstaq/qubo.py

```diff
@@ -1,44 +1,30 @@
 from typing import Dict
 
 import numpy as np
 import numpy.typing as npt
 import qubovert as qv
 
 import general_superstaq as gss
-from general_superstaq.typing import QuboModel
 
 
 def read_json_qubo_result(json_dict: Dict[str, str]) -> npt.NDArray[np.int_]:
-    """Reads out returned JSON from SuperstaQ API's QUBO endpoint.
+    """Reads out returned JSON from Superstaq API's QUBO endpoint.
     Args:
-        json_dict: a JSON dictionary matching the format returned by /qubo endpoint
+        json_dict: A JSON dictionary matching the format returned by the /qubo endpoint.
     Returns:
-        a numpy.recarray containing the results of the optimization.
+        A numpy.recarray containing the results of the optimization.
     """
     return gss.serialization.deserialize(json_dict["solution"])
 
 
-def convert_qubo_to_model(qubo: qv.QUBO) -> QuboModel:
+def convert_qubo_to_model(qubo: qv.QUBO) -> gss.QuboModel:
     """Takes in a qubovert QUBO and converts it to the format required by the /qubo endpoint API.
     Args:
-        qubo: a qubovert QUBO object.
+        qubo: A `qubovert.QUBO` object.
     Returns:
-        An equivalent qubo represent as a nested list of dictionaries.
+        An equivalent qubo represented as a nested list of dictionaries.
     """
-    model: QuboModel = []
+    model: gss.QuboModel = []
     for key, value in qubo.items():
         model.append({"keys": [str(variable) for variable in key], "value": value})
     return model
-
-
-def convert_model_to_qubo(model: QuboModel) -> qv.QUBO:
-    """Takes in qubo model transferred over the wire and converts it to the qubovert format.
-    Args:
-        model: The qubo model as specified in superstaq.web.server.
-    Returns:
-        An equivalent qubovert.QUBO object.
-    """
-    qubo_dict = {}
-    for term in model:
-        qubo_dict[tuple(term["keys"])] = term["value"]
-    return qv.QUBO(qubo_dict)
```

## general_superstaq/qubo_test.py

```diff
@@ -1,7 +1,8 @@
+# pylint: disable=missing-function-docstring
 import numpy as np
 import qubovert as qv
 
 import general_superstaq as gss
 
 
 def test_read_json_qubo_result() -> None:
```

## general_superstaq/resource_estimate.py

```diff
@@ -1,26 +1,25 @@
 from dataclasses import InitVar, dataclass
 from typing import Dict, Optional
 
 
 @dataclass
 class ResourceEstimate:
+    """A class to store data returned from a resource_estimate request."""
+
     num_single_qubit_gates: Optional[int] = None
     num_two_qubit_gates: Optional[int] = None
     depth: Optional[int] = None
     json_data: InitVar[Dict[str, int]] = None
 
     def __post_init__(self, json_data: Optional[Dict[str, int]] = None) -> None:
-        """Initializes ResourceEstimate object with JSON data, if specified
+        """Initializes `ResourceEstimate` object with JSON data, if specified.
 
         Args:
-            json_data: Optional dictionary containing JSON data from a resource_estimate request
-
-        Returns:
-            Nothing
+            json_data: Optional dictionary containing JSON data from a resource_estimate request.
         """
         if json_data is not None:
             assert "num_single_qubit_gates" in json_data
             assert "num_two_qubit_gates" in json_data
             assert "depth" in json_data
 
             self.num_single_qubit_gates = json_data["num_single_qubit_gates"]
```

## general_superstaq/resource_estimate_test.py

```diff
@@ -1,7 +1,8 @@
+# pylint: disable=missing-function-docstring
 from general_superstaq import ResourceEstimate
 
 
 def test_resource_estimate() -> None:
     json_data = {"num_single_qubit_gates": 1, "num_two_qubit_gates": 2, "depth": 3}
     expected_re = ResourceEstimate(1, 2, 3)
     constructed_re = ResourceEstimate(json_data=json_data)
```

## general_superstaq/serialization.py

```diff
@@ -1,37 +1,39 @@
 import codecs
 import pickle
 from typing import Any
 
 
-def _bytes_to_str(bytes_data: bytes) -> str:
+def bytes_to_str(bytes_data: bytes) -> str:
+    """Convert arbitrary bytes data into a string."""
     return codecs.encode(bytes_data, "base64").decode()
 
 
-def _str_to_bytes(str_data: str) -> bytes:
+def str_to_bytes(str_data: str) -> bytes:
+    """Decode the string-encoded bytes data returned by `bytes_to_str`."""
     return codecs.decode(str_data.encode(), "base64")
 
 
 def serialize(obj: Any) -> str:
     """Serialize picklable object into a string
 
     Args:
         obj: a picklable object to be serialized
 
     Returns:
         str representing the serialized object
     """
 
-    return _bytes_to_str(pickle.dumps(obj))
+    return bytes_to_str(pickle.dumps(obj))
 
 
 def deserialize(serialized_obj: str) -> Any:
     """Deserialize serialized objects
 
     Args:
         serialized_obj: a str generated via general_superstaq.serialization.serialize()
 
     Returns:
         the serialized object
     """
 
-    return pickle.loads(_str_to_bytes(serialized_obj))
+    return pickle.loads(str_to_bytes(serialized_obj))
```

## general_superstaq/serialization_test.py

```diff
@@ -1,7 +1,8 @@
+# pylint: disable=missing-function-docstring
 import general_superstaq as gss
 
 
 def test_serialization() -> None:
     obj = {"object": ["to", "serialize"]}
     serialized_obj = gss.serialization.serialize(obj)
     assert isinstance(serialized_obj, str)
```

## general_superstaq/superstaq_client.py

```diff
@@ -6,79 +6,80 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-"""Client for making requests to SuperstaQ's API."""
-
+"""Client for making requests to Superstaq's API."""
 import json
+import os
+import pathlib
 import sys
 import textwrap
 import time
 import urllib
 from typing import Any, Callable, Dict, List, Optional, Union
 
 import qubovert as qv
 import requests
 
 import general_superstaq as gss
-from general_superstaq.typing import MaxSharpeJson, MinVolJson, TSPJson, WareHouseJson
 
 
-class _SuperstaQClient:
-    """Handles calls to SuperstaQ's API.
+class _SuperstaqClient:
+    """Handles calls to Superstaq's API.
 
     Users should not instantiate this themselves,
     but instead should use `$client_superstaq.Service`.
     """
 
     RETRIABLE_STATUS_CODES = {
         requests.codes.service_unavailable,
     }
     SUPPORTED_VERSIONS = {
         gss.API_VERSION,
     }
 
     def __init__(
         self,
-        remote_host: str,
-        api_key: str,
         client_name: str,
+        api_key: Optional[str] = None,
+        remote_host: Optional[str] = None,
         api_version: str = gss.API_VERSION,
         max_retry_seconds: float = 60,  # 1 minute
         verbose: bool = False,
     ):
-        """Creates the SuperstaQClient.
+        """Creates the SuperstaqClient.
 
         Users should use `$client_superstaq.Service` instead of this class directly.
 
-        The SuperstaQClient handles making requests to the SuperstaQClient,
+        The SuperstaqClient handles making requests to the SuperstaqClient,
         returning dictionary results. It handles retry and authentication.
 
         Args:
-            remote_host: The url of the server exposing the SuperstaQ API. This will strip anything
+            remote_host: The url of the server exposing the Superstaq API. This will strip anything
                 besides the base scheme and netloc, i.e. it only takes the part of the host of
                 the form `http://example.com` of `http://example.com/test`.
-            api_key: The key used for authenticating against the SuperstaQ API.
+            api_key: The key used for authenticating against the Superstaq API.
             api_version: Which version fo the api to use, defaults to client_superstaq.API_VERSION,
                 which is the most recent version when this client was downloaded.
             max_retry_seconds: The time to continue retriable responses. Defaults to 3600.
             verbose: Whether to print to stderr and stdio any retriable errors that are encountered.
         """
 
-        self.api_key = api_key
+        self.api_key = api_key or gss.superstaq_client.find_api_key()
+        self.remote_host = remote_host or os.getenv("SUPERSTAQ_REMOTE_HOST") or gss.API_URL
         self.client_name = client_name
         self.api_version = api_version
         self.max_retry_seconds = max_retry_seconds
         self.verbose = verbose
-        url = urllib.parse.urlparse(remote_host)
+        url = urllib.parse.urlparse(self.remote_host)
         assert url.scheme and url.netloc, (
-            f"Specified remote_host {remote_host} is not a valid url, for example "
+            f"Specified remote_host {self.remote_host} is not a valid url, for example "
             "http://example.com"
         )
 
         assert (
             self.api_version in self.SUPPORTED_VERSIONS
         ), f"Only API versions {self.SUPPORTED_VERSIONS} are accepted but got {self.api_version}"
         assert max_retry_seconds >= 0, "Negative retry not possible without time machine."
@@ -89,24 +90,51 @@
             "Authorization": self.api_key,
             "Content-Type": "application/json",
             "X-Client-Name": self.client_name,
             "X-Client-Version": self.api_version,
         }
 
     def get_request(self, endpoint: str) -> Any:
+        """Performs a GET request on a given endpoint
+        Args:
+            endpoint: The endpoint to perform the GET request on
+        Returns:
+            The response of the GET request
+        """
+
         def request() -> requests.Response:
             return requests.get(
                 f"{self.url}{endpoint}",
                 headers=self.headers,
                 verify=self.verify_https,
             )
 
         return self._make_request(request).json()
 
+    def get_superstaq_version(self) -> Dict[str, Optional[str]]:
+        """Gets Superstaq version from response header
+
+        Returns:
+            A dict containing the current Superstaq version.
+        """
+
+        response = requests.get(self.url)
+        version = response.headers.get("superstaq_version")
+
+        return {"superstaq_version": version}
+
     def post_request(self, endpoint: str, json_dict: Dict[str, Any]) -> Any:
+        """Performs a POST request on a given endpoint with a given payload
+        Args:
+            endpoint: The endpoint to perform the POST request on
+            json_dict: The payload to POST
+        Returns:
+            The response of the POST request
+        """
+
         def request() -> requests.Response:
             return requests.post(
                 f"{self.url}{endpoint}",
                 json=json_dict,
                 headers=self.headers,
                 verify=self.verify_https,
             )
@@ -115,198 +143,291 @@
 
     def create_job(
         self,
         serialized_circuits: Dict[str, str],
         repetitions: int = 1,
         target: str = "ss_unconstrained_simulator",
         method: Optional[str] = None,
-        options: Optional[Dict[str, Any]] = None,
+        **kwargs: Any,
     ) -> Dict[str, List[str]]:
         """Create a job.
 
         Args:
             serialized_circuits: The serialized representation of the circuit to run.
             repetitions: The number of times to repeat the circuit. For simulation the repeated
                 sampling is not done on the server, but is passed as metadata to be recovered
                 from the returned job.
             target: Target to run on.
-            options: The different available options for creating a job.
-                - qiskit_pulse: Whether to use SuperstaQ's pulse-level optimizations for IBMQ
+            method: Which type of method to execute the circuits (noisy simulator,
+            non-noisy simulator, hardware, e.t.c)
+            kwargs: Other optimization and execution parameters.
+                - qiskit_pulse: Whether to use Superstaq's pulse-level optimizations for IBMQ
                 devices.
 
         Returns:
             The json body of the response as a dict. This does not contain populated information
             about the job, but does contain the job id.
 
         Raises:
-            An SuperstaQException if the request fails.
+            An SuperstaqException if the request fails.
         """
+        gss.validation.validate_target(target)
+        gss.validation.validate_integer_param(repetitions)
+
         json_dict: Dict[str, Any] = {
             **serialized_circuits,
             "target": target,
-            "shots": repetitions,
+            "shots": int(repetitions),
         }
 
         if method is not None:
             json_dict["method"] = method
 
-        if options is not None:
-            json_dict["options"] = json.dumps(options)
+        if kwargs:
+            json_dict["options"] = json.dumps(kwargs)
         return self.post_request("/jobs", json_dict)
 
     def get_job(self, job_id: str) -> Dict[str, str]:
-        """Get the job from the SuperstaQ API.
+        """Get the job from the Superstaq API.
 
         Args:
             job_id: The UUID of the job (returned when the job was created).
 
         Returns:
             The json body of the response as a dict.
 
         Raises:
-            SuperstaQNotFoundException: If a job with the given job_id does not exist.
-            SuperstaQException: For other API call failures.
+            SuperstaqNotFoundException: If a job with the given job_id does not exist.
+            SuperstaqException: For other API call failures.
         """
         return self.get_request(f"/job/{job_id}")
 
     def get_balance(self) -> Dict[str, float]:
         """Get the querying user's account balance in USD.
 
         Returns:
             The json body of the response as a dict.
         """
         return self.get_request("/balance")
 
+    def _accept_terms_of_use(self, user_input: str) -> str:
+        """Makes a POST request to Superstaq API to confirm acceptance of terms of use.
+
+        Args:
+            user_input: user's response to prompt for acceptance of TOU. Server accepts YES
+
+        Returns:
+            String with success message.
+        """
+        return self.post_request("/accept_terms_of_use", {"user_input": user_input})
+
     def get_targets(self) -> Dict[str, Dict[str, List[str]]]:
-        """Makes a GET request to SuperstaQ API to get a list of available targets."""
+        """Makes a GET request to Superstaq API to get a list of available targets."""
         return self.get_request("/targets")
 
-    def ibmq_set_token(self, json_dict: Dict[str, str]) -> str:
-        """Makes a POST request to SuperstaQ API to set IBMQ token field in database.
+    def add_new_user(self, json_dict: Dict[str, str]) -> str:
+        """Makes a POST request to Superstaq API to add a new user.
 
         Args:
-            ibmq_token: dictionary with IBMQ token string entry.
+            json_dict: dictionary with user entry.
 
         Returns:
-            The json body of the response as a dict.
+            The response as a string.
         """
+        return self.post_request("/add_new_user", json_dict)
 
-        return self.post_request("/ibmq_token", json_dict)
+    def update_user_balance(self, json_dict: Dict[str, Union[float, str]]) -> str:
+        """Makes a POST request to Superstaq API to update a user's balance in the database.
+
+        Args:
+            json_dict: dictionary with user entry and new balance.
+
+        Returns:
+            The response as a string.
+        """
+        return self.post_request("/update_user_balance", json_dict)
+
+    def update_user_role(self, json_dict: Dict[str, Union[int, str]]) -> str:
+        """Makes a POST request to Superstaq API to update a user's role.
+
+        Args:
+            json_dict: dictionary with user entry and new role.
+
+        Returns:
+            The response as a string.
+        """
+        return self.post_request("/update_user_role", json_dict)
 
     def resource_estimate(self, json_dict: Dict[str, str]) -> Dict[str, List[Dict[str, int]]]:
+        """POSTs the given payload to the `/resource_estimate` endpoint
+        Args:
+            json_dict: The payload to POST
+        Returns: The response of the given payload
+        """
         return self.post_request("/resource_estimate", json_dict)
 
-    def aqt_compile(self, json_dict: Dict[str, Union[int, str, List[str]]]) -> Dict[str, str]:
-        """Makes a POST request to SuperstaQ API to compile a list of circuits for Berkeley-AQT."""
+    def aqt_compile(self, json_dict: Dict[str, str]) -> Dict[str, str]:
+        """Makes a POST request to Superstaq API to compile a list of circuits for Berkeley-AQT."""
         return self.post_request("/aqt_compile", json_dict)
 
-    def qscout_compile(
-        self, json_dict: Dict[str, Union[str, List[str]]]
-    ) -> Dict[str, Union[str, List[str]]]:
-        """Makes a POST request to SuperstaQ API to compile a list of circuits for QSCOUT."""
+    def qscout_compile(self, json_dict: Dict[str, str]) -> Dict[str, Union[str, List[str]]]:
+        """Makes a POST request to Superstaq API to compile a list of circuits for QSCOUT."""
         return self.post_request("/qscout_compile", json_dict)
 
-    def cq_compile(self, json_dict: Dict[str, Union[str, List[str]]]) -> Dict[str, str]:
-        """Makes a POST request to SuperstaQ API to compile a list of circuits for CQ."""
-        return self.post_request("/cq_compile", json_dict)
-
-    def ibmq_compile(self, json_dict: Dict[str, Union[str, List[str]]]) -> Dict[str, str]:
-        """Makes a POST request to SuperstaQ API to compile a circuits for IBM devices."""
-        return self.post_request("/ibmq_compile", json_dict)
-
-    def neutral_atom_compile(self, json_dict: Dict[str, Union[str, List[str]]]) -> Dict[str, str]:
-        """Makes a POST request to SuperstaQ API to compile a circuits for neutral atom devices."""
-        return self.post_request("/neutral_atom_compile", json_dict)
+    def compile(self, json_dict: Dict[str, str]) -> Dict[str, str]:
+        """Makes a POST request to Superstaq API to compile a list of circuits."""
+        return self.post_request("/compile", json_dict)
 
     def submit_qubo(
         self,
         qubo: qv.QUBO,
         target: str,
         repetitions: int = 1000,
         method: Optional[str] = None,
     ) -> Dict[str, str]:
-        """Makes a POST request to SuperstaQ API to submit a QUBO problem to the given target."""
+        """Makes a POST request to Superstaq API to submit a QUBO problem to the given target."""
+        gss.validation.validate_target(target)
+        gss.validation.validate_integer_param(repetitions)
+
         json_dict = {
             "qubo": gss.qubo.convert_qubo_to_model(qubo),
             "target": target,
-            "shots": repetitions,
+            "shots": int(repetitions),
             "method": method,
         }
         return self.post_request("/qubo", json_dict)
 
     def supercheq(
         self,
         files: List[List[int]],
         num_qubits: int,
         depth: int,
         circuit_return_type: str,
     ) -> Any:
+        """Performs a POST request on the `/supercheq` endpoint.
+
+        Args:
+            files: List of files specified as binary using ints.
+                For example: [[1, 0, 1], [1, 1, 1]].
+            num_qubits: Number of qubits to run Supercheq on.
+            depth: The depth of the circuits to run Supercheq on.
+            circuit_return_type: Supports only `cirq` and `qiskit` for now.
+
+        Returns:
+            The output of Supercheq.
+        """
+        gss.validation.validate_integer_param(num_qubits)
+        gss.validation.validate_integer_param(depth)
+
         json_dict = {
             "files": files,
-            "num_qubits": num_qubits,
-            "depth": depth,
+            "num_qubits": int(num_qubits),
+            "depth": int(depth),
             "circuit_return_type": circuit_return_type,
         }
         return self.post_request("/supercheq", json_dict)
 
-    def find_min_vol_portfolio(
-        self, json_dict: Dict[str, Union[List[str], int, float, str]]
-    ) -> MinVolJson:
-        """Makes a POST request to SuperstaQ API to find a minimum volatility portfolio
-        that exceeds a certain specified return."""
-        return self.post_request("/minvol", json_dict)
-
-    def find_max_pseudo_sharpe_ratio(
-        self, json_dict: Dict[str, Union[List[str], float, str, Optional[int]]]
-    ) -> MaxSharpeJson:
-        """Makes a POST request to SuperstaQ API to find a max Sharpe ratio portfolio."""
-        return self.post_request("/maxsharpe", json_dict)
-
-    def tsp(self, json_dict: Dict[str, List[str]]) -> TSPJson:
-        """Makes a POST request to SuperstaQ API to find a optimal TSP tour."""
-        return self.post_request("/tsp", json_dict)
-
-    def warehouse(self, json_dict: Dict[str, Union[int, List[str], str]]) -> WareHouseJson:
-        """Makes a POST request to SuperstaQ API to find optimal warehouse assignment."""
-        return self.post_request("/warehouse", json_dict)
+    def target_info(self, target: str) -> Dict[str, Any]:
+        """Makes a POST request to the Superstaq API (using the `/target_info` endpoint to request
+        information about `target`.
+
+        Args:
+            target: String representing the device to get information about.
+
+        Returns: Target information.
+        """
+        gss.validation.validate_target(target)
+
+        json_dict = {
+            "target": target,
+        }
+        return self.post_request("/target_info", json_dict)
+
+    def ibmq_set_token(self, json_dict: Dict[str, str]) -> str:
+        """Makes a POST request to Superstaq API to set IBMQ token field in database.
+
+        Args:
+            json_dict: Dictionary with IBMQ token string entry.
+
+        Returns:
+            The response as a string.
+        """
+        return self.post_request("/ibmq_token", json_dict)
+
+    def cq_set_token(self, json_dict: Dict[str, str]) -> str:
+        """Makes a POST request to Superstaq API to set CQ token field in database.
+
+        Args:
+            json_dict: Dictionary with CQ token string entry.
+
+        Returns:
+            The response as a string.
+        """
+        return self.post_request("/cq_token", json_dict)
 
     def aqt_upload_configs(self, aqt_configs: Dict[str, str]) -> str:
-        """Makes a POST request to SuperstaQ API to upload configurations."""
+        """Makes a POST request to Superstaq API to upload configurations."""
         return self.post_request("/aqt_configs", aqt_configs)
 
     def aqt_get_configs(self) -> Dict[str, str]:
         """Writes AQT configs from the AQT system onto the given file paths."""
         return self.get_request("/get_aqt_configs")
 
     def _handle_status_codes(self, response: requests.Response) -> None:
         if response.status_code == requests.codes.unauthorized:
-            raise gss.SuperstaQException(
-                '"Not authorized" returned by SuperstaQ API.  '
-                "Check to ensure you have supplied the correct API key.",
-                response.status_code,
-            )
+            if response.json() == (
+                "You must accept the Terms of Use (superstaq.super.tech/terms_of_use)."
+            ):
+                self._prompt_accept_terms_of_use()
+                return
+            else:
+                raise gss.SuperstaqException(
+                    '"Not authorized" returned by Superstaq API.  '
+                    "Check to ensure you have supplied the correct API key.",
+                    response.status_code,
+                )
 
         if response.status_code not in self.RETRIABLE_STATUS_CODES:
             if "message" in response.json():
                 message = response.json()["message"]
             else:
                 message = str(response.text)
-            raise gss.SuperstaQException(
-                f"Non-retriable error making request to SuperstaQ API, {message}",
+            slack_invite_url = (
+                "https://join.slack.com/t/superstaq/shared_invite/"
+                "zt-1wr6eok5j-fMwB7dPEWGG~5S474xGhxw"
+            )
+            raise gss.SuperstaqException(
+                f"Non-retriable error making request to Superstaq API, {message}.\n\n"
+                "If you would like to contact a member of our team, email us at "
+                f"superstaq@infleqtion.com or join our Slack workspace: {slack_invite_url}",
                 response.status_code,
             )
 
+    def _prompt_accept_terms_of_use(self) -> None:
+        message = (
+            "Acceptance of the Terms of Use (superstaq.super.tech/terms_of_use)"
+            " is necessary before using Superstaq.\nType in YES to accept: "
+        )
+        user_input = input(message).upper()
+        response = self._accept_terms_of_use(user_input)
+        print(response)
+        if response != "Accepted. You can now continue using Superstaq.":
+            raise gss.SuperstaqException(
+                "You'll need to accept Terms of Use before usage of Superstaq.",
+                requests.codes.unauthorized,
+            )
+
     def _make_request(self, request: Callable[[], requests.Response]) -> requests.Response:
         """Make a request to the API, retrying if necessary.
 
         Args:
             request: A function that returns a `requests.Response`.
 
         Raises:
-            SuperstaQException: If there was a not-retriable error from the API.
+            SuperstaqException: If there was a not-retriable error from the API.
             TimeoutError: If the requests retried for more than `max_retry_seconds`.
 
         Returns:
             The request.Response from the final successful request call.
         """
         # Initial backoff of 100ms.
         delay_seconds = 0.1
@@ -334,16 +455,44 @@
 
     def __str__(self) -> str:
         return f"Client with host={self.url} and name={self.client_name}"
 
     def __repr__(self) -> str:
         return textwrap.dedent(
             f"""\
-            gss.superstaq_client._SuperstaQClient(
+            gss.superstaq_client._SuperstaqClient(
                 remote_host={self.url!r},
                 api_key={self.api_key!r},
                 client_name={self.client_name!r},
                 api_version={self.api_version!r},
                 max_retry_seconds={self.max_retry_seconds!r},
                 verbose={self.verbose!r},
             )"""
         )
+
+
+def find_api_key() -> str:
+    """Try to load a Superstaq API key from the environment or a key file."""
+
+    # look for the key in the environment
+    env_api_key = os.getenv("SUPERSTAQ_API_KEY")
+    if env_api_key:
+        return env_api_key
+
+    data_dir = pathlib.Path(os.getenv("XDG_DATA_HOME", "~/.local/share")).expanduser()
+    home_dir = pathlib.Path.home()
+    for directory in [
+        data_dir.joinpath("super.tech"),
+        data_dir.joinpath("coldquanta"),
+        home_dir.joinpath(".super.tech"),
+        home_dir.joinpath(".coldquanta"),
+    ]:
+        path = directory.joinpath("superstaq_api_key")
+        if path.is_file():
+            with open(path, "r") as file:
+                return file.readline()
+
+    raise EnvironmentError(
+        "Superstaq API key not specified and not found.\n"
+        "Try passing an 'api_key' variable, or setting your API key in the command line "
+        "with SUPERSTAQ_API_KEY=..."
+    )
```

## general_superstaq/superstaq_client_test.py

```diff
@@ -6,17 +6,19 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
+# pylint: disable=missing-function-docstring
 import contextlib
 import io
 import json
+import os
 from unittest import mock
 
 import pytest
 import qubovert as qv
 import requests
 
 import general_superstaq as gss
@@ -27,106 +29,142 @@
     "Content-Type": "application/json",
     "X-Client-Version": API_VERSION,
     "X-Client-Name": "general-superstaq",
 }
 
 
 def test_superstaq_client_str_and_repr() -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
 
     assert (
         str(client)
         == f"Client with host=http://example.com/{API_VERSION} and name=general-superstaq"
     )
     assert str(eval(repr(client))) == str(client)
 
 
 def test_general_superstaq_exception_str() -> None:
-    ex = gss.SuperstaQException("err", status_code=501)
+    ex = gss.SuperstaqException("err", status_code=501)
     assert str(ex) == "Status code: 501, Message: 'err'"
 
 
 def test_general_superstaq_not_found_exception_str() -> None:
-    ex = gss.SuperstaQNotFoundException("err")
+    ex = gss.SuperstaqNotFoundException("err")
     assert str(ex) == "Status code: 404, Message: 'err'"
 
 
-def test_superstaq_client_invalid_remote_host() -> None:
-    for invalid_url in ("", "url", "http://", "ftp://", "http://"):
-        with pytest.raises(AssertionError, match="not a valid url"):
-            _ = gss.superstaq_client._SuperstaQClient(
-                client_name="general-superstaq", remote_host=invalid_url, api_key="a"
-            )
-        with pytest.raises(AssertionError, match=invalid_url):
-            _ = gss.superstaq_client._SuperstaQClient(
-                client_name="general-superstaq", remote_host=invalid_url, api_key="a"
-            )
+@pytest.mark.parametrize("invalid_url", ("url", "http://", "ftp://", "http://"))
+def test_superstaq_client_invalid_remote_host(invalid_url: str) -> None:
+    with pytest.raises(AssertionError, match="not a valid url"):
+        _ = gss.superstaq_client._SuperstaqClient(
+            client_name="general-superstaq", remote_host=invalid_url, api_key="a"
+        )
+    with pytest.raises(AssertionError, match=invalid_url):
+        _ = gss.superstaq_client._SuperstaqClient(
+            client_name="general-superstaq", remote_host=invalid_url, api_key="a"
+        )
 
 
 def test_superstaq_client_invalid_api_version() -> None:
     with pytest.raises(AssertionError, match="are accepted"):
-        _ = gss.superstaq_client._SuperstaQClient(
+        _ = gss.superstaq_client._SuperstaqClient(
             client_name="general-superstaq",
             remote_host="http://example.com",
             api_key="a",
             api_version="v0.0",
         )
     with pytest.raises(AssertionError, match="0.0"):
-        _ = gss.superstaq_client._SuperstaQClient(
+        _ = gss.superstaq_client._SuperstaqClient(
             client_name="general-superstaq",
             remote_host="http://example.com",
             api_key="a",
             api_version="v0.0",
         )
 
 
 def test_superstaq_client_time_travel() -> None:
     with pytest.raises(AssertionError, match="time machine"):
-        _ = gss.superstaq_client._SuperstaQClient(
+        _ = gss.superstaq_client._SuperstaqClient(
             client_name="general-superstaq",
             remote_host="http://example.com",
             api_key="a",
             max_retry_seconds=-1,
         )
 
 
 def test_superstaq_client_attributes() -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
         max_retry_seconds=10,
         verbose=True,
     )
     assert client.url == f"http://example.com/{API_VERSION}"
     assert client.headers == EXPECTED_HEADERS
     assert client.max_retry_seconds == 10
     assert client.verbose
 
 
+@mock.patch("general_superstaq.superstaq_client._SuperstaqClient._accept_terms_of_use")
+@mock.patch("requests.get")
+def test_superstaq_client_needs_accept_terms_of_use(
+    mock_get: mock.MagicMock,
+    mock_accept_terms_of_use: mock.MagicMock,
+    capsys: pytest.CaptureFixture[str],
+) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
+        client_name="general-superstaq",
+        remote_host="http://example.com",
+        api_key="to_my_heart",
+    )
+
+    fake_get_response = mock.MagicMock()
+    fake_get_response.ok = False
+    fake_get_response.status_code = requests.codes.unauthorized
+    fake_get_response.json.return_value = (
+        "You must accept the Terms of Use (superstaq.super.tech/terms_of_use)."
+    )
+    mock_get.return_value = fake_get_response
+
+    mock_accept_terms_of_use.return_value = "YES response required to proceed"
+
+    with mock.patch("builtins.input"):
+        with pytest.raises(gss.SuperstaqException, match="You'll need to accept Terms of Use"):
+            client.get_balance()
+        assert capsys.readouterr().out == "YES response required to proceed\n"
+
+    fake_authorized_get_response = mock.MagicMock(ok=True)
+    mock_get.side_effect = [fake_get_response, fake_authorized_get_response]
+    mock_accept_terms_of_use.return_value = "Accepted. You can now continue using Superstaq."
+    with mock.patch("builtins.input"):
+        client.get_balance()
+        assert capsys.readouterr().out == "Accepted. You can now continue using Superstaq.\n"
+
+
 @mock.patch("requests.post")
 def test_supertstaq_client_create_job(mock_post: mock.MagicMock) -> None:
-    mock_post.return_value.status_code.return_value = requests.codes.ok
+    mock_post.return_value.status_code = requests.codes.ok
     mock_post.return_value.json.return_value = {"foo": "bar"}
 
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
     response = client.create_job(
         serialized_circuits={"Hello": "World"},
         repetitions=200,
         target="ss_example_qpu",
         method="dry-run",
-        options={"qiskit_pulse": True},
+        qiskit_pulse=True,
     )
     assert response == {"foo": "bar"}
 
     expected_json = {
         "Hello": "World",
         "target": "ss_example_qpu",
         "shots": 200,
@@ -142,60 +180,60 @@
 
 
 @mock.patch("requests.post")
 def test_superstaq_client_create_job_unauthorized(mock_post: mock.MagicMock) -> None:
     mock_post.return_value.ok = False
     mock_post.return_value.status_code = requests.codes.unauthorized
 
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
-    with pytest.raises(gss.SuperstaQException, match="Not authorized"):
+    with pytest.raises(gss.SuperstaqException, match="Not authorized"):
         _ = client.create_job({"Hello": "World"}, target="ss_example_qpu")
 
 
 @mock.patch("requests.post")
 def test_superstaq_client_create_job_not_found(mock_post: mock.MagicMock) -> None:
     mock_post.return_value.ok = False
     mock_post.return_value.status_code = requests.codes.not_found
 
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
-    with pytest.raises(gss.SuperstaQException):
+    with pytest.raises(gss.SuperstaqException):
         _ = client.create_job({"Hello": "World"}, target="ss_example_qpu")
 
 
 @mock.patch("requests.post")
 def test_superstaq_client_create_job_not_retriable(mock_post: mock.MagicMock) -> None:
     mock_post.return_value.ok = False
     mock_post.return_value.status_code = requests.codes.not_implemented
 
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
-    with pytest.raises(gss.SuperstaQException, match="Status code: 501"):
+    with pytest.raises(gss.SuperstaqException, match="Status code: 501"):
         _ = client.create_job({"Hello": "World"}, target="ss_example_qpu")
 
 
 @mock.patch("requests.post")
 def test_superstaq_client_create_job_retry(mock_post: mock.MagicMock) -> None:
     response1 = mock.MagicMock()
     response2 = mock.MagicMock()
     mock_post.side_effect = [response1, response2]
     response1.ok = False
     response1.status_code = requests.codes.service_unavailable
     response2.ok = True
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
         verbose=True,
     )
     test_stdout = io.StringIO()
     with contextlib.redirect_stdout(test_stdout):
@@ -205,29 +243,29 @@
 
 
 @mock.patch("requests.post")
 def test_superstaq_client_create_job_retry_request_error(mock_post: mock.MagicMock) -> None:
     response2 = mock.MagicMock()
     mock_post.side_effect = [requests.exceptions.ConnectionError(), response2]
     response2.ok = True
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
     _ = client.create_job({"Hello": "World"}, target="ss_example_qpu")
     assert mock_post.call_count == 2
 
 
 @mock.patch("requests.post")
 def test_superstaq_client_create_job_timeout(mock_post: mock.MagicMock) -> None:
     mock_post.return_value.ok = False
     mock_post.return_value.status_code = requests.codes.service_unavailable
 
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
         max_retry_seconds=0.2,
     )
     with pytest.raises(TimeoutError):
         _ = client.create_job({"Hello": "World"}, target="ss_example_qpu")
@@ -235,32 +273,32 @@
 
 @mock.patch("requests.post")
 def test_superstaq_client_create_job_json(mock_post: mock.MagicMock) -> None:
     mock_post.return_value.ok = False
     mock_post.return_value.status_code = requests.codes.bad_request
     mock_post.return_value.json.return_value = {"message": "foo bar"}
 
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
-    with pytest.raises(gss.SuperstaQException, match="Status code: 400"):
+    with pytest.raises(gss.SuperstaqException, match="Status code: 400"):
         _ = client.create_job(
             serialized_circuits={"Hello": "World"},
             repetitions=200,
             target="ss_example_qpu",
         )
 
 
 @mock.patch("requests.get")
 def test_superstaq_client_get_job(mock_get: mock.MagicMock) -> None:
     mock_get.return_value.ok = True
     mock_get.return_value.json.return_value = {"foo": "bar"}
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
     response = client.get_job(job_id="job_id")
     assert response == {"foo": "bar"}
 
@@ -269,49 +307,102 @@
     )
 
 
 @mock.patch("requests.get")
 def test_superstaq_client_get_balance(mock_get: mock.MagicMock) -> None:
     mock_get.return_value.ok = True
     mock_get.return_value.json.return_value = {"balance": 123.4567}
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
     response = client.get_balance()
     assert response == {"balance": 123.4567}
 
     mock_get.assert_called_with(
         f"http://example.com/{API_VERSION}/balance", headers=EXPECTED_HEADERS, verify=False
     )
 
 
+@mock.patch("requests.get")
+def test_superstaq_client_get_version(mock_get: mock.MagicMock) -> None:
+    mock_get.return_value.ok = True
+    mock_get.return_value.headers = {"superstaq_version": "1.2.3"}
+    client = gss.superstaq_client._SuperstaqClient(
+        client_name="general-superstaq",
+        remote_host="http://example.com",
+        api_key="to_my_heart",
+    )
+    response = client.get_superstaq_version()
+    assert response == {"superstaq_version": "1.2.3"}
+
+    mock_get.assert_called_with(f"http://example.com/{API_VERSION}")
+
+
 @mock.patch("requests.post")
-def test_superstaq_client_ibmq_set_token(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+def test_add_new_user(mock_post: mock.MagicMock) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
 
-    client.ibmq_set_token({"ibmq_token": "token"})
+    client.add_new_user({"Marie Curie": "mc@gmail.com"})
 
-    expected_json = {"ibmq_token": "token"}
+    expected_json = {"Marie Curie": "mc@gmail.com"}
     mock_post.assert_called_with(
-        f"http://example.com/{API_VERSION}/ibmq_token",
+        f"http://example.com/{API_VERSION}/add_new_user",
+        headers=EXPECTED_HEADERS,
+        json=expected_json,
+        verify=False,
+    )
+
+
+@mock.patch("requests.post")
+def test_update_user_balance(mock_post: mock.MagicMock) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
+        client_name="general-superstaq",
+        remote_host="http://example.com",
+        api_key="to_my_heart",
+    )
+
+    client.update_user_balance({"email": "mc@gmail.com", "balance": 5.00})
+
+    expected_json = {"email": "mc@gmail.com", "balance": 5.00}
+    mock_post.assert_called_with(
+        f"http://example.com/{API_VERSION}/update_user_balance",
+        headers=EXPECTED_HEADERS,
+        json=expected_json,
+        verify=False,
+    )
+
+
+@mock.patch("requests.post")
+def test_update_user_role(mock_post: mock.MagicMock) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
+        client_name="general-superstaq",
+        remote_host="http://example.com",
+        api_key="to_my_heart",
+    )
+
+    client.update_user_role({"email": "mc@gmail.com", "role": 5})
+
+    expected_json = {"email": "mc@gmail.com", "role": 5}
+    mock_post.assert_called_with(
+        f"http://example.com/{API_VERSION}/update_user_role",
         headers=EXPECTED_HEADERS,
         json=expected_json,
         verify=False,
     )
 
 
 @mock.patch("requests.post")
 def test_superstaq_client_resource_estimate(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
 
     client.resource_estimate({"Hello": "1", "World": "2"})
 
@@ -346,15 +437,15 @@
                 "d-wave_advantage-system1.1_qpu",
                 "ionq_ion_qpu",
             ],
             "compile-only": ["aqt_keysight_qpu", "sandia_qscout_qpu"],
         }
     }
     mock_get.return_value.json.return_value = targets
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
     response = client.get_targets()
     assert response == targets
 
@@ -364,140 +455,112 @@
 
 
 @mock.patch("requests.get")
 def test_superstaq_client_get_job_unauthorized(mock_get: mock.MagicMock) -> None:
     mock_get.return_value.ok = False
     mock_get.return_value.status_code = requests.codes.unauthorized
 
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
-    with pytest.raises(gss.SuperstaQException, match="Not authorized"):
+    with pytest.raises(gss.SuperstaqException, match="Not authorized"):
         _ = client.get_job("job_id")
 
 
 @mock.patch("requests.get")
 def test_superstaq_client_get_job_not_found(mock_get: mock.MagicMock) -> None:
     (mock_get.return_value).ok = False
     (mock_get.return_value).status_code = requests.codes.not_found
 
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
-    with pytest.raises(gss.SuperstaQException):
+    with pytest.raises(gss.SuperstaqException):
         _ = client.get_job("job_id")
 
 
 @mock.patch("requests.get")
 def test_superstaq_client_get_job_not_retriable(mock_get: mock.MagicMock) -> None:
     mock_get.return_value.ok = False
     mock_get.return_value.status_code = requests.codes.bad_request
 
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
-    with pytest.raises(gss.SuperstaQException, match="Status code: 400"):
+    with pytest.raises(gss.SuperstaqException, match="Status code: 400"):
         _ = client.get_job("job_id")
 
 
 @mock.patch("requests.get")
 def test_superstaq_client_get_job_retry(mock_get: mock.MagicMock) -> None:
     response1 = mock.MagicMock()
     response2 = mock.MagicMock()
     mock_get.side_effect = [response1, response2]
     response1.ok = False
     response1.status_code = requests.codes.service_unavailable
     response2.ok = True
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
     _ = client.get_job("job_id")
     assert mock_get.call_count == 2
 
 
 @mock.patch("requests.post")
 def test_superstaq_client_aqt_compile(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
     client.aqt_compile({"Hello": "1", "World": "2"})
 
     mock_post.assert_called_once()
     assert mock_post.call_args[0][0] == f"http://example.com/{API_VERSION}/aqt_compile"
 
 
 @mock.patch("requests.post")
 def test_superstaq_client_qscout_compile(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
     client.qscout_compile({"Hello": "1", "World": "2"})
 
     mock_post.assert_called_once()
     assert mock_post.call_args[0][0] == f"http://example.com/{API_VERSION}/qscout_compile"
 
 
 @mock.patch("requests.post")
-def test_superstaq_client_cq_compile(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
-        client_name="general-superstaq",
-        remote_host="http://example.com",
-        api_key="to_my_heart",
-    )
-    client.cq_compile({"Hello": "1", "World": "2"})
-
-    mock_post.assert_called_once()
-    assert mock_post.call_args[0][0] == f"http://example.com/{API_VERSION}/cq_compile"
-
-
-@mock.patch("requests.post")
-def test_superstaq_client_ibmq_compile(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
-        client_name="general-superstaq",
-        remote_host="http://example.com",
-        api_key="to_my_heart",
-    )
-    client.ibmq_compile(
-        {"Hello": "1", "World": "2"},
-    )
-
-    mock_post.assert_called_once()
-    assert mock_post.call_args[0][0] == f"http://example.com/{API_VERSION}/ibmq_compile"
-
-
-@mock.patch("requests.post")
-def test_superstaq_client_neutral_atom_compile(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+def test_superstaq_client_compile(mock_post: mock.MagicMock) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
-    client.neutral_atom_compile(
+    client.compile(
         {"Hello": "1", "World": "2"},
     )
 
     mock_post.assert_called_once()
-    assert mock_post.call_args[0][0] == f"http://example.com/{API_VERSION}/neutral_atom_compile"
+    assert mock_post.call_args[0][0] == f"http://example.com/{API_VERSION}/compile"
 
 
 @mock.patch("requests.post")
 def test_superstaq_client_submit_qubo(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
 
     example_qubo = qv.QUBO({(0,): 1.0, (1,): 1.0, (0, 1): -2.0})
     target = "ss_example_qpu"
@@ -521,15 +584,15 @@
         json=expected_json,
         verify=False,
     )
 
 
 @mock.patch("requests.post")
 def test_superstaq_client_supercheq(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
     client.supercheq([[0]], 1, 1, "cirq_circuits")
 
     expected_json = {
@@ -543,121 +606,112 @@
         headers=EXPECTED_HEADERS,
         json=expected_json,
         verify=False,
     )
 
 
 @mock.patch("requests.post")
-def test_superstaq_client_find_min_vol_portfolio(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+def test_superstaq_client_ibmq_set_token(mock_post: mock.MagicMock) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
-    client.find_min_vol_portfolio(
-        {"stock_symbols": ["AAPL", "GOOG", "IEF", "MMM"], "desired_return": 8}
-    )
 
-    expected_json = {"stock_symbols": ["AAPL", "GOOG", "IEF", "MMM"], "desired_return": 8}
+    client.ibmq_set_token({"ibmq_token": "token"})
+
+    expected_json = {"ibmq_token": "token"}
     mock_post.assert_called_with(
-        f"http://example.com/{API_VERSION}/minvol",
+        f"http://example.com/{API_VERSION}/ibmq_token",
         headers=EXPECTED_HEADERS,
         json=expected_json,
         verify=False,
     )
 
 
 @mock.patch("requests.post")
-def test_superstaq_client_find_max_pseudo_sharpe_ratio(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+def test_superstaq_client_cq_set_token(mock_post: mock.MagicMock) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
-    client.find_max_pseudo_sharpe_ratio({"stock_symbols": ["AAPL", "GOOG", "IEF", "MMM"], "k": 0.5})
 
-    expected_json = {"stock_symbols": ["AAPL", "GOOG", "IEF", "MMM"], "k": 0.5}
+    client.cq_set_token({"cq_token": "token"})
+
+    expected_json = {"cq_token": "token"}
     mock_post.assert_called_with(
-        f"http://example.com/{API_VERSION}/maxsharpe",
+        f"http://example.com/{API_VERSION}/cq_token",
         headers=EXPECTED_HEADERS,
         json=expected_json,
         verify=False,
     )
 
 
 @mock.patch("requests.post")
-def test_superstaq_client_tsp(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+def test_superstaq_client_aqt_upload_configs(mock_post: mock.MagicMock) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
-    client.tsp({"locs": ["Chicago", "St Louis", "St Paul"]})
 
-    expected_json = {"locs": ["Chicago", "St Louis", "St Paul"]}
+    client.aqt_upload_configs({"pulses": "Hello", "variables": "World"})
+
+    expected_json = {"pulses": "Hello", "variables": "World"}
     mock_post.assert_called_with(
-        f"http://example.com/{API_VERSION}/tsp",
+        f"http://example.com/{API_VERSION}/aqt_configs",
         headers=EXPECTED_HEADERS,
         json=expected_json,
         verify=False,
     )
 
 
-@mock.patch("requests.post")
-def test_superstaq_client_warehouse(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+@mock.patch("requests.get")
+def test_superstaq_client_aqt_get_configs(mock_get: mock.MagicMock) -> None:
+    expected_json = {"pulses": "Hello", "variables": "World"}
+
+    mock_get.return_value.json.return_value = expected_json
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
-    client.warehouse(
-        {
-            "k": 1,
-            "possible_warehouses": ["Chicago", "San Francisco"],
-            "customers": ["Rockford", "Aurora"],
-        }
-    )
 
-    expected_json = {
-        "k": 1,
-        "possible_warehouses": ["Chicago", "San Francisco"],
-        "customers": ["Rockford", "Aurora"],
-    }
-    mock_post.assert_called_with(
-        f"http://example.com/{API_VERSION}/warehouse",
-        headers=EXPECTED_HEADERS,
-        json=expected_json,
-        verify=False,
-    )
+    assert client.aqt_get_configs() == expected_json
 
 
 @mock.patch("requests.post")
-def test_superstaq_client_aqt_upload_configs(mock_post: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+def test_superstaq_client_target_info(mock_post: mock.MagicMock) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="general-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
+    client.target_info("ss_example_qpu")
 
-    client.aqt_upload_configs({"pulses": "Hello", "variables": "World"})
+    expected_json = {"target": "ss_example_qpu"}
 
-    expected_json = {"pulses": "Hello", "variables": "World"}
     mock_post.assert_called_with(
-        f"http://example.com/{API_VERSION}/aqt_configs",
+        f"http://example.com/{API_VERSION}/target_info",
         headers=EXPECTED_HEADERS,
         json=expected_json,
         verify=False,
     )
 
 
-@mock.patch("requests.get")
-def test_superstaq_client_aqt_get_configs(mock_get: mock.MagicMock) -> None:
-    expected_json = {"pulses": "Hello", "variables": "World"}
-
-    mock_get.return_value.json.return_value = expected_json
-    client = gss.superstaq_client._SuperstaQClient(
-        client_name="general-superstaq",
-        remote_host="http://example.com",
-        api_key="to_my_heart",
-    )
-
-    assert client.aqt_get_configs() == expected_json
+def test_find_api_key() -> None:
+    # find key in the environment
+    with mock.patch.dict(os.environ, {"SUPERSTAQ_API_KEY": "tomyheart"}):
+        assert gss.superstaq_client.find_api_key() == "tomyheart"
+
+    # find key in a config file
+    with mock.patch.dict(os.environ, SUPERSTAQ_API_KEY=""):
+        with mock.patch("pathlib.Path.is_file", return_value=True):
+            with mock.patch("builtins.open", mock.mock_open(read_data="tomyheart")):
+                assert gss.superstaq_client.find_api_key() == "tomyheart"
+
+    # fail to find an API key :(
+    with pytest.raises(EnvironmentError, match="Superstaq API key not specified and not found."):
+        with mock.patch.dict(os.environ, SUPERSTAQ_API_KEY=""):
+            with mock.patch("pathlib.Path.is_file", return_value=False):
+                gss.superstaq_client.find_api_key()
```

## general_superstaq/superstaq_exceptions.py

```diff
@@ -1,45 +1,45 @@
-"""Exceptions for the SuperstaQ API."""
+"""Exceptions for the Superstaq API."""
 
 from typing import Optional
 
 import requests
 
 
-class SuperstaQException(Exception):
-    """An exception for errors coming from SuperstaQ's API.
+class SuperstaqException(Exception):
+    """An exception for errors coming from Superstaq's API.
 
     Attributes:
-        status_code: A http status code, if coming from an http response with a failing status.
+        status_code: An HTTP status code, if coming from an HTTP response with a failing status.
+        message: A message corresponding to the HTTP response status code.
     """
 
     def __init__(self, message: str, status_code: Optional[int] = None):
         super().__init__(f"Status code: {status_code}, Message: '{message}'")
         self.status_code = status_code
         self.message = message
 
 
-class SuperstaQModuleNotFoundException(SuperstaQException):
-    """
-    An exception for SuperstaQ features requiring an uninstalled module."""
+class SuperstaqModuleNotFoundException(SuperstaqException):
+    """An exception for Superstaq features requiring an uninstalled module."""
 
     def __init__(self, name: str, context: str):
         message = f"'{context}' requires module '{name}'"
         super().__init__(message)
 
 
-class SuperstaQNotFoundException(SuperstaQException):
-    """An exception for errors from SuperstaQ's API when a resource is not found."""
+class SuperstaqNotFoundException(SuperstaqException):
+    """An exception for errors from Superstaq's API when a resource is not found."""
 
     def __init__(self, message: str):
         super().__init__(message, status_code=requests.codes.not_found)
 
 
-class SuperstaQUnsuccessfulJobException(SuperstaQException):
+class SuperstaqUnsuccessfulJobException(SuperstaqException):
     """An exception for attempting to get info about an unsuccessful job.
 
-    This exception occurs when a job has been canceled, deleted, or failed, and information about
+    This exception occurs when a job has been cancelled, deleted, or failed, and information about
     this job is attempted to be accessed.
     """
 
-    def __init__(self, job_id: str, status: str):
-        super().__init__(f"Job {job_id} was {status}.")
+    def __init__(self, job_id: str, status: str) -> None:
+        super().__init__(f"Job {job_id} terminated with status {status}.")
```

## general_superstaq/superstaq_exceptions_test.py

```diff
@@ -6,36 +6,37 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
+# pylint: disable=missing-function-docstring
 
 import general_superstaq as gss
 
 
 def test_superstaq_exception() -> None:
-    ex = gss.SuperstaQException(message="Hello", status_code=500)
+    ex = gss.SuperstaqException(message="Hello", status_code=500)
     assert str(ex) == "Status code: 500, Message: 'Hello'"
     assert ex.status_code == 500
     assert ex.message == "Hello"
 
 
 def test_module_not_found_exception() -> None:
-    ex = gss.SuperstaQModuleNotFoundException("hello_world", "test")
+    ex = gss.SuperstaqModuleNotFoundException("hello_world", "test")
     assert str(ex) == "Status code: None, Message: ''test' requires module 'hello_world''"
     assert ex.message == "'test' requires module 'hello_world'"
 
 
 def test_superstaq_not_found_exception() -> None:
-    ex = gss.SuperstaQNotFoundException(message="Where are you")
+    ex = gss.SuperstaqNotFoundException(message="Where are you")
     assert str(ex) == "Status code: 404, Message: 'Where are you'"
     assert ex.status_code == 404
     assert ex.message == "Where are you"
 
 
 def test_superstaq_unsuccessful_job_exception() -> None:
-    ex = gss.SuperstaQUnsuccessfulJobException(job_id="SWE", status="canceled")
-    assert str(ex) == "Status code: None, Message: 'Job SWE was canceled.'"
+    ex = gss.SuperstaqUnsuccessfulJobException(job_id="SWE", status="Cancelled")
+    assert str(ex) == "Status code: None, Message: 'Job SWE terminated with status Cancelled.'"
     assert ex.status_code is None
-    assert ex.message == "Job SWE was canceled."
+    assert ex.message == "Job SWE terminated with status Cancelled."
```

## general_superstaq/typing.py

```diff
@@ -1,10 +1,8 @@
-from typing import Any, Dict, List, Optional, Tuple
-
-from typing_extensions import TypedDict  # compatible with both python 3.7 and 3.8
+from typing import Any, Dict, List, Optional, Tuple, TypedDict
 
 QuboDict = TypedDict(
     "QuboDict",
     {
         "keys": List[str],
         "value": float,
     },
```

## general_superstaq/user_config.py

```diff
@@ -1,51 +1,129 @@
 import os
 from typing import Any, Dict, Optional, Tuple, Union
 
-from general_superstaq import superstaq_client
+import general_superstaq as gss
 
 
 class UserConfig:
-    def __init__(self, client: superstaq_client._SuperstaQClient):
+    """This class contains all the user configurations that are used to operate Superstaq."""
+
+    def __init__(self, client: gss.superstaq_client._SuperstaqClient):
         self._client = client
 
     def get_balance(self, pretty_output: bool = True) -> Union[str, float]:
         """Get the querying user's account balance in USD.
         Args:
-            pretty_output: whether to return a pretty string or a float of the balance.
+            pretty_output: Whether to return a pretty string or a float of the balance.
+
         Returns:
             If pretty_output is True, returns the balance as a nicely formatted string ($-prefix,
-                commas on LHS every three digits, and two digits after period). Otherwise, simply
-                returns a float of the balance.
+            commas on LHS every three digits, and two digits after period). Otherwise, simply
+            returns a float of the balance.
         """
         balance = self._client.get_balance()["balance"]
         if pretty_output:
             return f"${balance:,.2f}"
         return balance
 
+    def _accept_terms_of_use(self, user_input: str) -> str:
+        """Send acceptance of terms of use at https://superstaq.super.tech/terms_of_use.
+
+        Args:
+            user_input: If "YES", server will mark user as having accepted terms of use.
+
+        Returns:
+            String message indicated if user has been marked as having accepted terms of use.
+        """
+        return self._client._accept_terms_of_use(user_input)
+
+    def add_new_user(self, name: str, email: str) -> str:
+        """Adds new user.
+
+        Args:
+            name: The name to add.
+            email: The new user's email.
+
+        Returns:
+            String containing status of update (whether or not it failed) and the new user's token.
+        """
+        return self._client.add_new_user(
+            {
+                "name": name,
+                "email": email,
+            }
+        )
+
+    def update_user_balance(self, email: str, balance: float) -> str:
+        """Updates user's balance.
+
+        Args:
+            email: The new user's email.
+            balance: The new balance.
+
+        Returns:
+             String containing status of update (whether or not it failed).
+        """
+        return self._client.update_user_balance(
+            {
+                "email": email,
+                "balance": balance,
+            }
+        )
+
+    def update_user_role(self, email: str, role: int) -> str:
+        """Updates user's role.
+
+        Args:
+            email: The new user's email
+            role: The new role
+
+        Returns:
+             String containing status of update (whether or not it failed).
+        """
+        return self._client.update_user_role(
+            {
+                "email": email,
+                "role": role,
+            }
+        )
+
     def ibmq_set_token(self, token: str) -> str:
-        """Sets IBMQ token field in database.
+        """Sets IBMQ token field.
 
         Args:
             token: IBMQ token string.
 
         Returns:
-            JSON dictionary containing status of update (whether or not it failed).
+            String containing status of update (whether or not it failed).
         """
         return self._client.ibmq_set_token({"ibmq_token": token})
 
+    def cq_set_token(self, token: str) -> str:
+        """Sets CQ token field.
+
+        Args:
+            token: CQ token string.
+
+        Returns:
+            String containing status of update (whether or not it failed).
+        """
+        return self._client.cq_set_token({"cq_token": token})
+
     def aqt_upload_configs(self, pulses: Any, variables: Any) -> str:
-        """Uploads configs for AQT. Arguments can be either file paths (in .yaml format) or qtrl
-        Manager instances.
+        """Uploads configs for AQT.
+
+        Arguments can be either file paths (in .yaml format) or qtrl Manager instances.
 
         Args:
-            pulses: PulseManager or file path for Pulses calibration data
-            variables: VariableManager or file path for Variables calibration data
+            pulses: PulseManager or file path for pulse configuration.
+            variables: VariableManager or file path for variable configuration.
+
         Returns:
-            A status of the update (whether or not it failed)
+            A status of the update (whether or not it failed).
         """
 
         def _config_to_yaml_str(config: Any) -> str:
             if isinstance(config, str):
                 if not os.path.isfile(config):
                     raise ValueError(f"{config!r} is not a valid file path.")
 
@@ -73,37 +151,45 @@
 
         pulses_yaml = _config_to_yaml_str(pulses)
         variables_yaml = _config_to_yaml_str(variables)
 
         return self._client.aqt_upload_configs({"pulses": pulses_yaml, "variables": variables_yaml})
 
     def aqt_get_configs(self) -> Dict[str, str]:
+        """Retrieves the raw AQT config files that had previously been uploaded to Superstaq.
+
+        Returns:
+            A dictionary containing all of the user's configs (as YAML strings), indexed by the
+            config names (e.g. "pulses", "variables").
+        """
         return self._client.aqt_get_configs()
 
     def aqt_download_configs(
         self,
         pulses_file_path: Optional[str] = None,
         variables_file_path: Optional[str] = None,
         overwrite: bool = False,
     ) -> Optional[Tuple[Dict[str, Any], Dict[str, Any]]]:
-        """Downloads AQT configs that had previously been uploaded to SuperstaQ, optionally saving
-        them to disk. Reading AQT configurations requires the PyYAML package.
+        """Downloads AQT configs that had previously been uploaded to Superstaq.
+
+        Optionally saves configs to disk as YAML configuration files. Otherwise, the PyYAML package
+        is required to read the downloaded configs.
 
         Args:
-            pulses_file_path (optional): Where to write the pulse configurations
-            variables_file_path (optional): Where to write the variables configurations
-            overwrite: Whether or not to overwrite existing files
+            pulses_file_path (optional): Where to write the pulse configuration.
+            variables_file_path (optional): Where to write the variable configuration.
+            overwrite: Whether or not to overwrite existing files.
+
         Returns (if file paths are not provided):
-            pulses: A dictionary containing Pulse configuration data
-            variables: A dictionary containing Variables configuration data
-        Returns (if file paths are provided):
-            None
+            A tuple of pulses (a dictionary containing pulse configuration data) and variables (a
+            dictionary containing calibration variables).
+
         Raises:
-            ValueError: If either file path already exists and overwrite is not True
-            ModuleNotFoundError: If file paths are unspecified and PyYAML cannot be imported
+            ValueError: If either file path already exists and overwrite is not True.
+            ModuleNotFoundError: If file paths are unspecified and PyYAML cannot be imported.
         """
 
         if pulses_file_path and variables_file_path:
             pulses_file_exists = os.path.exists(pulses_file_path)
             variables_file_exists = os.path.exists(variables_file_path)
 
             if not overwrite and pulses_file_exists and variables_file_exists:
@@ -121,19 +207,19 @@
                     f"{variables_file_path} exists Please try a different filename to write to, "
                     "or pass overwrite=True to overwrite the existing file."
                 )
 
             config_dict = self.aqt_get_configs()
             with open(pulses_file_path, "w") as text_file:
                 text_file.write(config_dict["pulses"])
-                print(f"Pulses configuration save to {pulses_file_path}.")
+                print(f"Pulses configuration saved to {pulses_file_path}.")
 
             with open(variables_file_path, "w") as text_file:
                 text_file.write(config_dict["variables"])
-                print(f"Variables configuration save to {variables_file_path}.")
+                print(f"Variables configuration saved to {variables_file_path}.")
 
             return None
 
         elif pulses_file_path or variables_file_path:
             raise ValueError("Please provide both pulses and variables file paths, or neither.")
 
         else:
```

## general_superstaq/user_config_test.py

```diff
@@ -4,47 +4,122 @@
 from unittest import mock
 
 import pytest
 
 import general_superstaq as gss
 
 
-def test_service_get_balance() -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+def test_service_get_balance() -> None:  # pylint: disable=missing-function-docstring
+    client = gss.superstaq_client._SuperstaqClient(
         remote_host="http://example.com", api_key="key", client_name="general_superstaq"
     )
     service = gss.user_config.UserConfig(client)
     mock_client = mock.MagicMock()
     mock_client.get_balance.return_value = {"balance": 12345.6789}
     service._client = mock_client
 
     assert service.get_balance() == "$12,345.68"
     assert service.get_balance(pretty_output=False) == 12345.6789
 
 
+def test_accept_terms_of_use() -> None:  # pylint: disable=missing-function-docstring
+    client = gss.superstaq_client._SuperstaqClient(
+        remote_host="http://example.com", api_key="key", client_name="general_superstaq"
+    )
+    service = gss.user_config.UserConfig(client)
+    with mock.patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.post_request"
+    ) as mock_post_request:
+        service._accept_terms_of_use("response")
+        mock_post_request.assert_called_once_with(
+            "/accept_terms_of_use", {"user_input": "response"}
+        )
+
+
+@mock.patch(
+    "general_superstaq.superstaq_client._SuperstaqClient.post_request",
+    return_value="The user has been added",
+)
+def test_add_new_user(  # pylint: disable=missing-function-docstring
+    mock_post_request: mock.MagicMock,
+) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
+        remote_host="http://example.com", api_key="key", client_name="general_superstaq"
+    )
+    service = gss.user_config.UserConfig(client)
+    assert service.add_new_user("Marie Curie", "mc@gmail.com") == "The user has been added"
+
+
+@mock.patch(
+    "general_superstaq.superstaq_client._SuperstaqClient.post_request",
+    return_value="The account's balance has been updated",
+)
+def test_update_user_balance(  # pylint: disable=missing-function-docstring
+    mock_post_request: mock.MagicMock,
+) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
+        remote_host="http://example.com", api_key="key", client_name="general_superstaq"
+    )
+    service = gss.user_config.UserConfig(client)
+    assert (
+        service.update_user_balance("mc@gmail.com", 5.00)
+        == "The account's balance has been updated"
+    )
+
+
+@mock.patch(
+    "general_superstaq.superstaq_client._SuperstaqClient.post_request",
+    return_value="The account's role has been updated",
+)
+def test_update_user_role(  # pylint: disable=missing-function-docstring
+    mock_post_request: mock.MagicMock,
+) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
+        remote_host="http://example.com", api_key="key", client_name="general_superstaq"
+    )
+    service = gss.user_config.UserConfig(client)
+    assert service.update_user_role("mc@gmail.com", 5) == "The account's role has been updated"
+
+
+@mock.patch(
+    "general_superstaq.superstaq_client._SuperstaqClient.post_request",
+    return_value="Your IBMQ account token has been updated",
+)
+def test_ibmq_set_token(  # pylint: disable=missing-function-docstring
+    mock_post_request: mock.MagicMock,
+) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
+        remote_host="http://example.com", api_key="key", client_name="general_superstaq"
+    )
+    service = gss.user_config.UserConfig(client)
+    assert service.ibmq_set_token("valid token") == "Your IBMQ account token has been updated"
+
+
 @mock.patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.ibmq_set_token",
-    return_value={"status": "Your IBMQ account token has been updated"},
+    "general_superstaq.superstaq_client._SuperstaqClient.post_request",
+    return_value="Your CQ account token has been updated",
 )
-def test_ibmq_set_token(mock_ibmq: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+def test_cq_set_token(  # pylint: disable=missing-function-docstring
+    mock_post_request: mock.MagicMock,
+) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
         remote_host="http://example.com", api_key="key", client_name="general_superstaq"
     )
     service = gss.user_config.UserConfig(client)
-    assert service.ibmq_set_token("valid token") == {
-        "status": "Your IBMQ account token has been updated"
-    }
+    assert service.cq_set_token("valid token") == "Your CQ account token has been updated"
 
 
 @mock.patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.aqt_upload_configs",
+    "general_superstaq.superstaq_client._SuperstaqClient.aqt_upload_configs",
     return_value="Your AQT configuration has been updated",
 )
-def test_service_aqt_upload_configs(mock_aqt_compile: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+def test_service_aqt_upload_configs(  # pylint: disable=missing-function-docstring
+    mock_aqt_compile: mock.MagicMock,
+) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
         remote_host="http://example.com", api_key="key", client_name="general_superstaq"
     )
     service = gss.user_config.UserConfig(client)
     tempdir = tempfile.gettempdir()
     pulses_file = os.path.join(tempdir, f"pulses-{secrets.token_hex(nbytes=16)}.yaml")
     variables_file = os.path.join(tempdir, f"variables-{secrets.token_hex(nbytes=16)}.yaml")
 
@@ -81,19 +156,21 @@
 
     with mock.patch.dict("sys.modules", {"yaml": None}):
         with pytest.raises(ModuleNotFoundError, match="PyYAML"):
             _ = service.aqt_upload_configs({}, {})
 
 
 @mock.patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.aqt_get_configs",
+    "general_superstaq.superstaq_client._SuperstaqClient.aqt_get_configs",
     return_value={"pulses": "Hello", "variables": "World"},
 )
-def test_service_aqt_get_configs(mock_aqt_compile: mock.MagicMock) -> None:
-    client = gss.superstaq_client._SuperstaQClient(
+def test_service_aqt_get_configs(  # pylint: disable=missing-function-docstring
+    mock_aqt_compile: mock.MagicMock,
+) -> None:
+    client = gss.superstaq_client._SuperstaqClient(
         remote_host="http://example.com", api_key="key", client_name="general_superstaq"
     )
     service = gss.user_config.UserConfig(client)
     tempdir = tempfile.gettempdir()
     pulses_file = secrets.token_hex(nbytes=16)
     variables_file = secrets.token_hex(nbytes=16)
```

## general_superstaq/check/all_.py

```diff
@@ -13,15 +13,17 @@
     format_,
     mypy_,
     pylint_,
     requirements,
 )
 
 
-def run(*args: str, sphinx_paths: Optional[List[str]] = None) -> int:
+def run(  # pylint: disable=missing-function-docstring
+    *args: str, sphinx_paths: Optional[List[str]] = None
+) -> int:
 
     parser = check_utils.get_file_parser()
     parser.description = textwrap.dedent(
         """
         Runs all checks on the repository.
         Exits immediately upon any failure unless passed one of -f, -F, or --force as an argument.
         This script exits with a succeeding exit code if and only if all checks pass.
@@ -38,37 +40,37 @@
         "-F",
         "--force",
         action="store_true",
         dest="force_all",
         help="'Hard force' ~ continue past (i.e. do not exit after) all failing checks.",
     )
 
-    parsed_args = parser.parse_intermixed_args(args)
-    args_to_pass = parsed_args.files
+    parsed_args, _ = parser.parse_known_intermixed_args(args)
     if parsed_args.revisions is not None:
-        args_to_pass += ["-i", *parsed_args.revisions]
+        # print info about incremental files once now, rather than in each check
+        _ = check_utils.extract_files(parsed_args, silent=False)
 
     default_mode = not parsed_args.files and parsed_args.revisions is None
     checks_failed = 0
 
+    args_to_pass = [arg for arg in args if arg not in ("-f", "-F", "--force")]
+
     # run formatting checks
-    # silence most checks to avoid printing duplicate info about incrmental files
+    # silence most checks to avoid printing duplicate info about incremental files
     # silencing does not affect warnings and errors
     exit_on_failure = not (parsed_args.force_formats or parsed_args.force_all)
     checks_failed |= configs.run(exit_on_failure=exit_on_failure, silent=True)
-    checks_failed |= format_.run(*args_to_pass, exit_on_failure=exit_on_failure, silent=False)
+    checks_failed |= format_.run(*args_to_pass, exit_on_failure=exit_on_failure, silent=True)
     checks_failed |= flake8_.run(*args_to_pass, exit_on_failure=exit_on_failure, silent=True)
     checks_failed |= pylint_.run(*args_to_pass, exit_on_failure=exit_on_failure, silent=True)
 
     # run typing and coverage checks
     exit_on_failure = not parsed_args.force_all
     checks_failed |= mypy_.run(*args_to_pass, exit_on_failure=exit_on_failure, silent=True)
-    checks_failed |= coverage_.run(
-        *args_to_pass, exit_on_failure=exit_on_failure, silent=default_mode
-    )
+    checks_failed |= coverage_.run(*args_to_pass, exit_on_failure=exit_on_failure, silent=True)
 
     # check that all pip requirements files are in order
     checks_failed |= requirements.run(exit_on_failure=exit_on_failure)
 
     if default_mode:
         # checks that the docs build
         checks_failed |= build_docs.run(exit_on_failure=exit_on_failure, sphinx_paths=sphinx_paths)
```

## general_superstaq/check/build_docs.py

```diff
@@ -7,15 +7,17 @@
 import textwrap
 from typing import List, Optional
 
 from general_superstaq.check import check_utils
 
 
 @check_utils.enable_exit_on_failure
-def run(*args: str, sphinx_paths: Optional[List[str]] = None) -> int:
+def run(  # pylint: disable=missing-function-docstring
+    *args: str, sphinx_paths: Optional[List[str]] = None
+) -> int:
 
     parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)
     parser.description = textwrap.dedent(
         """
         Checks that the docs build successfully.
         """
     )
```

## general_superstaq/check/check_utils.py

```diff
@@ -1,125 +1,122 @@
 #!/usr/bin/env python3
 
-"""
-Dumping ground for check script utilities.
+"""Dumping ground for check script utilities.
 """
 
 import argparse
 import enum
 import fnmatch
 import os
 import re
 import subprocess
 import sys
-from typing import Any, Callable, Iterable, List, Optional, Union
+from typing import Any, Callable, Iterable, List, Union
 
 # identify the root directory of the "main" script that called this module
-main_file_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
-root_dir = subprocess.check_output(
-    ["git", "rev-parse", "--show-toplevel"], cwd=main_file_dir, text=True
-).strip()
+try:
+    main_file_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
+    root_dir = subprocess.check_output(
+        ["git", "rev-parse", "--show-toplevel"], cwd=main_file_dir, text=True
+    ).strip()
+except subprocess.CalledProcessError:
+    root_dir = subprocess.check_output(["git", "rev-parse", "--show-toplevel"], text=True).strip()
 
 
 def _check_output(*commands: str) -> str:
     """Wrapper for subprocess.check_output to run commands from root_dir and clean up the output."""
     return subprocess.check_output(commands, text=True, cwd=root_dir).strip()
 
 
 # container for string formatting console codes
-class Style(str, enum.Enum):
+class Style(str, enum.Enum):  # pylint: disable=missing-class-docstring
     BLACK = "\033[30m"
     RED = "\033[31m"
     GREEN = "\033[32m"
     YELLOW = "\033[33m"
     BLUE = "\033[34m"
     MAGENTA = "\033[35m"
     CYAN = "\033[36m"
     WHITE = "\033[37m"
     BOLD = "\033[1m"
     UNDERLINE = "\033[4m"
     RESET = "\033[0m"
 
 
-def styled(text: str, style_code: str) -> str:
+def styled(text: str, style_code: str) -> str:  # pylint: disable=missing-function-docstring
     return style_code + text + Style.RESET
 
 
-def warning(text: str) -> str:
+def warning(text: str) -> str:  # pylint: disable=missing-function-docstring
     return styled(text, Style.BOLD + Style.YELLOW)
 
 
-def failure(text: str) -> str:
+def failure(text: str) -> str:  # pylint: disable=missing-function-docstring
     return styled(text, Style.BOLD + Style.RED)
 
 
-def success(text: str) -> str:
+def success(text: str) -> str:  # pylint: disable=missing-function-docstring
     return styled(text, Style.BOLD + Style.GREEN)
 
 
 # default branches to compare against when performing incremental checks
 default_branches = ("upstream/main", "origin/main", "main")
 
 
 ####################################################################################################
 # methods for identifying files to check
 
 
-def get_tracked_files(
-    include: Union[str, Iterable[str]],
-    exclude: Union[str, Iterable[str]] = "",
-) -> List[str]:
+def get_tracked_files(include: Union[str, Iterable[str]]) -> List[str]:
+    """Identify all files matching the given match_patterns that are tracked by git in this repo.
+    If no patterns are provided, return a list of all tracked files in the repo.
     """
-    Identify all files matching the given match_patterns that are tracked by git in this repo.
-    If no matches are provided, return a list of all python scripts in the repo.
+    include = [include] if isinstance(include, str) else include
+    return _check_output("git", "ls-files", "--deduplicate", *include).splitlines()
 
-    Optionally excludes anything that matches [root_dir]/exclusion for each given exclusion (passed
-    either as a single string or a list of strings).
-    """
-    match_patterns = [include] if isinstance(include, str) else list(include)
-    matching_files = _check_output("git", "ls-files", *match_patterns).splitlines()
-    should_include = inclusion_filter(exclude)
-    return [file for file in matching_files if should_include(file)]
+
+def existing_files(files: Iterable[str]) -> List[str]:
+    """Returns the subset of `files` which actually exist."""
+    return [file for file in files if os.path.isfile(os.path.join(root_dir, file))]
 
 
-def inclusion_filter(exclude: Union[str, Iterable[str]]) -> Callable[[str], bool]:
-    """Construct filter that decides whether a file should be included."""
-    if not exclude:
-        return lambda _: True
+def exclude_files(files: Iterable[str], exclude: Union[str, Iterable[str]]) -> List[str]:
+    """Returns the files which don't match any of the globs in exclude."""
 
-    exclusions = [exclude] if isinstance(exclude, str) else exclude
+    exclude = [exclude] if isinstance(exclude, str) else exclude
 
-    def should_include(file: str) -> bool:
-        return not any(fnmatch.fnmatch(file, exclusion) for exclusion in exclusions)
+    files = list(files)
+    for exclusion in exclude:
+        files = [file for file in files if not fnmatch.fnmatch(file, exclusion)]
 
-    return should_include
+    return files
+
+
+def select_files(files: Iterable[str], include: Union[str, Iterable[str]]) -> List[str]:
+    """Returns the files which match at least one of the globs in include."""
+
+    files = list(files)
+    excluded_files = exclude_files(files, include)
+    return [file for file in files if file not in excluded_files]
 
 
 def get_changed_files(
-    include: Union[str, Iterable[str]],
-    exclude: Union[str, Iterable[str]],
-    revisions: Optional[Iterable[str]] = None,
-    silent: bool = False,
+    files: Iterable[str], revisions: Iterable[str], silent: bool = False
 ) -> List[str]:
-    """
-    Get the files of interest that have been changed in the current branch.
-    Here "files of interest" means all files identified by get_tracked_files (see above).
+    """Returns the files that have been changed in the current branch.
 
     You can specify git revisions to compare against when determining whether a file is considered
     to have "changed".  If multiple revisions are provided, this script compares against their most
     recent common ancestor.
 
     If an empty list of revisions is specified, this script will default to the first of the
     default_branches (specified above) that it finds.  If none of these branches exists, this method
     raises a ValueError.
     """
-    if revisions is None:
-        return []
-    else:
-        revisions = list(revisions)
+    revisions = list(revisions)
 
     # verify that all arguments are valid revisions
     invalid_revisions = [revision for revision in revisions if not _revision_exists(revision)]
     if invalid_revisions:
         rev_text = " ".join([f"'{rev}'" for rev in invalid_revisions])
         raise ValueError(failure(f"Revision(s) not found: {rev_text}"))
 
@@ -132,29 +129,26 @@
         revision_commit = _check_output("git", "rev-parse", base_revision)
         if common_ancestor == revision_commit:
             print(f"Comparing against revision '{base_revision}'")
         else:
             print(f"Comparing against revision '{base_revision}' (merge base '{common_ancestor}')")
 
     changed_files = _check_output("git", "diff", "--name-only", common_ancestor).splitlines()
-    files_to_examine = [
-        file for file in get_tracked_files(include, exclude) if file in changed_files
-    ]
+
+    files_to_examine = [file for file in files if file in changed_files]
 
     if not silent:
         print(f"Found {len(files_to_examine)} changed file(s) to examine")
         for file in files_to_examine:
             print(file)
     return files_to_examine
 
 
 def _get_ancestor(*revisions: str, silent: bool = False) -> str:
-    """
-    Helper function to identify the most recent common ancestor of the given git revisions.
-    """
+    """Helper function to identify the most recent common ancestor of the given git revisions."""
     if len(revisions) == 1:
         return revisions[0]
 
     elif len(revisions) > 1:
         if not silent:
             rev_text = " ".join([f"'{rev}'" for rev in revisions])
             print(f"Finding common ancestor of revisions {rev_text}")
@@ -174,78 +168,128 @@
         ["git", "rev-parse", "--verify", revision],
         stdout=subprocess.DEVNULL,
         stderr=subprocess.DEVNULL,
         cwd=root_dir,
     )
 
 
-def get_test_files(*files: str, exclude: Union[str, Iterable[str]] = "", silent: bool) -> List[str]:
-    """
-    For the given files, identify all associated test files (i.e. files with the same name, but
+def get_test_files(
+    files: Iterable[str], exclude: Union[str, Iterable[str]] = (), silent: bool = False
+) -> List[str]:
+    """For the given files, identify all associated test files (i.e. files with the same name, but
     with a "_test.py" suffix).
     """
-    should_include = inclusion_filter(exclude)
 
-    test_files = set()
+    test_files = []
     for file in files:
-        if file.endswith("_test.py"):
-            test_files.add(file)
-
+        if file.split("::")[0].endswith("_test.py"):
+            test_files.append(file)
         else:
             test_file = re.sub(r"\.py$", "_test.py", file)
-            test_file_exists = os.path.isfile(os.path.join(root_dir, test_file))
-            if test_file_exists and should_include(test_file):
-                test_files.add(test_file)
+            if os.path.isfile(os.path.join(root_dir, test_file)):
+                test_files.append(test_file)
             elif not silent:
                 print(warning(f"WARNING: no test file found for {file}"))
 
-    return list(test_files)
+    if exclude:
+        test_files = exclude_files(test_files, exclude)
+
+    return sorted(set(test_files))
 
 
 ####################################################################################################
 # file parsing, incremental checks, and decorator to exit instead of returning a failing exit code
 
 
-def get_file_parser() -> argparse.ArgumentParser:
-    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)
+def get_file_parser() -> argparse.ArgumentParser:  # pylint: disable=missing-function-docstring
+    parser = argparse.ArgumentParser(
+        allow_abbrev=False, formatter_class=argparse.RawDescriptionHelpFormatter
+    )
 
     help_text = "The files to check. If not passed any files, inspects the entire repo."
     parser.add_argument("files", nargs="*", help=help_text)
 
     help_text = (
         "Run an incremental check on files that have changed since a specified revision.  "
-        + f"If no revisions are specified, compare against the first of {default_branches} "
-        + "that exists.  If multiple revisions are provided, this script compares against "
-        + "their most recent common ancestor.  Incremental checks ignore integration tests."
+        f"If no revisions are specified, compare against the first of {default_branches} "
+        "that exists. If multiple revisions are provided, this script compares against "
+        "their most recent common ancestor. Incremental checks ignore integration tests."
     )
     parser.add_argument("-i", "--incremental", dest="revisions", nargs="*", help=help_text)
+    parser.add_argument(
+        "-x", "--exclude", action="append", metavar="GLOB", help="Exclude files matchine GLOB."
+    )  # TODO: replace "append" with "extend" once we require python>=3.8
 
     return parser
 
 
 def extract_files(
     parsed_args: argparse.Namespace,
-    include: Union[str, Iterable[str]],
-    exclude: Union[str, Iterable[str]] = "",
+    include: Union[str, Iterable[str]] = (),
+    exclude: Union[str, Iterable[str]] = (),
     silent: bool = False,
-    search_if_empty: bool = True,
 ) -> List[str]:
-    files = parsed_args.files if "files" in parsed_args else []
-    if "revisions" in parsed_args:
-        files += get_changed_files(include, exclude, parsed_args.revisions, silent=silent)
-    if not files and search_if_empty:
-        return get_tracked_files(include, exclude)
-    else:
-        return files
+    """Collect a list of files to test, according to command line arguments and `include`/`exclude`
+    values.
+
+    Args:
+        parsed_args: The namespace generated by the ArgumentParser returned by `get_file_parser()`.
+        include: Glob(s) indicating which tracked files to consider (e.g. "*.py").
+        exclude: Glob(s) indicating which tracked files to skip (e.g. "*integration_test.py").
+        silent: If True, restrict printing to warning and error messages.
+
+    Returns:
+        If `parsed_args.files` is empty (i.e. no file paths or globs have been passed to the file
+        parser), a list of tracked files in the active repo branch meeting all of the following
+        criteria:
+        1. The file's path (relative to `root_dir`) matches at least one path or glob in `include`,
+        2. The path does not match any path or glob in `exclude`,
+        3. The path does not match any path or glob in `parsed_args.exclude`,
+        4. If `parsed_args.revisions` is not None, the file additionally must have been modified in
+            the current branch (see `get_changed_files()` for details on how this is determined).
+
+        If `parsed_args.files` is nonempty, a restricted file list containing:
+        1. Paths meeting the above criteria and matching any glob in `parsed_args.files`.
+        2. Paths meeting the above criteria and located in any extant subdirectory passed to the
+            file parser directly.
+        3. Paths to extant files passed to the file parser directly, regardless of above criteria.
+    """
+
+    exclude = [exclude] if isinstance(exclude, str) else exclude
+
+    if parsed_args.exclude:
+        exclude = [*exclude, *parsed_args.exclude]
+
+    files = []
+    globs = []
+    for glob in parsed_args.files:
+        if os.path.isfile(glob.split("::")[0]):  # always include files passed directly as arguments
+            files.append(os.path.relpath(glob, start=root_dir))
+        elif os.path.isdir(glob):  # treat subdirectories the same as the glob "<subdir>/*"
+            globs.append(os.path.normpath(os.path.join(os.path.relpath(glob, start=root_dir), "*")))
+        else:
+            globs.append(glob)
+
+    if globs or not parsed_args.files:
+        tracked_files = get_tracked_files(include)
+        tracked_files = existing_files(tracked_files)
+        tracked_files = exclude_files(tracked_files, exclude)
+        if globs:
+            tracked_files = select_files(tracked_files, globs)
+        files += tracked_files
+
+    if parsed_args.revisions is not None:
+        files = get_changed_files(files, parsed_args.revisions, silent=silent)
+
+    return sorted(set(files))
 
 
 def enable_exit_on_failure(func_with_returncode: Callable[..., int]) -> Callable[..., int]:
-    """
-    Decorator optionally allowing a function to exit instead of returning a failing return code.
-    """
+    """Decorator optionally allowing a function to exit instead of returning a failing
+    return code."""
 
     def func_with_exit(*args: Any, exit_on_failure: bool = False, **kwargs: Any) -> int:
         returncode = func_with_returncode(*args, **kwargs)
         if exit_on_failure and returncode:
             exit(returncode)
         return returncode
```

## general_superstaq/check/configs.py

```diff
@@ -6,15 +6,15 @@
 import textwrap
 from typing import List, Tuple
 
 from general_superstaq.check import check_utils
 
 
 @check_utils.enable_exit_on_failure
-def run(
+def run(  # pylint: disable=missing-function-docstring
     *args: str,
     config_file: str = "setup.cfg",
     ignore_match: str = "# REPO-SPECIFIC CONFIG",
     silent: bool = False,
 ) -> int:
 
     parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)
```

## general_superstaq/check/coverage_.py

```diff
@@ -5,15 +5,15 @@
 import textwrap
 from typing import Iterable, Union
 
 from general_superstaq.check import check_utils
 
 
 @check_utils.enable_exit_on_failure
-def run(
+def run(  # pylint: disable=missing-function-docstring
     *args: str,
     include: Union[str, Iterable[str]] = "*.py",
     exclude: Union[str, Iterable[str]] = "*_integration_test.py",
     silent: bool = False,
 ) -> int:
 
     parser = check_utils.get_file_parser()
@@ -24,29 +24,30 @@
         Ignores integration tests and files in the [repo_root]/examples directory.
         Passes --disable-socket to coverage, unless running with --enable-socket.
         """
     )
 
     parser.add_argument("--enable-socket", action="store_true", help="Force-enable socket.")
 
-    parsed_args, args_to_pass = parser.parse_known_intermixed_args(args)
+    parsed_args, pytest_args = parser.parse_known_intermixed_args(args)
     files = check_utils.extract_files(parsed_args, include, exclude, silent)
 
     silent = silent or not (parsed_args.files or parsed_args.revisions)
-    test_files = check_utils.get_test_files(*files, exclude=exclude, silent=silent)
+    test_files = check_utils.get_test_files(files, exclude=exclude, silent=silent)
 
     if not test_files:
         print("No test files to check for pytest and coverage.")
         return 0
 
-    pytest_args = ["--disable-socket"] if not parsed_args.enable_socket else []
+    if not parsed_args.enable_socket:
+        pytest_args.append("--disable-socket")
 
-    args_to_pass.append("--include=" + ",".join(files))
+    coverage_arg = "--include=" + ",".join(files)
     test_returncode = subprocess.call(
-        ["coverage", "run", *args_to_pass, "-m", "pytest", *test_files, *pytest_args],
+        ["coverage", "run", coverage_arg, "-m", "pytest", *test_files, *pytest_args],
         cwd=check_utils.root_dir,
     )
 
     coverage_returncode = subprocess.call(
         ["coverage", "report", "--precision=2"], cwd=check_utils.root_dir
     )
```

## general_superstaq/check/flake8_.py

```diff
@@ -5,29 +5,32 @@
 import textwrap
 from typing import Iterable, Union
 
 from general_superstaq.check import check_utils
 
 
 @check_utils.enable_exit_on_failure
-def run(
+def run(  # pylint: disable=missing-function-docstring
     *args: str,
     include: Union[str, Iterable[str]] = "*.py",
-    exclude: Union[str, Iterable[str]] = "*_integration_test.py",
+    exclude: Union[str, Iterable[str]] = (),
     silent: bool = False,
 ) -> int:
 
     parser = check_utils.get_file_parser()
     parser.description = textwrap.dedent(
         """
         Runs flake8 on the repository (formatting check).
         """
     )
 
     parsed_args, args_to_pass = parser.parse_known_intermixed_args(args)
     files = check_utils.extract_files(parsed_args, include, exclude, silent)
 
-    return subprocess.call(["flake8", *files, *args_to_pass], cwd=check_utils.root_dir)
+    if files:
+        return subprocess.call(["flake8", *files, *args_to_pass], cwd=check_utils.root_dir)
+
+    return 0
 
 
 if __name__ == "__main__":
     exit(run(*sys.argv[1:]))
```

## general_superstaq/check/format_.py

```diff
@@ -5,44 +5,47 @@
 import textwrap
 from typing import Iterable, Union
 
 from general_superstaq.check import check_utils
 
 
 @check_utils.enable_exit_on_failure
-def run(
+def run(  # pylint: disable=missing-function-docstring
     *args: str,
     include: Union[str, Iterable[str]] = ("*.py", "*.ipynb"),
-    exclude: Union[str, Iterable[str]] = "",
+    exclude: Union[str, Iterable[str]] = (),
     silent: bool = False,
 ) -> int:
 
     parser = check_utils.get_file_parser()
     parser.description = textwrap.dedent(
         """
         Runs black and isort on the repository (formatting check).
         """
     )
 
     parser.add_argument("--apply", action="store_true", help="Apply changes to files.")
 
-    parsed_args, args_to_pass_black = parser.parse_known_intermixed_args(args)
+    parsed_args, args_to_pass_isort = parser.parse_known_intermixed_args(args)
     files = check_utils.extract_files(parsed_args, include, exclude, silent)
+    if not files:
+        return 0
 
     diff_check_args = ["--diff", "--check"] if not parsed_args.apply else []
     returncode_black = subprocess.call(
-        ["black", *files, *diff_check_args, *args_to_pass_black], cwd=check_utils.root_dir
+        ["black", *files, *diff_check_args], cwd=check_utils.root_dir
     )
 
     if returncode_black > 1:
         # this only occurs if black could not parse a file (for example due to a syntax error)
         return returncode_black
 
+    args_to_pass_isort += ["--resolve-all-configs", f"--config-root={check_utils.root_dir}"]
     returncode_isort = subprocess.call(
-        ["isort", *files, *diff_check_args], cwd=check_utils.root_dir
+        ["isort", *files, *diff_check_args, *args_to_pass_isort], cwd=check_utils.root_dir
     )
 
     if returncode_black == 1 or returncode_isort == 1:
         # some files should be reformatted, but there don't seem to be any bona fide errors
         command = "./check/format_.py --apply"
         text = f"Run '{command}' (from the repo root directory) to format files."
         print(check_utils.warning(text))
```

## general_superstaq/check/mypy_.py

```diff
@@ -5,18 +5,18 @@
 import textwrap
 from typing import Iterable, Union
 
 from general_superstaq.check import check_utils
 
 
 @check_utils.enable_exit_on_failure
-def run(
+def run(  # pylint: disable=missing-function-docstring
     *args: str,
     include: Union[str, Iterable[str]] = "*.py",
-    exclude: Union[str, Iterable[str]] = "",
+    exclude: Union[str, Iterable[str]] = "*setup.py",
     silent: bool = False,
 ) -> int:
 
     parser = check_utils.get_file_parser()
     parser.description = textwrap.dedent(
         """
         Runs mypy on the repository (typing check).
```

## general_superstaq/check/pylint_.py

```diff
@@ -6,49 +6,56 @@
 import textwrap
 from typing import Iterable, Union
 
 from general_superstaq.check import check_utils
 
 
 @check_utils.enable_exit_on_failure
-def run(
+def run(  # pylint: disable=missing-function-docstring
     *args: str,
     include: Union[str, Iterable[str]] = "*.py",
-    exclude: Union[str, Iterable[str]] = "",
+    exclude: Union[str, Iterable[str]] = (),
     silent: bool = False,
 ) -> int:
 
     parser = check_utils.get_file_parser()
     parser.description = textwrap.dedent(
         """
         Runs pylint on the repository (formatting check).
         NOTE: Only checks incrementally changed files by default.
         """
     )
 
     num_cores = max(multiprocessing.cpu_count() // 2, 1)
 
-    parser.add_argument("-a", "--all", action="store_true", help="Run pylint on the entire repo.")
+    # perform incremental check by default
+    parser.set_defaults(revisions=[])
+    parser.add_argument(
+        "-a",
+        "--all",
+        action="store_const",
+        const=None,
+        dest="revisions",
+        help="Run pylint on the entire repo.",
+    )
+
     parser.add_argument(
         "-j",
         "--cores",
         type=int,
         default=num_cores,
         help="Number of cores to use for this test.",
     )
 
     parsed_args, args_to_pass = parser.parse_known_intermixed_args(args)
-    files = check_utils.extract_files(parsed_args, include, exclude, silent, search_if_empty=False)
+    files = check_utils.extract_files(parsed_args, include, exclude, silent)
 
     args_to_pass.append(f"-j{parsed_args.cores}")
 
-    if parsed_args.all:
-        files += check_utils.get_tracked_files(include, exclude)
-    elif not files:
-        parsed_args.revisions = []  # perform a default incremental check
-        files = check_utils.extract_files(parsed_args, include, exclude, silent)
+    if files:
+        return subprocess.call(["pylint", *files, *args_to_pass], cwd=check_utils.root_dir)
 
-    return subprocess.call(["pylint", *files, *args_to_pass], cwd=check_utils.root_dir)
+    return 0
 
 
 if __name__ == "__main__":
     exit(run(*sys.argv[1:]))
```

## general_superstaq/check/pytest_.py

```diff
@@ -1,19 +1,19 @@
 #!/usr/bin/env python3
 
 import subprocess
 import sys
 import textwrap
-from typing import Callable, Iterable, Optional, Tuple, Union
+from typing import Callable, Iterable, Optional, Union
 
 from general_superstaq.check import check_utils
 
 
 @check_utils.enable_exit_on_failure
-def run(
+def run(  # pylint: disable=missing-function-docstring
     *args: str,
     include: Optional[Union[str, Iterable[str]]] = None,
     exclude: Optional[Union[str, Iterable[str]]] = None,
     integration_setup: Optional[Callable[[], None]] = None,
     silent: bool = False,
 ) -> int:
 
@@ -32,60 +32,44 @@
         "--notebook",
         action="store_true",
         help="Run pytest on *.ipynb files.",
     )
     exclusive_group.add_argument(
         "--integration",
         action="store_true",
-        help="Run pytest on *_integration_test.py files, ignoring dev_tools/*.",
+        help="Run pytest on *_integration_test.py files.",
     )
 
     parser.add_argument("--enable-socket", action="store_true", help="Force-enable socket.")
 
     parsed_args, args_to_pass = parser.parse_known_intermixed_args(args)
-    include, exclude = _get_file_search_options(
-        parsed_args.notebook, parsed_args.integration, include, exclude
-    )
+
+    exclude = [exclude] if isinstance(exclude, str) else [] if exclude is None else list(exclude)
+    if parsed_args.notebook:
+        include = include or "*.ipynb"
+    elif parsed_args.integration:
+        include = include or "*_integration_test.py"
+    else:
+        include = include or "*.py"
+        exclude.append("*_integration_test.py")
+
     files = check_utils.extract_files(parsed_args, include, exclude, silent)
 
     if parsed_args.notebook:
         args_to_pass += ["--nbmake"]
+    elif not parsed_args.integration:
+        files = check_utils.get_test_files(files, exclude=exclude, silent=silent)
 
     if not parsed_args.integration and not parsed_args.enable_socket:
         args_to_pass += ["--disable-socket"]
 
+    if not files:
+        return 0
+
     if parsed_args.integration and integration_setup:
         integration_setup()
 
     return subprocess.call(["pytest", *files, *args_to_pass], cwd=check_utils.root_dir)
 
 
-def _get_file_search_options(
-    notebook_mode: bool,
-    integration_mode: bool,
-    include: Optional[Union[str, Iterable[str]]],
-    exclude: Optional[Union[str, Iterable[str]]],
-) -> Tuple[Union[str, Iterable[str]], Union[str, Iterable[str]]]:
-    """If either of the include/exclude options are None, set them to reasonable defaults."""
-
-    if notebook_mode:
-        default_include = "*.ipynb"
-        default_exclude = ""
-
-    elif integration_mode:
-        default_include = "*_integration_test.py"
-        default_exclude = ""
-
-    else:
-        default_include = "*_test.py"
-        default_exclude = "*_integration_test.py"
-
-    if include is None:
-        include = default_include
-    if exclude is None:
-        exclude = default_exclude
-
-    return include, exclude
-
-
 if __name__ == "__main__":
     exit(run(*sys.argv[1:]))
```

## general_superstaq/check/requirements.py

```diff
@@ -7,21 +7,22 @@
 import re
 import subprocess
 import sys
 import textwrap
 import urllib.request
 from typing import Dict, Iterable, List, Tuple, Union
 
-import pkg_resources
+import packaging.version
 
+import general_superstaq as gss
 from general_superstaq.check import check_utils
 
 
 @check_utils.enable_exit_on_failure
-def run(
+def run(  # pylint: disable=missing-function-docstring
     *args: str,
     include: Union[str, Iterable[str]] = "*requirements.txt",
     exclude: Union[str, Iterable[str]] = "",
     upstream_match: str = "*superstaq*",
     silent: bool = False,
 ) -> int:
 
@@ -94,16 +95,15 @@
             print(check_utils.warning(error))
         return False, []  # file cannot be cleaned up, and there are no requirements to track
 
     needs_cleanup, requirements = _sort_requirements(requirements)
     if needs_cleanup and not silent:
         print(check_utils.failure(f"{req_file} is not sorted."))
 
-    is_repo_req = not os.path.dirname(req_file)  # repo requirements are in the root directory
-    if is_repo_req and not only_sort and can_connect_to_pypi:
+    if not only_sort and can_connect_to_pypi:
         needs_cleanup |= _check_package_versions(
             req_file, requirements, upstream_match, silent, strict=True
         )
 
     return needs_cleanup, requirements
 
 
@@ -142,16 +142,16 @@
     needs_cleanup = requirements != sorted_requirements
     return needs_cleanup, sorted_requirements
 
 
 def _check_package_versions(
     req_file: str, requirements: List[str], match: str, silent: bool, strict: bool
 ) -> bool:
-    """
-    Check whether package requirements matching 'match' are up-to-date with their latest versions.
+    """Check whether package requirements matching 'match' are up-to-date with their latest
+    versions.
     Print warnings if matching requirements are out of date.  Return whether the requirements file
     *must* be updated, i.e., return 'True' iff packages are out of date and 'strict == True'.
     """
     text_format = check_utils.failure if strict else check_utils.warning
 
     up_to_date = True
     for idx, req in enumerate(requirements):
@@ -180,15 +180,18 @@
     return strict and not up_to_date  # True iff we are *requiring* changes to the requirements file
 
 
 @functools.lru_cache()
 def _get_latest_version(package: str) -> str:
     base_package = package.split("[")[0]  # remove options: package_name[options] --> package_name
     pypi_url = f"https://pypi.org/pypi/{base_package}/json"
-    return json.loads(urllib.request.urlopen(pypi_url).read().decode())["info"]["version"]
+    pypi_version = json.loads(urllib.request.urlopen(pypi_url).read().decode())["info"]["version"]
+
+    # If the local gss version is newer, return that instead
+    return max(pypi_version, gss.__version__, key=packaging.version.parse)
 
 
 def _inspect_local_version(package: str, latest_version: str) -> None:
     base_package = package.split("[")[0]  # remove options: package_name[options] --> package_name
     try:
         installed_info = subprocess.check_output(
             [sys.executable, "-m", "pip", "show", base_package],
@@ -204,22 +207,14 @@
         print(check_utils.warning(warning))
         print(check_utils.warning(suggestion))
     except subprocess.CalledProcessError:
         # pip returned a non-zero exit status; let pip print its own error message
         pass
 
 
-def _check_requirements(requirements: List[str]) -> None:
-    # wrapper for "pkg_resources.require" to check that all requirements are satisfied
-    try:
-        pkg_resources.require(iter(requirements))
-    except (pkg_resources.DistributionNotFound, pkg_resources.VersionConflict) as error:
-        print(check_utils.warning("WARNING: " + error.report()))
-
-
 def _cleanup(
     requirements_to_fix: Dict[str, List[str]],
     apply_changes: bool,
     silent: bool,
 ) -> None:
     if not requirements_to_fix:
         print("Nothing to fix in requirements files.")
```

## general_superstaq/check/setup.cfg

```diff
@@ -9,25 +9,30 @@
 color_output = True
 line_length = 100
 
 [coverage:report]
 show_missing = True
 fail_under = 100
 skip_covered = True
+exclude_lines =
+    pragma: no cover
+    if TYPE_CHECKING:
 
 [coverage:run]
 include = ./*
 
 [flake8]
 count = True
 max-complexity = 10
 max-line-length = 100
 show_source = True
 statistics = True
-extend-ignore = E203, I100, I101, I201, I202  # these errors conflict with black and/or isort
+enable-extensions = TC, TC1
+# these errors conflict with black and/or isort:
+extend-ignore = E203, I100, I101, I201, I202
 
 [mypy]
 ignore_missing_imports = True
 show_error_codes = True
 disallow_any_generics = True
 disallow_incomplete_defs = True
 disallow_untyped_defs = True
@@ -36,40 +41,45 @@
 non_interactive = True
 no_implicit_optional = True
 plugins = numpy.typing.mypy_plugin
 
 [pylint.MAIN]
 max-line-length=100
 disable=all
+load-plugins=pylint.extensions.docparams,pylint.extensions.docstyle
 output-format=colorized
 score=no
 reports=no
 enable=
     anomalous-backslash-in-string,
     assert-on-tuple,
     bad-indentation,
     bad-option-value,
     bad-reversed-sequence,
     bad-super-call,
     consider-merging-isinstance,
     continue-in-finally,
     dangerous-default-value,
+    docstyle,
     duplicate-argument-name,
     expression-not-assigned,
     function-redefined,
     inconsistent-mro,
     init-is-generator,
     line-too-long,
     lost-exception,
+    missing-class-docstring,
+    missing-function-docstring,
     missing-kwoa,
     mixed-line-endings,
     not-callable,
     no-value-for-parameter,
     nonexistent-operator,
     not-in-loop,
+    parameter_documentation,
     pointless-statement,
     redefined-builtin,
     relative-beyond-top-level,
     return-arg-in-generator,
     return-in-init,
     return-outside-function,
     simplifiable-if-statement,
```

## Comparing `general_superstaq-0.3.9.dist-info/METADATA` & `general_superstaq-0.4.0.dist-info/METADATA`

 * *Files 12% similar despite different names*

```diff
@@ -1,32 +1,33 @@
 Metadata-Version: 2.1
 Name: general-superstaq
-Version: 0.3.9
-Summary: The general module that provides tools and access to SuperstaQ
-Home-page: https://github.com/SupertechLabs/general-superstaq
-Author: Super.tech
-Author-email: pranav@super.tech
+Version: 0.4.0
+Summary: The general module that provides tools and access to Superstaq
+Home-page: https://github.com/Infleqtion/client-superstaq
+Author: Superstaq development team
+Author-email: superstaq@infleqtion.com
 License: Apache 2
 Platform: UNKNOWN
-Requires-Python: >=3.7.0
+Requires-Python: >=3.8.0
 Description-Content-Type: text/markdown
 Requires-Dist: numpy (>=1.21.0)
 Requires-Dist: qubovert (>=1.2.3)
 Requires-Dist: requests (>=2.26.0)
 Provides-Extra: dev
 Requires-Dist: black-configparser (~=0.2.0b2) ; extra == 'dev'
 Requires-Dist: black[jupyter] (~=22.3.0) ; extra == 'dev'
-Requires-Dist: flake8 (~=3.8.4) ; extra == 'dev'
-Requires-Dist: isort[colors] (~=5.10.1) ; extra == 'dev'
-Requires-Dist: mypy (>=0.961) ; extra == 'dev'
-Requires-Dist: nbmake (~=1.3.0) ; extra == 'dev'
-Requires-Dist: pylint (>=2.13.0) ; extra == 'dev'
+Requires-Dist: flake8 (>=3.8.4) ; extra == 'dev'
+Requires-Dist: flake8-type-checking (>=2.1.0) ; extra == 'dev'
+Requires-Dist: isort[colors] (>=5.10.1) ; extra == 'dev'
+Requires-Dist: mypy (>=1.0.0) ; extra == 'dev'
+Requires-Dist: nbmake (>=1.3.0) ; extra == 'dev'
+Requires-Dist: pylint (>=2.15.0) ; extra == 'dev'
 Requires-Dist: pytest (>=6.2.5) ; extra == 'dev'
 Requires-Dist: pytest-cov (>=2.11.1) ; extra == 'dev'
 Requires-Dist: pytest-randomly (>=3.10.1) ; extra == 'dev'
 Requires-Dist: pytest-socket (>=0.4.1) ; extra == 'dev'
 Requires-Dist: pyyaml (>=6.0) ; extra == 'dev'
 
 # general-superstaq
-This package is used to house code shared across Super.tech's codebase including the clients ([cirq-superstaq](https://github.com/SupertechLabs/cirq-superstaq) and [qiskit-superstaq](https://github.com/SupertechLabs/qiskit-superstaq)), [SupermarQ](https://github.com/SupertechLabs/SupermarQ), and more.
+This package is used to house code shared across Superstaq development team's codebase including the clients ([cirq-superstaq](https://github.com/Infleqtion/client-superstaq#-cirq-superstaq-) and [qiskit-superstaq](https://github.com/Infleqtion/client-superstaq#-qiskit-superstaq-)), [Supermarq](https://github.com/Infleqtion/client-superstaq#-supermarq-), and more.
```

## Comparing `general_superstaq-0.3.9.dist-info/RECORD` & `general_superstaq-0.4.0.dist-info/RECORD`

 * *Files 13% similar despite different names*

```diff
@@ -1,40 +1,37 @@
-general_superstaq/__init__.py,sha256=Aw62r24msNVUZg1R4eELvGnOggTRGOr73veEBXMQBCE,902
+general_superstaq/__init__.py,sha256=OhTzhpHJImER3mDzBTMeqEursg53GzWzHpYXtwj6FwI,1057
 general_superstaq/_init_vars.py,sha256=goHcdq5b2jZFaKwWkj2kFh1SliuyXTyUk93FBVsdqb8,64
-general_superstaq/_version.py,sha256=xmkmdvq15kb61xdtCoa1YARnvHBnUgI-0GWIJYvHNeA,22
-general_superstaq/_version_test.py,sha256=AEcakXhIvjKK9rUQPIjoG4awvVjLCUiLSJGp8Rivk2U,246
-general_superstaq/finance.py,sha256=ZKO-dPmR55Cp8-X3NXDRlGhjrQ9gXEGGvx9HnqpS3wc,7009
-general_superstaq/finance_test.py,sha256=Jlo8564OIaAC7n81cDtGl3N7lxFv1m6oHbriaHCbgu0,3872
-general_superstaq/logistics.py,sha256=QgsNlIjxR_Qzsp5HHpjm6uZPukVUuZmxCWpTG8c1B1w,4888
-general_superstaq/logistics_test.py,sha256=c-iZ8SeJATmlxLkYG5mZEguknTONIs-YV7xcCl_GecQ,3258
+general_superstaq/_version.py,sha256=42STGor_9nKYXumfeV5tiyD_M8VdcddX7CEexmibPBk,22
+general_superstaq/_version_test.py,sha256=27DzbOMN2JIhwdSk43ZpKYx3kpWQjtL66Y5OmqORyhc,292
 general_superstaq/py.typed,sha256=H0PmAKP6JZUUkmoj4zWMUfqMLuhIgp2R1ELdo27xvfs,76
-general_superstaq/qubo.py,sha256=0JYcPzXqdwqqK2onVaYaARfLZiyfLmV4c-ZgVRVpUQc,1447
-general_superstaq/qubo_test.py,sha256=Ilfd9bEnGt9DLfAsgbs5X5lXX--0GjXBMHT6YzkzTwI,820
-general_superstaq/resource_estimate.py,sha256=m8uOqXOzox1r9ro94iZeLl5cRgZ6k-UHIdf8NPm6pW4,987
-general_superstaq/resource_estimate_test.py,sha256=crooUVKqcHI2aqr8sd5RudhbE35uhesOTY1UeOi0g-g,328
-general_superstaq/serialization.py,sha256=BA7lrhPesupq6seLGdj_CNAefMyintUQlYDwA9l2v6I,801
-general_superstaq/serialization_test.py,sha256=Xibbeq6et2ZWlXjhgkMB650IQKjCWnHYj4kxNZVavcE,271
-general_superstaq/superstaq_client.py,sha256=xjq2sRooGi-UytFdwZTmJNeTOkC6n-2nTmDaS4h6uSI,13618
-general_superstaq/superstaq_client_test.py,sha256=fqZHatG2jMdB9-MMDQX8sYu8otSfxp2Y5tfDuKXXKIc,22302
-general_superstaq/superstaq_exceptions.py,sha256=eHhq9ndqeVAvECxXZcQpXba4gsB0kX4GU-Ircq_esds,1461
-general_superstaq/superstaq_exceptions_test.py,sha256=_6UrreKr5Ep4h9k5JHIWQ_Qbe_caRVDLhsHy_FNf8ks,1677
-general_superstaq/typing.py,sha256=2_hCHynEF7ShfUn2QPQFA7EJQ2HxdAx9F6PGn-6T9pA,2305
-general_superstaq/user_config.py,sha256=geIz-NWuxpS7ADDkVDjIax5tHH3RyPWOpfFjT9l5wFc,6412
-general_superstaq/user_config_test.py,sha256=TZP5iNm9TQH79Jrg3jatyTqRjxuVs_meUR34jG53cs0,5530
+general_superstaq/qubo.py,sha256=vhC_fVno9DKPta5O8B6xcOM_3PiTjNO028KrHc9AKuE,996
+general_superstaq/qubo_test.py,sha256=vjmny6PNTEo8SoUSdCdLX5R71UVBcyf022kyYJ-x4-s,865
+general_superstaq/resource_estimate.py,sha256=8PShHLw4brNAJi9TX0JEiiy8gp5caWEQ7i0dLRBF4K4,1029
+general_superstaq/resource_estimate_test.py,sha256=mS5Xq_Sk1y734ZU8hfGz7eXb8nN1Xs1n8vmoadMrHxg,373
+general_superstaq/serialization.py,sha256=v8Dq331nus5ArizVbfWoqYT1t4jpMY1gldaHwJevWGw,926
+general_superstaq/serialization_test.py,sha256=VKrcn-3SspDSwoSkcJhSs-4IsAQxMEMw1ioZAMFUlPQ,316
+general_superstaq/superstaq_client.py,sha256=MtHbDa0m7wfz4u3hfQ5x1VHeiejht-0aTNFjhbBJjCA,18523
+general_superstaq/superstaq_client_test.py,sha256=_5isB31VqZfBiVRIiOtUHtd1sYsBS1ATq5WILQ80Bq8,24407
+general_superstaq/superstaq_exceptions.py,sha256=M2esueGad3o85keyGcakb-cm39Dg6u2zuTEwnFpZOxc,1560
+general_superstaq/superstaq_exceptions_test.py,sha256=2OVe30oIxTINREy3YPU5J10bTJgjLXncuSmuWSUmKn0,1763
+general_superstaq/typing.py,sha256=Eh98nrxHIuCByLZQwBH56Qs6wd8toGZazuXSrPfLakM,2232
+general_superstaq/user_config.py,sha256=TeN6WHHk5eGLlAaD5A78TCRgtmNzL9OZDe_nTq4wnT0,8830
+general_superstaq/user_config_test.py,sha256=MxLAqDOXY1Kl46EVJsUjDb--dxTO5-z1WhZ2RvivpOM,8537
+general_superstaq/validation.py,sha256=gywf5FS7DqSXqLK5UN3D7cab_jtYiSwoElGs0dMrOhg,2078
+general_superstaq/validation_test.py,sha256=TK1sAyUJGaXr9a8pc3bL_LmhBlhid_QVZ6vm76TK_Lc,1560
 general_superstaq/check/__init__.py,sha256=SRyCR1InR45J2uj8urU4gjr5vpZrDa1u95e_MqCTbwM,359
-general_superstaq/check/all_.py,sha256=7TilCYgHA25Ieoyv1_8zZXbLK-PuMCIIBDWdV6QksUk,2636
-general_superstaq/check/build_docs.py,sha256=kFgEVG1-yxsoh7UDsExRouykPibxbccUsfiG-99ZrRI,1147
-general_superstaq/check/check_utils.py,sha256=4htY-QvxzB0YqRI1kWm4p-T8d_D3lVCTdzkDZtmvCWI,8910
-general_superstaq/check/configs.py,sha256=7LApLiJrdaqLS0aEPeqvfX-hXJExV59SXA1Yoh76Wkw,3774
-general_superstaq/check/coverage_.py,sha256=SpBdkhaUJ10ONmFBTRKExHZSeNPJnv_jbugyEwy_oKY,2075
-general_superstaq/check/flake8_.py,sha256=yKQtAPw3cjDQCY8pXB-obxmFLb_3S-yfC9pK73y3L_U,839
-general_superstaq/check/format_.py,sha256=eA2eBBvI4YPkV0oxfFhT7VJg6oOjnKlD0LY4ZJlpdQ4,1699
-general_superstaq/check/mypy_.py,sha256=GVZaRDtRYkR13xvkqmiclZZ6Gx69Q0zT80tEXo59EKI,871
-general_superstaq/check/pylint_.py,sha256=dbkZgq66qlX6z6FeTdCnquzpDvoPo3MT0vhpL7Rex5M,1567
-general_superstaq/check/pytest_.py,sha256=iApnx8a0YUDrtpusLTbw6qraZ6z6UTc_9O50GCVSIG8,2794
-general_superstaq/check/requirements.py,sha256=g-pHy0L5mIGnYRCatUIwcgSp7IuEKWzV5io1Yn76FMA,9373
-general_superstaq/check/setup.cfg,sha256=S-4h8rqonBRiKMGU9psC-3UbVrwFVobIzVmYcBcmiJY,2303
-general_superstaq-0.3.9.dist-info/LICENSE,sha256=iX_ssVZ8xAgLqWW2e92S2GEkakzvUzK2B29C98hStro,11349
-general_superstaq-0.3.9.dist-info/METADATA,sha256=stD5M1tOz1GPhPFQrjrDG3AH4UFfwwVmXrbS93aKiLc,1432
-general_superstaq-0.3.9.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-general_superstaq-0.3.9.dist-info/top_level.txt,sha256=73AX23AFPvHHHXD4EHy0rewavlV-R7-hNY46bNkJD-o,18
-general_superstaq-0.3.9.dist-info/RECORD,,
+general_superstaq/check/all_.py,sha256=g7kviwjF93kQQh0bx3XuQz_TL5_GgkraaweLTIjP9gA,2809
+general_superstaq/check/build_docs.py,sha256=B5UyOfqibGE21_n4gK7-Rp5lAbMLHKFs6pFMVenvPMc,1199
+general_superstaq/check/check_utils.py,sha256=Hr-1h7whHp3_sjvVSHcJT7gMZCEDEiBiXXObTRFew54,11666
+general_superstaq/check/configs.py,sha256=dP_iomOPzTkn_6G8Gm9PKqA6dH3IeK1aNwqjupxIu5Y,3820
+general_superstaq/check/coverage_.py,sha256=PS3gIY-_FJPHphBOyWa-NWMi1W3VjoaxcpSmoPwISRI,2117
+general_superstaq/check/flake8_.py,sha256=Fb9ETqPMXryhf5_ySuHS1TW2PAc9yZ_ouSTxytD6lus,896
+general_superstaq/check/format_.py,sha256=M_tVe0v3tRa_EGrcwBqaacMge3I-Oglmj9l4lHAueTk,1873
+general_superstaq/check/mypy_.py,sha256=KNRPap-KpBGyhM9Ivt2CgB_qn5xUQo_aHI-ZgdFdFdU,926
+general_superstaq/check/pylint_.py,sha256=vYCyu9yOf81DFy2F8Do3Rbvpdavhm4agrsDcjKaUmy0,1525
+general_superstaq/check/pytest_.py,sha256=1U9AhNdiruTxBoadQtus-Y0tyLFB-VvkDsNWzy1rw-8,2404
+general_superstaq/check/requirements.py,sha256=cJQZIcURNYPME9bHgQ7Mbfv-piS4mx1JbjJCpy8HpsM,9128
+general_superstaq/check/setup.cfg,sha256=zfAwBsJracKMEJ-p-bS-u6AdjynC_69M0KUrHUQKVtU,2562
+general_superstaq-0.4.0.dist-info/METADATA,sha256=BZ23rhOqmK6BUjNkiACiZ99MA20Icy1mprtnDJoRSQU,1578
+general_superstaq-0.4.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+general_superstaq-0.4.0.dist-info/top_level.txt,sha256=73AX23AFPvHHHXD4EHy0rewavlV-R7-hNY46bNkJD-o,18
+general_superstaq-0.4.0.dist-info/RECORD,,
```

