# Comparing `tmp/qiskit_superstaq-0.3.9-py3-none-any.whl.zip` & `tmp/qiskit_superstaq-0.4.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,25 @@
-Zip file size: 32129 bytes, number of entries: 22
--rw-r--r--  2.0 unx      645 b- defN 22-Dec-08 20:02 qiskit_superstaq/__init__.py
--rw-r--r--  2.0 unx       22 b- defN 22-Dec-08 20:02 qiskit_superstaq/_version.py
--rw-r--r--  2.0 unx      245 b- defN 22-Dec-08 20:02 qiskit_superstaq/_version_test.py
--rw-r--r--  2.0 unx     7720 b- defN 22-Dec-08 20:02 qiskit_superstaq/compiler_output.py
--rw-r--r--  2.0 unx     7102 b- defN 22-Dec-08 20:02 qiskit_superstaq/compiler_output_test.py
--rw-r--r--  2.0 unx    12754 b- defN 22-Dec-08 20:02 qiskit_superstaq/custom_gates.py
--rw-r--r--  2.0 unx     8614 b- defN 22-Dec-08 20:02 qiskit_superstaq/custom_gates_test.py
--rw-r--r--  2.0 unx     7750 b- defN 22-Dec-08 20:02 qiskit_superstaq/daily_integration_test.py
--rw-r--r--  2.0 unx       68 b- defN 22-Dec-08 20:02 qiskit_superstaq/py.typed
--rw-r--r--  2.0 unx     3544 b- defN 22-Dec-08 20:02 qiskit_superstaq/serialization.py
--rw-r--r--  2.0 unx     3791 b- defN 22-Dec-08 20:02 qiskit_superstaq/serialization_test.py
--rw-r--r--  2.0 unx     4282 b- defN 22-Dec-08 20:02 qiskit_superstaq/superstaq_backend.py
--rw-r--r--  2.0 unx     3651 b- defN 22-Dec-08 20:02 qiskit_superstaq/superstaq_backend_test.py
--rw-r--r--  2.0 unx     4951 b- defN 22-Dec-08 20:02 qiskit_superstaq/superstaq_job.py
--rw-r--r--  2.0 unx     3503 b- defN 22-Dec-08 20:02 qiskit_superstaq/superstaq_job_test.py
--rw-r--r--  2.0 unx    13771 b- defN 22-Dec-08 20:02 qiskit_superstaq/superstaq_provider.py
--rw-r--r--  2.0 unx    11406 b- defN 22-Dec-08 20:02 qiskit_superstaq/superstaq_provider_test.py
--rw-r--r--  2.0 unx    11416 b- defN 22-Dec-08 20:02 qiskit_superstaq-0.3.9.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx     2253 b- defN 22-Dec-08 20:02 qiskit_superstaq-0.3.9.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Dec-08 20:02 qiskit_superstaq-0.3.9.dist-info/WHEEL
--rw-r--r--  2.0 unx       17 b- defN 22-Dec-08 20:02 qiskit_superstaq-0.3.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2004 b- defN 22-Dec-08 20:02 qiskit_superstaq-0.3.9.dist-info/RECORD
-22 files, 109601 bytes uncompressed, 28815 bytes compressed:  73.7%
+Zip file size: 39185 bytes, number of entries: 23
+-rw-r--r--  2.0 unx      918 b- defN 23-Jun-27 19:52 qiskit_superstaq/__init__.py
+-rw-r--r--  2.0 unx       22 b- defN 23-Jun-27 19:52 qiskit_superstaq/_version.py
+-rw-r--r--  2.0 unx      290 b- defN 23-Jun-27 19:52 qiskit_superstaq/_version_test.py
+-rw-r--r--  2.0 unx    12027 b- defN 23-Jun-27 19:52 qiskit_superstaq/compiler_output.py
+-rw-r--r--  2.0 unx     9574 b- defN 23-Jun-27 19:52 qiskit_superstaq/compiler_output_test.py
+-rw-r--r--  2.0 unx    18928 b- defN 23-Jun-27 19:52 qiskit_superstaq/custom_gates.py
+-rw-r--r--  2.0 unx     9858 b- defN 23-Jun-27 19:52 qiskit_superstaq/custom_gates_test.py
+-rw-r--r--  2.0 unx     8418 b- defN 23-Jun-27 19:52 qiskit_superstaq/daily_integration_test.py
+-rw-r--r--  2.0 unx       68 b- defN 23-Jun-27 19:52 qiskit_superstaq/py.typed
+-rw-r--r--  2.0 unx     6338 b- defN 23-Jun-27 19:52 qiskit_superstaq/serialization.py
+-rw-r--r--  2.0 unx     5933 b- defN 23-Jun-27 19:52 qiskit_superstaq/serialization_test.py
+-rw-r--r--  2.0 unx    15719 b- defN 23-Jun-27 19:52 qiskit_superstaq/superstaq_backend.py
+-rw-r--r--  2.0 unx    10173 b- defN 23-Jun-27 19:52 qiskit_superstaq/superstaq_backend_test.py
+-rw-r--r--  2.0 unx     6944 b- defN 23-Jun-27 19:52 qiskit_superstaq/superstaq_job.py
+-rw-r--r--  2.0 unx     7118 b- defN 23-Jun-27 19:52 qiskit_superstaq/superstaq_job_test.py
+-rw-r--r--  2.0 unx    16192 b- defN 23-Jun-27 19:52 qiskit_superstaq/superstaq_provider.py
+-rw-r--r--  2.0 unx    15299 b- defN 23-Jun-27 19:52 qiskit_superstaq/superstaq_provider_test.py
+-rw-r--r--  2.0 unx      826 b- defN 23-Jun-27 19:52 qiskit_superstaq/validation.py
+-rw-r--r--  2.0 unx      764 b- defN 23-Jun-27 19:52 qiskit_superstaq/validation_test.py
+-rw-r--r--  2.0 unx     2146 b- defN 23-Jun-27 19:52 qiskit_superstaq-0.4.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-27 19:52 qiskit_superstaq-0.4.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       17 b- defN 23-Jun-27 19:52 qiskit_superstaq-0.4.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2082 b- defN 23-Jun-27 19:52 qiskit_superstaq-0.4.0.dist-info/RECORD
+23 files, 149746 bytes uncompressed, 35753 bytes compressed:  76.1%
```

## zipnote {}

```diff
@@ -45,23 +45,26 @@
 
 Filename: qiskit_superstaq/superstaq_provider.py
 Comment: 
 
 Filename: qiskit_superstaq/superstaq_provider_test.py
 Comment: 
 
-Filename: qiskit_superstaq-0.3.9.dist-info/LICENSE.txt
+Filename: qiskit_superstaq/validation.py
 Comment: 
 
-Filename: qiskit_superstaq-0.3.9.dist-info/METADATA
+Filename: qiskit_superstaq/validation_test.py
 Comment: 
 
-Filename: qiskit_superstaq-0.3.9.dist-info/WHEEL
+Filename: qiskit_superstaq-0.4.0.dist-info/METADATA
 Comment: 
 
-Filename: qiskit_superstaq-0.3.9.dist-info/top_level.txt
+Filename: qiskit_superstaq-0.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: qiskit_superstaq-0.3.9.dist-info/RECORD
+Filename: qiskit_superstaq-0.4.0.dist-info/top_level.txt
+Comment: 
+
+Filename: qiskit_superstaq-0.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## qiskit_superstaq/__init__.py

```diff
@@ -1,23 +1,36 @@
-from . import compiler_output, serialization
+from . import compiler_output, serialization, validation
 from ._version import __version__
-from .compiler_output import active_qubit_indices
-from .custom_gates import AceCR, AQTiCCXGate, AQTiToffoliGate, ParallelGates, ZZSwapGate
-from .superstaq_backend import SuperstaQBackend
-from .superstaq_job import SuperstaQJob
-from .superstaq_provider import SuperstaQProvider
+from .compiler_output import active_qubit_indices, measured_qubit_indices
+from .custom_gates import (
+    AceCR,
+    AQTiCCXGate,
+    AQTiToffoliGate,
+    ParallelGates,
+    StrippedCZGate,
+    ZZSwapGate,
+)
+from .serialization import deserialize_circuits, serialize_circuits
+from .superstaq_backend import SuperstaqBackend
+from .superstaq_job import SuperstaqJob
+from .superstaq_provider import SuperstaqProvider
 
 __all__ = [
     "active_qubit_indices",
     "AceCR",
     "AQTiCCXGate",
     "AQTiToffoliGate",
     "compiler_output",
+    "deserialize_circuits",
     "ITOFFOLIGate",
+    "measured_qubit_indices",
     "ParallelGates",
     "serialization",
-    "SuperstaQBackend",
-    "SuperstaQJob",
-    "SuperstaQProvider",
+    "serialize_circuits",
+    "StrippedCZGate",
+    "SuperstaqBackend",
+    "SuperstaqJob",
+    "SuperstaqProvider",
+    "validation",
     "ZZSwapGate",
     "__version__",
 ]
```

## qiskit_superstaq/_version.py

```diff
@@ -1 +1 @@
-__version__ = "0.3.9"
+__version__ = "0.4.0"
```

## qiskit_superstaq/_version_test.py

```diff
@@ -1,7 +1,8 @@
+# pylint: disable=missing-function-docstring
 import packaging.version
 
 import qiskit_superstaq as qss
 
 
 def test_version() -> None:
     assert (
```

## qiskit_superstaq/compiler_output.py

```diff
@@ -1,128 +1,207 @@
+from __future__ import annotations
+
 import importlib
 import json
+import warnings
 from typing import Any, Dict, List, Optional, Set, Union
 
 import general_superstaq as gss
 import qiskit
 
 import qiskit_superstaq as qss
 
 try:
     import qtrl.sequence_utils.readout
 except ModuleNotFoundError:
     pass
 
 
 def active_qubit_indices(circuit: qiskit.QuantumCircuit) -> List[int]:
-    """Returns the indices of the non-idle qubits in a quantum circuit."""
+    """Returns the indices of the non-idle qubits in the input quantum circuit.
+
+    Args:
+        circuit: A `qiskit.QuantumCircuit` circuit.
+
+    Returns:
+        A list containing the indices of the non-idle qubits.
+    """
 
     qubit_indices: Set[int] = set()
 
     for inst, qubits, _ in circuit:
         if inst.name != "barrier":
             indices = [circuit.find_bit(q).index for q in qubits]
             qubit_indices.update(indices)
 
     return sorted(qubit_indices)
 
 
+def measured_qubit_indices(circuit: qiskit.QuantumCircuit) -> List[int]:
+    """Returns the indices of the measured qubits in the input quantum circuit.
+
+    Args:
+        circuit: A `qiskit.QuantumCircuit` circuit.
+
+    Returns:
+        A list containing the indices of the measured qubits.
+    """
+
+    measured_qubits: Set[qiskit.circuit.Qubit] = set()
+
+    for inst, qubits, clbits in circuit:
+        if isinstance(inst, qiskit.circuit.Measure):
+            measured_qubits.update(qubits)
+
+        # Recurse into definition if it involves classical bits
+        elif clbits and inst.definition is not None:
+            measured_qubits.update(qubits[i] for i in measured_qubit_indices(inst.definition))
+
+    return sorted(circuit.find_bit(qubit).index for qubit in measured_qubits)
+
+
 class CompilerOutput:
+    """A class that stores the results of compiled circuits."""
+
     def __init__(
         self,
         circuits: Union[
             qiskit.QuantumCircuit, List[qiskit.QuantumCircuit], List[List[qiskit.QuantumCircuit]]
         ],
+        final_logical_to_physicals: Union[
+            Dict[int, int], List[Dict[int, int]], List[List[Dict[int, int]]]
+        ],
         pulse_sequences: Union[qiskit.pulse.Schedule, List[qiskit.pulse.Schedule]] = None,
-        seq: Optional["qtrl.sequencer.Sequence"] = None,
+        seq: Optional[qtrl.sequencer.Sequence] = None,
         jaqal_programs: Optional[Union[str, List[str]]] = None,
         pulse_lists: Optional[Union[List[List[List[Any]]], List[List[List[List[Any]]]]]] = None,
     ) -> None:
+        """Constructs a `CompilerOutput` object.
+
+        Args:
+            circuits: Compiled circuit or list of compiled circuits.
+            final_logical_to_physics: Dictionary or list of dictionaries specifying mapping from
+                logical to physical qubits.
+            pulse_sequences: `qiskit.pulse.Schedule` or list thereof specifying the pulse
+                compilation.
+            seq: `qtrl.sequencer.Sequence` pulse sequence if qtrl is available locally.
+            jaqal_programs: Optional string or list of strings specifying Jaqal programs (for
+                QSCOUT).
+            pulse_lists: Optional list of pulse cycles if qtrl is available locally.
+        """
         if isinstance(circuits, qiskit.QuantumCircuit):
             self.circuit = circuits
+            self.final_logical_to_physical = final_logical_to_physicals
             self.pulse_sequence = pulse_sequences
             self.pulse_list = pulse_lists
             self.jaqal_program = jaqal_programs
         else:
             self.circuits = circuits
+            self.final_logical_to_physicals = final_logical_to_physicals
             self.pulse_sequences = pulse_sequences
             self.pulse_lists = pulse_lists
             self.jaqal_programs = jaqal_programs
 
         self.seq = seq
 
     def has_multiple_circuits(self) -> bool:
-        """Returns True if this object represents multiple circuits.
+        """Checks if this object represents multiple circuits.
 
         If so, this object has .circuits and .pulse_lists attributes. Otherwise, this object
         represents a single circuit, and has .circuit and .pulse_list attributes.
+
+        Returns:
+            A boolean indicating whether this object represents multiple circuits.
         """
         return hasattr(self, "circuits")
 
     def __repr__(self) -> str:
         if not self.has_multiple_circuits():
             return (
-                f"CompilerOutput({self.circuit!r}, {self.seq!r}, {self.jaqal_program!r}, "
+                f"CompilerOutput({self.circuit!r}, {self.final_logical_to_physical!r}, "
+                f"{self.pulse_sequence!r}, {self.seq!r}, {self.jaqal_program!r}, "
                 f"{self.pulse_list!r})"
             )
         return (
-            f"CompilerOutput({self.circuits!r}, {self.seq!r}, {self.jaqal_programs!r}, "
+            f"CompilerOutput({self.circuits!r}, {self.final_logical_to_physicals!r}, "
+            f"{self.pulse_sequences!r}, {self.seq!r}, {self.jaqal_programs!r}, "
             f"{self.pulse_lists!r})"
         )
 
     def __eq__(self, other: Any) -> bool:
         if not isinstance(other, CompilerOutput):
             return False
 
         if self.has_multiple_circuits() != other.has_multiple_circuits():
             return False
         elif self.has_multiple_circuits():
             return (
                 self.circuits == other.circuits
+                and self.final_logical_to_physicals == other.final_logical_to_physicals
                 and self.pulse_sequences == other.pulse_sequences
                 and self.jaqal_programs == other.jaqal_programs
                 and self.pulse_lists == other.pulse_lists
                 and self.seq == other.seq
             )
 
         return (
             self.circuit == other.circuit
+            and self.final_logical_to_physical == other.final_logical_to_physical
             and self.pulse_sequence == other.pulse_sequence
             and self.jaqal_program == other.jaqal_program
             and self.pulse_list == other.pulse_list
             and self.seq == other.seq
         )
 
 
 def read_json_aqt(
-    json_dict: Dict[str, str], circuits_is_list: bool, num_eca_circuits: int = 0
+    json_dict: Dict[str, str], circuits_is_list: bool, num_eca_circuits: Optional[int] = None
 ) -> CompilerOutput:
-    """Reads out returned JSON from SuperstaQ API's AQT compilation endpoint.
+    """Reads out the returned JSON from Superstaq API's AQT compilation endpoint.
 
     Args:
-        json_dict: a JSON dictionary matching the format returned by /aqt_compile endpoint
-        circuits_is_list: bool flag that controls whether the returned object has a .circuits
-            attribute (if True) or a .circuit attribute (False)
+        json_dict: A JSON dictionary matching the format returned by /aqt_compile endpoint.
+        circuits_is_list: Bool flag that controls whether the returned object has a .circuits
+            attribute (if True) or a .circuit attribute (False).
+        num_eca_circuits: Optional number of logically equivalent random circuits to generate for
+            each input circuit.
+
     Returns:
-        a CompilerOutput object with the compiled circuit(s). If qtrl is available locally,
+        A `CompilerOutput` object with the compiled circuit(s). If qtrl is available locally,
         the returned object also stores the pulse sequence in the .seq attribute and the
         list(s) of cycles in the .pulse_list(s) attribute.
     """
 
     compiled_circuits: Union[List[qiskit.QuantumCircuit], List[List[qiskit.QuantumCircuit]]]
     compiled_circuits = qss.serialization.deserialize_circuits(json_dict["qiskit_circuits"])
 
+    final_logical_to_physicals_list: List[Dict[int, int]] = list(
+        map(dict, json.loads(json_dict["final_logical_to_physicals"]))
+    )
+    final_logical_to_physicals: Union[
+        List[Dict[int, int]], List[List[Dict[int, int]]]
+    ] = final_logical_to_physicals_list
+
     seq = None
     pulse_lists = None
 
-    if importlib.util.find_spec(
-        "qtrl"
-    ):  # pragma: no cover, b/c qtrl is not open source so it is not in qiskit-superstaq reqs
+    if "state_jp" not in json_dict:
+        warnings.warn(
+            "This output only contains compiled circuits (using a default AQT gate set). To "
+            "get back the corresponding pulse sequence, you must first upload your qtrl configs "
+            "using `service.aqt_upload_configs`."
+        )
+    elif not importlib.util.find_spec("qtrl"):
+        warnings.warn(
+            "This output only contains compiled circuits. The qtrl package must be installed in "
+            "order to deserialize compiled pulse sequences."
+        )
+    else:  # pragma: no cover, b/c qtrl is not open source so it is not in cirq-superstaq reqs
 
-        def _sequencer_from_state(state: Dict[str, Any]) -> "qtrl.sequencer.Sequence":
+        def _sequencer_from_state(state: Dict[str, Any]) -> qtrl.sequencer.Sequence:
             seq = qtrl.sequencer.Sequence(n_elements=1)
             seq.__setstate__(state)
             seq.compile()
             return seq
 
         pulse_lists = gss.serialization.deserialize(json_dict["pulse_lists_jp"])
         state = gss.serialization.deserialize(json_dict["state_jp"])
@@ -137,64 +216,95 @@
                     readout_seq, readout_qubits, n_readouts=len(compiled_circuits)
                 )
 
             state["_readout"] = readout_seq
 
         seq = _sequencer_from_state(state)
 
-    if num_eca_circuits:
+    if num_eca_circuits is not None:
         compiled_circuits = [
             compiled_circuits[i : i + num_eca_circuits]
             for i in range(0, len(compiled_circuits), num_eca_circuits)
         ]
 
         pulse_lists = pulse_lists and [
             pulse_lists[i : i + num_eca_circuits]
             for i in range(0, len(pulse_lists), num_eca_circuits)
         ]
+        final_logical_to_physicals = [
+            final_logical_to_physicals_list[i : i + num_eca_circuits]
+            for i in range(0, len(final_logical_to_physicals_list), num_eca_circuits)
+        ]
 
     if circuits_is_list:
-        return CompilerOutput(circuits=compiled_circuits, seq=seq, pulse_lists=pulse_lists)
+        return CompilerOutput(
+            compiled_circuits, final_logical_to_physicals, seq=seq, pulse_lists=pulse_lists
+        )
 
     pulse_lists = pulse_lists[0] if pulse_lists is not None else None
-    return CompilerOutput(circuits=compiled_circuits[0], seq=seq, pulse_lists=pulse_lists)
+    return CompilerOutput(
+        compiled_circuits[0], final_logical_to_physicals[0], seq=seq, pulse_lists=pulse_lists
+    )
 
 
 def read_json_qscout(
-    json_dict: Dict[str, Union[str, List[str]]], circuits_is_list: bool
+    json_dict: Dict[str, Union[str, List[str]]],
+    circuits_is_list: bool,
 ) -> CompilerOutput:
-    """Reads out returned JSON from SuperstaQ API's QSCOUT compilation endpoint.
+    """Reads out the returned JSON from Superstaq API's QSCOUT compilation endpoint.
 
     Args:
-        json_dict: a JSON dictionary matching the format returned by /qscout_compile endpoint
-        circuits_is_list: bool flag that controls whether the returned object has a .circuits
-            attribute (if True) or a .circuit attribute (False)
+        json_dict: A JSON dictionary matching the format returned by /qscout_compile endpoint.
+        circuits_is_list: Bool flag that controls whether the returned object has a .circuits
+            attribute (if True) or a .circuit attribute (False).
+
     Returns:
-        a CompilerOutput object with the compiled circuit(s) and a list of
+        A `CompilerOutput` object with the compiled circuit(s) and a list of
         jaqal programs in a string representation.
     """
     qiskit_circuits = json_dict["qiskit_circuits"]
     jaqal_programs = json_dict["jaqal_programs"]
+
+    final_logical_to_physicals_str = json_dict["final_logical_to_physicals"]
+    assert isinstance(final_logical_to_physicals_str, str)
+    final_logical_to_physicals: List[Dict[int, int]] = list(
+        map(dict, json.loads(final_logical_to_physicals_str))
+    )
+
     assert isinstance(qiskit_circuits, str)
     assert isinstance(jaqal_programs, list)
     compiled_circuits = qss.serialization.deserialize_circuits(qiskit_circuits)
+
     if circuits_is_list:
-        return CompilerOutput(circuits=compiled_circuits, jaqal_programs=jaqal_programs)
+        return CompilerOutput(
+            circuits=compiled_circuits,
+            final_logical_to_physicals=final_logical_to_physicals,
+            jaqal_programs=jaqal_programs,
+        )
 
-    return CompilerOutput(circuits=compiled_circuits[0], jaqal_programs=jaqal_programs[0])
+    return CompilerOutput(
+        compiled_circuits[0],
+        final_logical_to_physicals[0],
+        jaqal_programs=jaqal_programs[0],
+    )
 
 
 def read_json_only_circuits(json_dict: Dict[str, str], circuits_is_list: bool) -> CompilerOutput:
-    """Reads JSON returned from SuperstaQ API's CQ compilation endpoint.
+    """Reads the JSON returned from Superstaq API's CQ compilation endpoint.
 
     Args:
-        json_dict: a JSON dictionary matching the format returned by /cq_compile endpoint
-        circuits_is_list: bool flag that controls whether the returned object has a .circuits
-            attribute (if True) or a .circuit attribute (False)
+        json_dict: A JSON dictionary matching the format returned by /cq_compile endpoint.
+        circuits_is_list: Bool flag that controls whether the returned object has a .circuits
+            attribute (if True) or a .circuit attribute (False).
+
     Returns:
-        a CompilerOutput object with the compiled circuit(s)
+        A `CompilerOutput` object with the compiled circuit(s).
     """
     compiled_circuits = qss.serialization.deserialize_circuits(json_dict["qiskit_circuits"])
-    if circuits_is_list:
-        return CompilerOutput(circuits=compiled_circuits)
 
-    return CompilerOutput(circuits=compiled_circuits[0])
+    final_logical_to_physicals: List[Dict[int, int]] = list(
+        map(dict, json.loads(json_dict["final_logical_to_physicals"]))
+    )
+
+    if circuits_is_list:
+        return CompilerOutput(compiled_circuits, final_logical_to_physicals)
+    return CompilerOutput(compiled_circuits[0], final_logical_to_physicals[0])
```

## qiskit_superstaq/compiler_output_test.py

```diff
@@ -1,8 +1,10 @@
+# pylint: disable=missing-function-docstring
 import importlib
+import json
 import pickle
 import textwrap
 from typing import Dict, List, Union
 from unittest import mock
 
 import general_superstaq as gss
 import pytest
@@ -19,70 +21,131 @@
     circuit.cz(3, 5)
     circuit.barrier(0, 1, 2, 3, 4, 5)
     circuit.h(circuit.qubits[1])
 
     assert qss.active_qubit_indices(circuit) == [1, 3, 5]
 
 
+def test_measured_qubit_indices() -> None:
+    circuit = qiskit.QuantumCircuit(8, 2)
+    circuit.x(0)
+    circuit.measure(1, 0)
+    circuit.cx(1, 2)
+    circuit.measure([6, 5], [0, 1])
+    circuit.measure([1, 3], [0, 1])  # (qubit 1 was already measured)
+    circuit.measure([5, 1], [0, 1])  # (both were already measured)
+    assert qss.measured_qubit_indices(circuit) == [1, 3, 5, 6]
+
+    # Check that measurements in custom gates/subcircuits are handled correctly
+    circuit = qiskit.QuantumCircuit(6, 2)
+    circuit.measure(0, 0)
+    assert qss.measured_qubit_indices(circuit) == [0]
+
+    subcircuit = qiskit.QuantumCircuit(6, 2)
+    subcircuit.x(0)
+    subcircuit.measure(1, 0)
+    subcircuit.measure(2, 1)
+    assert qss.measured_qubit_indices(subcircuit) == [1, 2]
+
+    # Append subcircuit to itself (measurements should land on qubits 2 and 4)
+    subcircuit.append(subcircuit, [3, 2, 4, 0, 1, 5], [1, 0])
+    assert qss.measured_qubit_indices(subcircuit) == [1, 2, 4]
+
+    # Append subcircuit to circuit (measurements should land on qubits 4, 3, and 1 of circuit)
+    circuit.append(subcircuit, [5, 4, 3, 2, 1, 0], [0, 1])
+    assert qss.measured_qubit_indices(circuit) == [0, 1, 3, 4]
+
+
 def test_compiler_output_repr() -> None:
     circuit = qiskit.QuantumCircuit(4)
     assert (
-        repr(qss.compiler_output.CompilerOutput(circuit))
-        == f"""CompilerOutput({circuit!r}, None, None, None)"""
+        repr(qss.compiler_output.CompilerOutput(circuit, {0: 1}))
+        == f"""CompilerOutput({circuit!r}, {{0: 1}}, None, None, None, None)"""
     )
 
     circuits = [circuit, circuit]
     assert (
-        repr(qss.compiler_output.CompilerOutput(circuits))
-        == f"CompilerOutput({circuits!r}, None, None, None)"
+        repr(qss.compiler_output.CompilerOutput(circuits, [{0: 1}, {1: 0}]))
+        == f"CompilerOutput({circuits!r}, [{{0: 1}}, {{1: 0}}], None, None, None, None)"
     )
 
 
+def test_read_json_only_circuits() -> None:
+    qc = qiskit.QuantumCircuit(2)
+    qc.h(0)
+    qc.cx(0, 1)
+
+    json_dict = {
+        "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": "[[]]",
+    }
+
+    out = qss.compiler_output.read_json_only_circuits(json_dict, circuits_is_list=False)
+    assert out.circuit == qc
+
+    json_dict = {
+        "qiskit_circuits": qss.serialization.serialize_circuits([qc, qc]),
+        "final_logical_to_physicals": "[[], []]",
+    }
+    out = qss.compiler_output.read_json_only_circuits(json_dict, circuits_is_list=True)
+    assert out.circuits == [qc, qc]
+
+
 @mock.patch.dict("sys.modules", {"qtrl": None})
-def test_read_json() -> None:
+def test_read_json_aqt() -> None:
     importlib.reload(qss.compiler_output)
 
     circuit = qiskit.QuantumCircuit(4)
     for i in range(4):
         circuit.h(i)
+
     state_str = gss.serialization.serialize({})
     pulse_lists_str = gss.serialization.serialize([[[]]])
 
     json_dict = {
         "qiskit_circuits": qss.serialization.serialize_circuits(circuit),
+        "final_logical_to_physicals": "[[]]",
         "state_jp": state_str,
         "pulse_lists_jp": pulse_lists_str,
     }
 
-    out = qss.compiler_output.read_json_aqt(json_dict, circuits_is_list=False)
+    with pytest.warns(UserWarning, match="deserialize compiled pulse sequences"):
+        out = qss.compiler_output.read_json_aqt(json_dict, circuits_is_list=False)
+
     assert out.circuit == circuit
     assert not hasattr(out, "circuits")
 
-    out = qss.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
+    with pytest.warns(UserWarning, match="deserialize compiled pulse sequences"):
+        out = qss.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
+
     assert out.circuits == [circuit]
     assert not hasattr(out, "circuit")
 
+    # multiple circuits
     pulse_lists_str = gss.serialization.serialize([[[]], [[]]])
     json_dict = {
         "qiskit_circuits": qss.serialization.serialize_circuits([circuit, circuit]),
+        "final_logical_to_physicals": "[[], []]",
         "state_jp": state_str,
         "pulse_lists_jp": pulse_lists_str,
     }
-    out = qss.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
+
+    with pytest.warns(UserWarning, match="deserialize compiled pulse sequences"):
+        out = qss.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
+
     assert out.circuits == [circuit, circuit]
     assert not hasattr(out, "circuit")
 
-    json_dict = {"qiskit_circuits": qss.serialization.serialize_circuits(circuit)}
+    # no sequence returned
+    json_dict.pop("state_jp")
 
-    out = qss.compiler_output.read_json_only_circuits(json_dict, circuits_is_list=False)
-    assert out.circuit == circuit
+    with pytest.warns(UserWarning, match="aqt_upload_configs"):
+        out = qss.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
 
-    json_dict = {"qiskit_circuits": qss.serialization.serialize_circuits([circuit, circuit])}
-    out = qss.compiler_output.read_json_only_circuits(json_dict, circuits_is_list=True)
-    assert out.circuits == [circuit, circuit]
+    assert out.seq is None
 
 
 def test_read_json_with_qtrl() -> None:  # pragma: no cover, b/c test requires qtrl installation
     qtrl = pytest.importorskip("qtrl", reason="qtrl not installed")
     seq = qtrl.sequencer.Sequence(n_elements=1)
 
     circuit = qiskit.QuantumCircuit(4)
@@ -90,14 +153,15 @@
         circuit.h(i)
     circuit.measure_all()
 
     state_str = gss.serialization.serialize(seq.__getstate__())
     pulse_lists_str = gss.serialization.serialize([[[]]])
     json_dict = {
         "qiskit_circuits": qss.serialization.serialize_circuits(circuit),
+        "final_logical_to_physicals": "[[]]",
         "state_jp": state_str,
         "pulse_lists_jp": pulse_lists_str,
     }
 
     out = qss.compiler_output.read_json_aqt(json_dict, circuits_is_list=False)
     assert out.circuit == circuit
     assert isinstance(out.seq, qtrl.sequencer.Sequence)
@@ -120,21 +184,23 @@
     assert out.seq._readout._readout.n_readouts == 1
     assert pickle.dumps(out.seq._readout) == pickle.dumps(out.seq) == pickle.dumps(seq)
     assert not hasattr(out, "circuits") and not hasattr(out, "pulse_lists")
 
     # Multiple circuits:
     out = qss.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
     assert out.circuits == [circuit]
+
     assert pickle.dumps(out.seq) == pickle.dumps(seq)
     assert out.pulse_lists == [[[]]]
     assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
 
     pulse_lists_str = gss.serialization.serialize([[[]], [[]]])
     json_dict = {
         "qiskit_circuits": qss.serialization.serialize_circuits([circuit, circuit]),
+        "final_logical_to_physicals": "[[], []]",
         "state_jp": state_str,
         "pulse_lists_jp": pulse_lists_str,
         "readout_jp": state_str,
         "readout_qubits": "[4, 5, 6, 7]",
     }
     out = qss.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
     assert out.circuits == [circuit, circuit]
@@ -145,50 +211,54 @@
     assert isinstance(out.seq._readout._readout, qtrl.sequence_utils.readout._ReadoutInfo)
     assert out.seq._readout._readout.sequence is out.seq._readout
     assert out.seq._readout._readout.qubits == [4, 5, 6, 7]
     assert out.seq._readout._readout.n_readouts == 2
     assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
 
 
-def test_read_json_with_qscout() -> None:
+def test_read_json_qscout() -> None:
     circuit = qiskit.QuantumCircuit(1)
     circuit.h(0)
 
     jaqal_program = textwrap.dedent(
         """\
-                register allqubits[1]
+        register allqubits[1]
 
-                prepare_all
-                R allqubits[0] -1.5707963267948966 1.5707963267948966
-                Rz allqubits[0] -3.141592653589793
-                measure_all
-                """
+        prepare_all
+        R allqubits[0] -1.5707963267948966 1.5707963267948966
+        Rz allqubits[0] -3.141592653589793
+        measure_all
+        """
     )
 
     json_dict: Dict[str, Union[str, List[str]]] = {
         "qiskit_circuits": qss.serialization.serialize_circuits(circuit),
+        "final_logical_to_physicals": json.dumps([[(0, 13)]]),
         "jaqal_programs": [jaqal_program],
     }
 
     out = qss.compiler_output.read_json_qscout(json_dict, circuits_is_list=False)
     assert out.circuit == circuit
+    assert out.final_logical_to_physical == {0: 13}
     assert out.jaqal_program == jaqal_program
 
     json_dict = {
         "qiskit_circuits": qss.serialization.serialize_circuits([circuit, circuit]),
+        "final_logical_to_physicals": json.dumps([[(0, 13)], [(0, 13)]]),
         "jaqal_programs": [jaqal_program, jaqal_program],
     }
     out = qss.compiler_output.read_json_qscout(json_dict, circuits_is_list=True)
     assert out.circuits == [circuit, circuit]
+    assert out.final_logical_to_physicals == [{0: 13}, {0: 13}]
     assert out.jaqal_programs == json_dict["jaqal_programs"]
 
 
 def test_compiler_output_eq() -> None:
     circuit = qiskit.QuantumCircuit(1)
     circuit.h(0)
-    co = qss.compiler_output.CompilerOutput(circuit)
+    co = qss.compiler_output.CompilerOutput(circuit, {5: 0})
     assert co != 1
 
     circuit1 = qiskit.QuantumCircuit(1)
     circuit1.h(0)
 
-    assert qss.compiler_output.CompilerOutput([circuit, circuit1]) != co
+    assert qss.compiler_output.CompilerOutput([circuit, circuit1], [{5: 0}, {4: 0}]) != co
```

## qiskit_superstaq/custom_gates.py

```diff
@@ -5,89 +5,94 @@
 import numpy.typing as npt
 import qiskit
 
 
 class AceCR(qiskit.circuit.Gate):
     """Active Cancellation Echoed Cross Resonance gate, supporting polarity switches and sandwiches.
 
-    The typical AceCR in literature is a positive half-CR, then X on "Z side", then negative
-    half-CR ("Z side" and "X side" refer to the two sides of the underlying ZX interactions).
-
-    Args:
-        polarity: Should be either "+-" or "-+". Specifies if positive or negative half-CR is first
-        sandwich_rx_rads: Angle of rotation for an rx gate applied to the "X side" simultaneously
-            with the X gate on the "Z side".
-        label: An optional label for the constructed Gate
+    The typical AceCR in the literature is a positive half-CR, then X on "Z side", then negative
+    half-CR (where "Z side" and "X side" refer to the two sides of the underlying ZX interactions).
     """
 
     def __init__(
-        self, polarity: str, sandwich_rx_rads: float = 0, label: Optional[str] = None
+        self,
+        rads: Union[str, float] = np.pi / 2,
+        sandwich_rx_rads: float = 0,
+        label: Optional[str] = None,
     ) -> None:
-        if polarity not in ("+-", "-+"):
-            raise ValueError("Polarity must be either '+-' or '-+'")
+        """Initializes an AceCR gate.
+
+        Args:
+            rads: Angle of rotation for CR gate (i.e., twice the angle for each echoed half-CR).
+            sandwich_rx_rads: Angle of rotation for an rx gate applied to the "X side"
+                simultaneously with the X gate on the "Z side".
+            label: An optional label for the constructed gate. Defaults to None.
 
-        name = "acecr_" + polarity.replace("+", "p").replace("-", "m")
+        Raises:
+            ValueError: If the polarity of `rads` is not '+-' or '-+'.
+        """
+        if rads == "+-":
+            rads = np.pi / 2
+        elif rads == "-+":
+            rads = -np.pi / 2
+        elif isinstance(rads, str):
+            raise ValueError("Polarity must be either '+-' or '-+'")
 
+        name = "acecr"
+        params = [rads]
         if sandwich_rx_rads:
-            super().__init__(name + "_rx", 2, [sandwich_rx_rads], label=label)
-        else:
-            super().__init__(name, 2, [], label=label)
+            name += "_rx"
+            params.append(sandwich_rx_rads)
+        super().__init__(name, 2, params, label=label)
 
-        self.polarity = polarity
+        self.rads = rads
         self.sandwich_rx_rads = sandwich_rx_rads
 
     def inverse(self) -> "AceCR":
-        return AceCR(self.polarity, sandwich_rx_rads=-self.sandwich_rx_rads, label=self.label)
+        """Returns the inverse AceCR gate."""
+        return AceCR(self.rads, -self.sandwich_rx_rads, label=self.label)
 
     def _define(self) -> None:
+        """Stores the qiskit circuit definition of the AceCR gate."""
         qc = qiskit.QuantumCircuit(2, name=self.name)
-        first_sign = +1 if self.polarity == "+-" else -1
-        qc.rzx(first_sign * np.pi / 4, 0, 1)
+        qc.rzx(self.rads / 2, 0, 1)
         qc.x(0)
         if self.sandwich_rx_rads:
             qc.rx(self.sandwich_rx_rads, 1)
-        qc.rzx(-first_sign * np.pi / 4, 0, 1)
+        qc.rzx(-self.rads / 2, 0, 1)
         self.definition = qc
 
     def __array__(self, dtype: Optional[type] = None) -> npt.NDArray[np.bool_]:
-        cval = 1 / np.sqrt(2)
-        if self.polarity == "+-":
-            sval = 1j * cval
-        else:
-            sval = -1j * cval
-
-        mat = np.array(
-            [
-                [0, cval, 0, sval],
-                [cval, 0, -sval, 0],
-                [0, sval, 0, cval],
-                [-sval, 0, cval, 0],
-            ],
-            dtype=dtype,
-        )
-
-        # sandwiched rx gate commutes and can just be multiplied with non-sandwiched part:
-        return mat @ np.kron(
-            np.asarray(qiskit.circuit.library.RXGate(self.sandwich_rx_rads), dtype=dtype),
-            np.eye(2, dtype=dtype),
-        )
+        """Returns an array for the AceCR gate."""
+        return qiskit.quantum_info.Operator(self.definition).data
 
     def __repr__(self) -> str:
-        args = f"'{self.polarity}'"
-        if self.sandwich_rx_rads:
-            args += f", sandwich_rx_rads={self.sandwich_rx_rads}"
+        args = []
+        if self.rads != np.pi / 2:
+            args.append(f"rads={self.rads!r}")
+        if self.sandwich_rx_rads != 0:
+            args.append(f"sandwich_rx_rads={self.sandwich_rx_rads!r}")
         if self.label:
-            args += f", label='{self.label}'"
-        return f"qss.AceCR({args})"
+            args.append(f"label={self.label!r}")
+        return f"qss.AceCR({', '.join(args)})"
 
     def __str__(self) -> str:
-        if not self.sandwich_rx_rads:
-            return f"AceCR{self.polarity}"
-        arg = qiskit.circuit.tools.pi_check(self.sandwich_rx_rads, ndigits=8, output="qasm")
-        return f"AceCR{self.polarity}|RXGate({arg})|"
+        rads_str = f"{self.rads}"
+        if np.isclose(round(self.rads / np.pi, 5) * np.pi, self.rads):
+            rads_str = f"{round(self.rads / np.pi, 5)}π"
+        if self.sandwich_rx_rads == 0 and self.rads == np.pi / 2:
+            return "AceCR"
+        elif self.sandwich_rx_rads != 0 and self.rads not in [0, np.pi / 2]:
+            arg = qiskit.circuit.tools.pi_check(self.sandwich_rx_rads, ndigits=8, output="qasm")
+            return f"AceCR({rads_str})|RXGate({arg})|"
+        elif self.sandwich_rx_rads != 0:
+            arg = qiskit.circuit.tools.pi_check(self.sandwich_rx_rads, ndigits=8, output="qasm")
+            return f"AceCR|RXGate({arg})|"
+        else:
+            return f"AceCR({rads_str})"
 
 
 class ZZSwapGate(qiskit.circuit.Gate):
     r"""The ZZ-SWAP gate, which performs the ZZ-interaction followed by a SWAP.
 
     ZZ-SWAPs are useful for applications like QAOA or Hamiltonian Simulation,
     particularly on linear- or low- connectivity devices. See https://arxiv.org/pdf/2004.14970.pdf
@@ -105,33 +110,37 @@
         \end{bmatrix}
 
     where '.' means '0'.
     For :math:`\theta = 0`, the ZZ-SWAP gate is just an ordinary SWAP.
     """
 
     def __init__(self, theta: float, label: Optional[str] = None) -> None:
-        """
+        """Initalizes a ZZ-SWAP gate.
+
         Args:
-            theta: ZZ-interaction angle in radians
-            label: an optional label for the constructed Gate
+            theta: The ZZ-interaction angle in radians.
+            label: An optional label for the constructed gate. Defaults to None.
         """
         super().__init__("zzswap", 2, [theta], label=label)
 
     def inverse(self) -> "ZZSwapGate":
+        """Returns the inverse ZZ-SWAP gate."""
         return ZZSwapGate(-self.params[0])
 
     def _define(self) -> None:
+        """Stores the qiskit circuit definition of the ZZ-SWAP gate."""
         qc = qiskit.QuantumCircuit(2, name="zzswap")
         qc.cx(0, 1)
         qc.cx(1, 0)
         qc.p(self.params[0], 1)
         qc.cx(0, 1)
         self.definition = qc
 
     def __array__(self, dtype: Optional[type] = None) -> npt.NDArray[np.bool_]:
+        """Returns a numpy array for the ZZ-SWAP gate."""
         return np.array(
             [
                 [1, 0, 0, 0],
                 [0, 0, np.exp(1j * self.params[0]), 0],
                 [0, np.exp(1j * self.params[0]), 0, 0],
                 [0, 0, 0, 1],
             ],
@@ -145,22 +154,72 @@
         return f"qss.ZZSwapGate({args})"
 
     def __str__(self) -> str:
         args = qiskit.circuit.tools.pi_check(self.params[0], ndigits=8, output="qasm")
         return f"ZZSwapGate({args})"
 
 
+class StrippedCZGate(qiskit.circuit.Gate):
+    """The Stripped CZ gate is the gate that is actually being performed by Hilbert,
+    which is just a regular CZ gate when the rz angle = 0, and is corrected into a CZ
+    gate by RZ gates afterwards if the rz angle is nonzero.
+    """
+
+    def __init__(self, rz_rads: float) -> None:
+        """Initializes a Stripped CZ gate.
+
+        Args:
+            rz_rads: The RZ-rotation angle in radians.
+        """
+        super().__init__("stripped_cz", 2, [rz_rads])
+
+    def inverse(self) -> "StrippedCZGate":
+        """Returns the inverse Stripped CZ gate."""
+        return StrippedCZGate(-self.params[0])
+
+    def _define(self) -> None:
+        """Stores the qiskit circuit definition of the Stripped CZ gate."""
+        qc = qiskit.QuantumCircuit(2, name="stripped_cz")
+        qc.p(self.params[0], 0)
+        qc.p(self.params[0], 1)
+        qc.cz(0, 1)
+        self.definition = qc
+
+    def __array__(self, dtype: Optional[type] = None) -> npt.NDArray[np.complex_]:
+        """Returns a numpy array of the Stripped CZ gate."""
+        return np.array(
+            [
+                [1, 0, 0, 0],
+                [0, np.exp(1j * self.params[0]), 0, 0],
+                [0, 0, np.exp(1j * self.params[0]), 0],
+                [0, 0, 0, np.exp(1j * (2 * self.params[0] - np.pi))],
+            ],
+            dtype=dtype,
+        )
+
+    def __repr__(self) -> str:
+        return f"qss.StrippedCZGate({self.params[0]!r})"
+
+    def __str__(self) -> str:
+        args = qiskit.circuit.tools.pi_check(self.params[0], ndigits=8, output="qasm")
+        return f"StrippedCZGate({args})"
+
+
 class ParallelGates(qiskit.circuit.Gate):
-    """A single Gate combining a collection of concurrent Gate(s) acting on different qubits"""
+    """A single gate combining a collection of concurrent gate(s) acting on different qubits."""
 
     def __init__(self, *component_gates: qiskit.circuit.Gate, label: Optional[str] = None) -> None:
-        """
+        """Initializes the `ParallelGates` class.
+
         Args:
-            component_gates: Gate(s) to be collected into single gate
-            label: an optional label for the constructed Gate
+            component_gates: Gate(s) to be collected into a single gate.
+            label: An optional label for the constructed gate. Defaults to None.
+
+        Raises:
+            ValueError: If `component_gates` are not `qiskit.circuit.Gate` instances.
         """
         self.component_gates: Tuple[qiskit.circuit.Gate, ...] = ()
         num_qubits = 0
 
         for gate in component_gates:
             num_qubits += gate.num_qubits
 
@@ -171,169 +230,258 @@
             else:
                 self.component_gates += (gate,)
 
         name = "parallel_" + "_".join(gate.name for gate in self.component_gates)
         super().__init__(name, num_qubits, [], label=label)
 
     def inverse(self) -> "ParallelGates":
+        """Returns the inverse gates."""
         return ParallelGates(*[gate.inverse() for gate in self.component_gates])
 
     def _define(self) -> None:
+        """Stores the qiskit circuit definition of `ParallelGates`."""
         qc = qiskit.QuantumCircuit(self.num_qubits, name="parallel_gates")
         qubits = list(range(self.num_qubits))
         for gate in self.component_gates:
             num_qubits = gate.num_qubits
             qc.append(gate, qubits[:num_qubits])
             qubits = qubits[num_qubits:]
         self.definition = qc
 
     def __array__(self, dtype: Optional[type] = None) -> npt.NDArray[np.bool_]:
+        """Returns a numpy array for `ParallelGates`."""
         mat = functools.reduce(np.kron, (gate.to_matrix() for gate in self.component_gates[::-1]))
         return np.asarray(mat, dtype=dtype)
 
     def __str__(self) -> str:
         args = ", ".join(gate.qasm() for gate in self.component_gates)
         return f"ParallelGates({args})"
 
 
 class iXGate(qiskit.circuit.Gate):
+    r"""The iX gate (a single qubit Pauli-X gate with a global phase of i). It is a special case
+    of when the RZ gate's input rotation angle is :math:`-\pi`:
+
+     .. math::
+
+        \begin{bmatrix}
+        0 & i \\
+        i & 0 \\
+        \end{bmatrix}
+    """
+
     def __init__(self, label: Optional[str] = None) -> None:
+        """Initializes an iXGate.
+
+        Args:
+            label: An optional label for the constructed gate. Defaults to None.
+        """
         super().__init__("ix", 1, [], label=label)
 
     def _define(self) -> None:
+        """Stores the qiskit circuit definition of the iX gate."""
         qc = qiskit.QuantumCircuit(1, name=self.name)
         qc.rx(-np.pi, 0)
         self.definition = qc
 
     def __array__(self, dtype: Optional[type] = None) -> npt.NDArray[np.bool_]:
+        """Returns a numpy array of the iX gate."""
         return np.array([[0, 1j], [1j, 0]])
 
     def inverse(self) -> "iXdgGate":
+        """Returns the inverse iX gate."""
         return iXdgGate()
 
     def control(
         self,
         num_ctrl_qubits: int = 1,
         label: Optional[str] = None,
         ctrl_state: Optional[Union[str, int]] = None,
     ) -> qiskit.circuit.ControlledGate:
+        """Method to return a controlled version of the gate.
+
+        Args:
+            num_ctrl_qubits: Number of control qubits for the gate. Defaults to 1.
+            label: An optional label for the gate. Defaults to None.
+            ctrl_state: The control qubit state to use (e.g. '00'). Defaults to None.
+
+        Returns:
+            The `qiskit.circuit.ControlledGate` version of the gate.
+        """
         if num_ctrl_qubits == 2:
             gate = iCCXGate(ctrl_state=ctrl_state)
             gate.base_gate.label = self.label
             return gate
         return super().control(num_ctrl_qubits, label, ctrl_state)
 
     def __repr__(self) -> str:
         return f"qss.custom_gates.{str(self)}"
 
     def __str__(self) -> str:
         return f"iXGate(label={self.label})"
 
 
 class iXdgGate(qiskit.circuit.Gate):
+    r"""The conjugate transpose of the `iXGate` (:math:`iXGate^{\dagger} = iXdgGate`)."""
+
     def __init__(self, label: Optional[str] = None) -> None:
+        """Initializes an iXdgGate.
+
+        Args:
+            label: An optional label for the constructed gate. Defaults to None.
+        """
         super().__init__("ixdg", 1, [], label=label)
 
     def _define(self) -> None:
+        """Stores the qiskit circuit definition of the inverse iX gate."""
         qc = qiskit.QuantumCircuit(1, name=self.name)
         qc.rx(np.pi, 0)
         self.definition = qc
 
     def __array__(self, dtype: Optional[type] = None) -> npt.NDArray[np.complex_]:
+        """Returns a numpy array of the inverse iX gate."""
         return np.array([[0, -1j], [-1j, 0]])
 
     def inverse(self) -> iXGate:
+        """Returns the inverse of the `iXdgGate`."""
         return iXGate()
 
     def control(
         self,
         num_ctrl_qubits: int = 1,
         label: Optional[str] = None,
         ctrl_state: Optional[Union[str, int]] = None,
     ) -> qiskit.circuit.ControlledGate:
+        """Method to return a controlled version of the gate.
+
+        Args:
+            num_ctrl_qubits: Number of control qubits for the gate. Defaults to 1.
+            label: An optional label for the gate. Defaults to None.
+            ctrl_state: The control qubit state to use (e.g. '00'). Defaults to None.
+
+        Returns:
+            The `qiskit.circuit.ControlledGate` version of the gate.
+        """
         if num_ctrl_qubits == 2:
             gate = iCCXdgGate(ctrl_state=ctrl_state)
             gate.base_gate.label = self.label
             return gate
         return super().control(num_ctrl_qubits, label, ctrl_state)
 
     def __repr__(self) -> str:
         return f"qss.custom_gates.{str(self)}"
 
     def __str__(self) -> str:
         return f"iXdgGate(label={self.label})"
 
 
 class iCCXGate(qiskit.circuit.ControlledGate):
+    r"""An iCCX gate which consists of a Toffoli gate and subsequent two-qubit controlled phase gate
+    (with angle of rotation of :math:`\frac{\pi}{2}` on the second qubit using the first qubit as
+    control). That is, it is a composite gate of the following instructions:
+
+    .. parsed-literal::
+
+        q_0: ──■───■───────
+               │   │P(π/2)
+        q_1: ──■───■───────
+             ┌─┴─┐
+        q_2: ┤ X ├─────────
+             └───┘
+    """
+
     def __init__(
         self, label: Optional[str] = None, ctrl_state: Optional[Union[str, int]] = None
     ) -> None:
+        """Initializes an iCCXGate.
+
+        Args:
+            label: An optional label for the constructed gate. Defaults to None.
+            ctrl_state: The control qubit state to use (e.g. '00'). Defaults to None.
+        """
         super().__init__(
             "iccx", 3, [], label, num_ctrl_qubits=2, ctrl_state=ctrl_state, base_gate=iXGate()
         )
 
     def _define(self) -> None:
+        """Stores the qiskit circuit definition of iCCX gate."""
         qc = qiskit.QuantumCircuit(3, name=self.name)
         qc.ccx(0, 1, 2)
         qc.cp(np.pi / 2, 0, 1)
         self.definition = qc
 
     def __array__(self, dtype: Optional[type] = None) -> npt.NDArray[np.complex_]:
+        """Returns a numpy array of the iCCX gate."""
         mat = qiskit.circuit._utils._compute_control_matrix(
             self.base_gate.to_matrix(), self.num_ctrl_qubits, ctrl_state=self.ctrl_state
         )
         return np.asarray(mat, dtype=dtype)
 
     def __repr__(self) -> str:
         return f"qss.custom_gates.{str(self)}"
 
     def __str__(self) -> str:
         return f"iCCXGate(label={self.label}, ctrl_state={self.ctrl_state})"
 
 
 class iCCXdgGate(qiskit.circuit.ControlledGate):
+    r"""The conjugate transpose of the `iCCXGate` (:math:`iCCXGate^{\dagger} = iCCXdgGate`)."""
+
     def __init__(
         self, label: Optional[str] = None, ctrl_state: Optional[Union[str, int]] = None
     ) -> None:
+        """Initializes an iCCXdgGate.
+
+        Args:
+            label: An optional label for the constructed gate. Defaults to None.
+            ctrl_state: The control qubit state to use (e.g. '00'). Defaults to None.
+        """
         super().__init__(
             "iccxdg", 3, [], label, num_ctrl_qubits=2, ctrl_state=ctrl_state, base_gate=iXdgGate()
         )
 
     def _define(self) -> None:
+        """Stores the qiskit circuit definition of the iCCX gate conjugate transpose."""
         qc = qiskit.QuantumCircuit(3, name=self.name)
         qc.ccx(0, 1, 2).inverse()
         qc.cp(-np.pi / 2, 0, 1)
         self.definition = qc
 
     def __array__(self, dtype: Optional[type] = None) -> npt.NDArray[np.complex_]:
+        """Returns a numpy array of the `iCCXdgGate`."""
         mat = qiskit.circuit._utils._compute_control_matrix(
             self.base_gate.to_matrix(), self.num_ctrl_qubits, ctrl_state=self.ctrl_state
         )
         return np.asarray(mat, dtype=dtype)
 
     def __repr__(self) -> str:
         return f"qss.custom_gates.{str(self)}"
 
     def __str__(self) -> str:
         return f"iCCXdgGate(label={self.label}, ctrl_state={self.ctrl_state})"
 
 
 class AQTiCCXGate(iCCXGate):
+    """A subclass of the iCCXGate for AQT where the control state is "00"."""
+
     def __init__(self, label: Optional[str] = None) -> None:
+        """Initializes an AQTiCCXGate.
+
+        Args:
+            label: An optional label for the constructed gate. Defaults to None.
+        """
         super().__init__(label=label, ctrl_state="00")
 
 
 AQTiToffoliGate = AQTiCCXGate
 
 
 _custom_gate_resolvers: Dict[str, Callable[..., qiskit.circuit.Gate]] = {
-    "acecr_pm": lambda: AceCR("+-"),
-    "acecr_mp": lambda: AceCR("-+"),
-    "acecr_pm_rx": lambda rads: AceCR("+-", rads),
-    "acecr_mp_rx": lambda rads: AceCR("-+", rads),
+    "acecr": lambda rads: AceCR(rads=rads),
+    "acecr_rx": lambda *rads: AceCR(*rads),
     "zzswap": ZZSwapGate,
     "ix": iXGate,
     "ixdg": iXdgGate,
     "iccx": iCCXGate,
     "iccx_o0": AQTiCCXGate,
     "iccx_o1": lambda: iCCXGate(ctrl_state="01"),
     "iccx_o2": lambda: iCCXGate(ctrl_state="10"),
@@ -341,17 +489,24 @@
     "iccxdg_o0": lambda: iCCXdgGate(ctrl_state="00"),
     "iccxdg_o1": lambda: iCCXdgGate(ctrl_state="01"),
     "iccxdg_o2": lambda: iCCXdgGate(ctrl_state="10"),
 }
 
 
 def custom_resolver(gate: qiskit.circuit.Instruction) -> Optional[qiskit.circuit.Gate]:
-    """Recover a custom gate type from a generic qiskit.circuit.Gate. Resolution is done using
-    gate.definition.name rather than gate.name, as the former is set by all qiskit-superstaq
+    """Recover a custom gate type from a generic `qiskit.circuit.Gate`. Resolution is done using
+    `gate.definition.name` rather than `gate.name`, as the former is set by all qiskit-superstaq
     custom gates and the latter may be modified by calls such as QuantumCircuit.qasm()
+
+    Args:
+        gate: The input gate instruction from which to recover a custom gate type.
+
+    Returns:
+        A `qiskit.circuit.Gate` if the gate definition name is in the `_custom_gate_resolver`
+        dictionary (or the definition name is "parallel_gates").
     """
 
     if gate.definition and gate.definition.name == "parallel_gates":
         component_gates = [custom_resolver(inst) or inst for inst, _, _ in gate.definition]
         return ParallelGates(*component_gates, label=gate.label)
 
     if gate.definition and gate.definition.name in _custom_gate_resolvers:
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## qiskit_superstaq/custom_gates_test.py

```diff
@@ -1,7 +1,8 @@
+# pylint: disable=missing-function-docstring
 from typing import List, Set
 
 import numpy as np
 import pytest
 import qiskit
 
 import qiskit_superstaq as qss
@@ -20,58 +21,89 @@
 
     assert inverse_operation.equiv(gate.inverse().to_matrix(), atol=1e-10)
     assert inverse_operation.equiv(gate.to_matrix().T.conj(), atol=1e-10)
 
 
 def test_acecr() -> None:
     gate = qss.AceCR("+-")
-    _check_gate_definition(gate)
-    assert repr(gate) == "qss.AceCR('+-')"
-    assert str(gate) == "AceCR+-"
-    assert gate.qasm() == "acecr_pm"
+    assert repr(gate) == "qss.AceCR()"
+    assert str(gate) == "AceCR"
+    assert gate.qasm() == "acecr(pi/2)"
 
     gate = qss.AceCR("-+", label="label")
-    _check_gate_definition(gate)
-    assert repr(gate) == "qss.AceCR('-+', label='label')"
-    assert str(gate) == "AceCR-+"
-    assert gate.qasm() == "acecr_mp"
+    assert repr(gate) == "qss.AceCR(rads=-1.5707963267948966, label='label')"
+    assert str(gate) == "AceCR(-0.5π)"
+    assert gate.qasm() == "acecr(-pi/2)"
 
     gate = qss.AceCR("-+", sandwich_rx_rads=np.pi / 2)
-    _check_gate_definition(gate)
-    assert repr(gate) == "qss.AceCR('-+', sandwich_rx_rads=1.5707963267948966)"
-    assert str(gate) == "AceCR-+|RXGate(pi/2)|"
-    assert gate.qasm() == "acecr_mp_rx(pi/2)"
+    assert repr(gate) == "qss.AceCR(rads=-1.5707963267948966, sandwich_rx_rads=1.5707963267948966)"
+    assert str(gate) == "AceCR(-0.5π)|RXGate(pi/2)|"
+    assert gate.qasm() == "acecr_rx(-pi/2,pi/2)"
 
     gate = qss.AceCR("-+", sandwich_rx_rads=np.pi / 2, label="label")
     _check_gate_definition(gate)
-    assert repr(gate) == "qss.AceCR('-+', sandwich_rx_rads=1.5707963267948966, label='label')"
-    assert str(gate) == "AceCR-+|RXGate(pi/2)|"
-    assert gate.qasm() == "acecr_mp_rx(pi/2)"
+    assert (
+        repr(gate)
+        == "qss.AceCR(rads=-1.5707963267948966, sandwich_rx_rads=1.5707963267948966, label='label')"
+    )
+    assert str(gate) == "AceCR(-0.5π)|RXGate(pi/2)|"
+    assert gate.qasm() == "acecr_rx(-pi/2,pi/2)"
 
     with pytest.raises(ValueError, match="Polarity must be"):
         _ = qss.AceCR("++")
 
+    gate = qss.AceCR(np.pi)
+    assert repr(gate) == "qss.AceCR(rads=3.141592653589793)"
+    assert str(gate) == "AceCR(1.0π)"
+
+    gate = qss.AceCR(sandwich_rx_rads=np.pi / 2)
+    assert repr(gate) == "qss.AceCR(sandwich_rx_rads=1.5707963267948966)"
+    assert str(gate) == "AceCR|RXGate(pi/2)|"
+
+    gate = qss.AceCR(rads=np.pi / 5, sandwich_rx_rads=np.pi / 2)
+    assert repr(gate) == "qss.AceCR(rads=0.6283185307179586, sandwich_rx_rads=1.5707963267948966)"
+    assert str(gate) == "AceCR(0.2π)|RXGate(pi/2)|"
+
+    qc = qiskit.QuantumCircuit(2)
+    qc.append(gate, [0, 1])
+    correct_unitary = np.array(
+        [
+            [0, 0.891007, 0, -0.45399j],
+            [0.45399, 0j, -0.891007j, 0],
+            [0, -0.45399j, 0, 0.891007],
+            [-0.891007j, 0, 0.45399, 0],
+        ],
+    )
+    assert np.allclose(qiskit.quantum_info.Operator(qc), correct_unitary)
+
 
 def test_zz_swap() -> None:
     gate = qss.ZZSwapGate(1.23)
     _check_gate_definition(gate)
     assert repr(gate) == "qss.ZZSwapGate(1.23)"
     assert str(gate) == "ZZSwapGate(1.23)"
 
     gate = qss.ZZSwapGate(4.56, label="label")
     assert repr(gate) == "qss.ZZSwapGate(4.56, label='label')"
     assert str(gate) == "ZZSwapGate(4.56)"
 
 
+def test_stripped_cz() -> None:
+    gate = qss.StrippedCZGate(1.23)
+    _check_gate_definition(gate)
+    assert repr(gate) == "qss.StrippedCZGate(1.23)"
+    assert str(gate) == "StrippedCZGate(1.23)"
+
+
 def test_parallel_gates() -> None:
     gate = qss.ParallelGates(
         qss.AceCR("+-"),
         qiskit.circuit.library.RXGate(1.23),
     )
-    assert str(gate) == "ParallelGates(acecr_pm, rx(1.23))"
+    assert str(gate) == "ParallelGates(acecr(pi/2), rx(1.23))"
     _check_gate_definition(gate)
 
     # confirm gates are applied to disjoint qubits
     all_qargs: Set[qiskit.circuit.Qubit] = set()
     for _, qargs, _ in gate.definition:
         assert all_qargs.isdisjoint(qargs)
         all_qargs.update(qargs)
@@ -187,15 +219,18 @@
     np.allclose(qiskit.quantum_info.Operator(qc), correct_unitary)
 
 
 def test_custom_resolver() -> None:
     custom_gates: List[qiskit.circuit.Gate] = [
         qss.AceCR("+-"),
         qss.AceCR("-+"),
-        qss.AceCR("+-", 1.23),
+        qss.AceCR("+-", sandwich_rx_rads=1.23),
+        qss.AceCR(np.pi),
+        qss.AceCR(np.pi / 3, np.pi / 2),
+        qss.AceCR(0),
         qss.ZZSwapGate(1.23),
         qss.AQTiCCXGate(),
         qss.custom_gates.iXGate(),
         qss.custom_gates.iXdgGate(),
         qss.custom_gates.iCCXGate(),
         qss.custom_gates.iCCXGate(ctrl_state="01"),
         qss.custom_gates.iCCXGate(ctrl_state="10"),
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## qiskit_superstaq/daily_integration_test.py

```diff
@@ -1,151 +1,163 @@
 """Integration checks that run daily (via Github action) between client and prod server."""
+# pylint: disable=missing-function-docstring
 import os
-from datetime import datetime
 
 import numpy as np
 import pytest
 import qiskit
-from general_superstaq import ResourceEstimate, SuperstaQException
+from general_superstaq import ResourceEstimate, SuperstaqException
 
 import qiskit_superstaq as qss
 
 
 @pytest.fixture
-def provider() -> qss.SuperstaQProvider:
-    token = os.environ["TEST_USER_TOKEN"]
-    provider = qss.SuperstaQProvider(api_key=token)
-    return provider
+def provider() -> qss.SuperstaqProvider:
+    return qss.SuperstaqProvider()
 
 
-def test_backends(provider: qss.SuperstaQProvider) -> None:
+def test_backends(provider: qss.SuperstaqProvider) -> None:
     result = provider.backends()
     assert provider.get_backend("ibmq_qasm_simulator") in result
-    if datetime.now().isoweekday() < 6:  # IonQ device is only available on weekdays
-        assert provider.get_backend("ionq_ion_qpu") in result
 
 
-def test_ibmq_set_token(provider: qss.SuperstaQProvider) -> None:
-    ibmq_token = os.environ["TEST_USER_IBMQ_TOKEN"]
+def test_ibmq_set_token(provider: qss.SuperstaqProvider) -> None:
+    try:
+        ibmq_token = os.environ["TEST_USER_IBMQ_TOKEN"]
+    except KeyError as key:
+        raise KeyError(f"To run the integration tests, please export to {key} a valid IBMQ token")
+
     assert provider.ibmq_set_token(ibmq_token) == "Your IBMQ account token has been updated"
 
-    with pytest.raises(SuperstaQException, match="IBMQ token is invalid."):
+    with pytest.raises(SuperstaqException, match="IBMQ token is invalid."):
         assert provider.ibmq_set_token("INVALID_TOKEN")
 
 
-def test_ibmq_compile(provider: qss.SuperstaQProvider) -> None:
+def test_ibmq_compile(provider: qss.SuperstaqProvider) -> None:
     qc = qiskit.QuantumCircuit(2)
     qc.append(qss.AceCR("+-"), [0, 1])
     out = provider.ibmq_compile(qc, target="ibmq_jakarta_qpu")
     assert isinstance(out, qss.compiler_output.CompilerOutput)
     assert isinstance(out.circuit, qiskit.QuantumCircuit)
     assert isinstance(out.pulse_sequence, qiskit.pulse.Schedule)
-    assert 800 <= out.pulse_sequence.duration <= 1000  # 896 as of 12/27/2021
-    assert out.pulse_sequence.start_time == 0
-    assert len(out.pulse_sequence) == 5
 
 
-def test_acecr_ibmq_compile(provider: qss.SuperstaQProvider) -> None:
+def test_acecr_ibmq_compile(provider: qss.SuperstaqProvider) -> None:
     """Tests ibmq_compile method running without error.
 
     This test was originally written to make sure compilation to ibmq_casablanca would not fail, but
     IBM has since taken casablanca down.
     """
     qc = qiskit.QuantumCircuit(4)
     qc.append(qss.AceCR("-+"), [0, 1])
     qc.append(qss.AceCR("-+"), [1, 2])
     qc.append(qss.AceCR("-+"), [2, 3])
     out = provider.ibmq_compile(qc, target="ibmq_jakarta_qpu")
     assert isinstance(out, qss.compiler_output.CompilerOutput)
     assert isinstance(out.circuit, qiskit.QuantumCircuit)
     assert isinstance(out.pulse_sequence, qiskit.pulse.Schedule)
-    assert out.pulse_sequence.start_time == 0
-    assert len(out.pulse_sequence) == 51
 
     out = provider.ibmq_compile(qc, target="ibmq_perth_qpu")
     assert isinstance(out, qss.compiler_output.CompilerOutput)
     assert isinstance(out.circuit, qiskit.QuantumCircuit)
     assert isinstance(out.pulse_sequence, qiskit.pulse.Schedule)
-    assert out.pulse_sequence.start_time == 0
-    assert len(out.pulse_sequence) == 54
 
     out = provider.ibmq_compile(qc, target="ibmq_lagos_qpu")
     assert isinstance(out, qss.compiler_output.CompilerOutput)
     assert isinstance(out.circuit, qiskit.QuantumCircuit)
     assert isinstance(out.pulse_sequence, qiskit.pulse.Schedule)
-    assert out.pulse_sequence.start_time == 0
-    assert len(out.pulse_sequence) == 61
 
 
-def test_aqt_compile(provider: qss.SuperstaQProvider) -> None:
+def test_aqt_compile(provider: qss.SuperstaqProvider) -> None:
     circuit = qiskit.QuantumCircuit(8)
     circuit.h(4)
     expected = qiskit.QuantumCircuit(8)
     expected.rz(np.pi / 2, 4)
     expected.rx(np.pi / 2, 4)
     expected.rz(np.pi / 2, 4)
     assert provider.aqt_compile(circuit).circuit == expected
     assert provider.aqt_compile([circuit]).circuits == [expected]
     assert provider.aqt_compile([circuit, circuit]).circuits == [expected, expected]
 
 
-def test_aqt_compile_eca(provider: qss.SuperstaQProvider) -> None:
+def test_aqt_compile_eca(provider: qss.SuperstaqProvider) -> None:
     circuit = qiskit.QuantumCircuit(8)
     circuit.h(4)
+    circuit.crx(0.7 * np.pi, 4, 5)
 
-    eca_circuits = provider.aqt_compile_eca(circuit, num_equivalent_circuits=3).circuits
+    eca_circuits = provider.aqt_compile(circuit, num_eca_circuits=3, random_seed=123).circuits
     assert len(eca_circuits) == 3
     assert all(isinstance(circuit, qiskit.QuantumCircuit) for circuit in eca_circuits)
 
-    eca_circuits = provider.aqt_compile_eca([circuit, circuit], num_equivalent_circuits=3).circuits
+    # multiple circuits:
+    eca_circuits = provider.aqt_compile([circuit, circuit], num_eca_circuits=3).circuits
     assert len(eca_circuits) == 2
     for circuits in eca_circuits:
         assert len(circuits) == 3
         assert all(isinstance(circuit, qiskit.QuantumCircuit) for circuit in circuits)
 
 
-def test_get_balance(provider: qss.SuperstaQProvider) -> None:
+@pytest.mark.skip(reason="Won't pass until server issue related to this is fixed")
+def test_aqt_compile_eca_regression(provider: qss.SuperstaqProvider) -> None:
+    circuit = qiskit.QuantumCircuit(8)
+    circuit.h(4)
+    circuit.crx(0.7 * np.pi, 4, 5)
+
+    eca_circuits = provider.aqt_compile(circuit, num_eca_circuits=3, random_seed=123).circuits
+
+    # test with same and different seed
+    assert (
+        eca_circuits == provider.aqt_compile(circuit, num_eca_circuits=3, random_seed=123).circuits
+    )
+    assert (
+        eca_circuits != provider.aqt_compile(circuit, num_eca_circuits=3, random_seed=456).circuits
+    )
+
+
+def test_get_balance(provider: qss.SuperstaqProvider) -> None:
     balance_str = provider.get_balance()
     assert isinstance(balance_str, str)
     assert balance_str.startswith("$")
 
     assert isinstance(provider.get_balance(pretty_output=False), float)
 
 
-def test_get_resource_estimate(provider: qss.SuperstaQProvider) -> None:
+def test_get_resource_estimate(provider: qss.SuperstaqProvider) -> None:
     circuit1 = qiskit.QuantumCircuit(2)
     circuit1.cnot(0, 1)
     circuit1.h(1)
 
-    resource_estimate = provider.resource_estimate(circuit1, "neutral_atom_qpu")
+    resource_estimate = provider.resource_estimate(circuit1, "ss_unconstrained_simulator")
 
     assert resource_estimate == ResourceEstimate(1, 1, 2)
 
     circuit2 = qiskit.QuantumCircuit(2)
     circuit2.h(1)
     circuit2.cnot(0, 1)
     circuit2.cz(1, 0)
 
-    resource_estimates = provider.resource_estimate([circuit1, circuit2], "neutral_atom_qpu")
+    resource_estimates = provider.resource_estimate(
+        [circuit1, circuit2], "ss_unconstrained_simulator"
+    )
 
     assert resource_estimates == [resource_estimate, ResourceEstimate(1, 2, 3)]
 
 
-def test_qscout_compile(provider: qss.SuperstaQProvider) -> None:
+def test_qscout_compile(provider: qss.SuperstaqProvider) -> None:
     circuit = qiskit.QuantumCircuit(1)
     circuit.h(0)
     expected = qiskit.QuantumCircuit(2)
-    expected.u(-np.pi / 2, 0, 0, 0)
+    expected.r(np.pi / 2, -np.pi / 2, 0)
     expected.z(0)
     assert provider.qscout_compile(circuit).circuit == expected
     assert provider.qscout_compile([circuit]).circuits == [expected]
     assert provider.qscout_compile([circuit, circuit]).circuits == [expected, expected]
 
 
-def test_qscout_compile_swap_mirror(provider: qss.SuperstaQProvider) -> None:
+def test_qscout_compile_swap_mirror(provider: qss.SuperstaqProvider) -> None:
     qc = qiskit.QuantumCircuit(2)
     qc.swap(0, 1)
 
     out_qc_swap = qiskit.QuantumCircuit(2)
 
     out = provider.qscout_compile(qc, mirror_swaps=True)
     assert out.circuit == out_qc_swap
@@ -158,35 +170,35 @@
     num_two_qubit_gates = 0
     for _, qbs, _ in out.circuit:
         if len(qbs) > 1:
             num_two_qubit_gates += 1
     assert num_two_qubit_gates == 3
 
 
-def test_cq_compile(provider: qss.SuperstaQProvider) -> None:
+def test_cq_compile(provider: qss.SuperstaqProvider) -> None:
     circuit = qiskit.QuantumCircuit(1)
     circuit.h(0)
     assert isinstance(provider.cq_compile(circuit).circuit, qiskit.QuantumCircuit)
     circuits = provider.cq_compile([circuit]).circuits
     assert len(circuits) == 1 and isinstance(circuits[0], qiskit.QuantumCircuit)
     circuits = provider.cq_compile([circuit, circuit]).circuits
     assert (
         len(circuits) == 2
         and isinstance(circuits[0], qiskit.QuantumCircuit)
         and isinstance(circuits[1], qiskit.QuantumCircuit)
     )
 
 
-def test_get_aqt_configs(provider: qss.superstaq_provider.SuperstaQProvider) -> None:
+def test_get_aqt_configs(provider: qss.superstaq_provider.SuperstaqProvider) -> None:
     res = provider.aqt_get_configs()
     assert "pulses" in res
     assert "variables" in res
 
 
-def test_supercheq(provider: qss.superstaq_provider.SuperstaQProvider) -> None:
+def test_supercheq(provider: qss.superstaq_provider.SuperstaqProvider) -> None:
     # fmt: off
     files = [
         [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 1, 0], [0, 0, 0, 1, 1],
         [0, 0, 1, 0, 0], [0, 0, 1, 0, 1], [0, 0, 1, 1, 0], [0, 0, 1, 1, 1],
         [0, 1, 0, 0, 0], [0, 1, 0, 0, 1], [0, 1, 0, 1, 0], [0, 1, 0, 1, 1],
         [0, 1, 1, 0, 0], [0, 1, 1, 0, 1], [0, 1, 1, 1, 0], [0, 1, 1, 1, 1],
         [1, 0, 0, 0, 0], [1, 0, 0, 0, 1], [1, 0, 0, 1, 0], [1, 0, 0, 1, 1],
@@ -197,7 +209,22 @@
     # fmt: on
 
     num_qubits = 3
     depth = 1
     circuits, fidelities = provider.supercheq(files, num_qubits, depth)
     assert len(circuits) == 32
     assert fidelities.shape == (32, 32)
+
+
+def test_submit_to_provider_simulators(provider: qss.superstaq_provider.SuperstaqProvider) -> None:
+
+    qc = qiskit.QuantumCircuit(2, 2)
+    qc.x(0)
+    qc.cx(0, 1)
+    qc.measure(0, 0)
+    qc.measure(1, 1)
+
+    backends = ["cq_hilbert_simulator", "aws_sv1_simulator", "ibmq_qasm_simulator"]
+
+    for backend in backends:
+        job = provider.get_backend(backend).run(qc, shots=1)
+        assert job.result().get_counts() == {"11": 1}
```

## qiskit_superstaq/serialization.py

```diff
@@ -1,18 +1,76 @@
 import io
+import json
+import re
 import warnings
-from typing import Dict, List, Set, Tuple, Union
+from typing import Dict, List, Sequence, Set, Tuple, TypeVar, Union
 
 import general_superstaq as gss
+import numpy as np
+import numpy.typing as npt
 import qiskit
 import qiskit.qpy
 from qiskit.converters.ast_to_dag import AstInterpreter
 
 import qiskit_superstaq as qss
 
+T = TypeVar("T")
+RealArray = Union[int, float, List["RealArray"]]
+
+
+def json_encoder(val: object) -> Dict[str, Union[str, RealArray]]:
+    """Convert (real or complex) arrays to a JSON-serializable format.
+
+    Args:
+        val: The value to be serialized.
+
+    Returns:
+        A JSON dictionary containing the provided name and array values.
+
+    Raises:
+        TypeError: If `val` is not a `np.ndarray`.
+    """
+    if isinstance(val, np.ndarray):
+        return {
+            "type": "qss_array",
+            "real": val.real.tolist(),
+            "imag": val.imag.tolist(),
+        }
+
+    raise TypeError(f"Object of type {type(val)} is not JSON serializable.")
+
+
+def json_resolver(val: T) -> Union[T, npt.NDArray[np.complex_]]:
+    """Hook to deserialize objects that were serialized via `json_encoder()`.
+
+    Args:
+        val: The deserialized object.
+
+    Returns:
+        The resolved object.
+    """
+    if isinstance(val, dict) and val.get("type") == "qss_array":
+        real_part = val.get("real", 0)
+        imag_part = val.get("imag", 0)
+        return np.array(real_part) + 1j * np.array(imag_part)
+
+    return val
+
+
+def to_json(val: object) -> str:
+    """Extends `json.dumps` to support numpy arrays.
+
+    Args:
+        val: The value to be serialized.
+
+    Returns:
+        The JSON-serialized value (a string).
+    """
+    return json.dumps(val, default=json_encoder)
+
 
 def _assign_unique_inst_names(circuit: qiskit.QuantumCircuit) -> qiskit.QuantumCircuit:
     """QPY requires unique custom gates to have unique `.name` attributes (including parameterized
     gates differing by just their `.params` attributes). This function rewrites the input circuit
     with new instruction names given by appending a unique (consecutive) "_{index}" string to the
     name of any custom instruction which shares a name with a non-equivalent prior instruction in
     the circuit.
@@ -28,25 +86,25 @@
     insts_to_update: List[Tuple[int, int]] = []
     unique_inst_ids: Set[int] = set()
 
     qiskit_gates = set(AstInterpreter.standard_extension) | {"measure"}
 
     new_circuit = circuit.copy()
     for inst, _, _ in new_circuit:
+        inst._define()
         if inst.name in qiskit_gates or id(inst) in unique_inst_ids:
             continue
 
         # save id() in case instruction instance is used more than once
         unique_inst_ids.add(id(inst))
 
         if inst.name in unique_insts_by_name:
             index = 0
             for other in unique_insts_by_name[inst.name]:
-                # compare qasm strings first because equality checking is very slow
-                if inst.qasm() == other.qasm() and inst == other:
+                if inst == other:
                     break
                 index += 1
 
             if index == len(unique_insts_by_name[inst.name]):
                 unique_insts_by_name[inst.name].append(inst)
             if index > 0:
                 insts_to_update.append((inst, index))
@@ -55,15 +113,17 @@
 
     for inst, index in insts_to_update:
         inst.name += f"_{index}"
 
     return new_circuit
 
 
-def serialize_circuits(circuits: Union[qiskit.QuantumCircuit, List[qiskit.QuantumCircuit]]) -> str:
+def serialize_circuits(
+    circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]]
+) -> str:
     """Serialize QuantumCircuit(s) into a single string
 
     Args:
         circuits: a QuantumCircuit or list of QuantumCircuits to be serialized
 
     Returns:
         str representing the serialized circuit(s)
@@ -71,32 +131,57 @@
     if isinstance(circuits, qiskit.QuantumCircuit):
         circuits = [_assign_unique_inst_names(circuits)]
     else:
         circuits = [_assign_unique_inst_names(circuit) for circuit in circuits]
 
     buf = io.BytesIO()
     qiskit.qpy.dump(circuits, buf)
-    return gss.serialization._bytes_to_str(buf.getvalue())
+    return gss.serialization.bytes_to_str(buf.getvalue())
 
 
 def deserialize_circuits(serialized_circuits: str) -> List[qiskit.QuantumCircuit]:
-    """Deserialize serialized QuantumCircuit(s)
+    """Deserialize serialized `qiskit.QuantumCircuit`(s).
 
     Args:
-        serialized_circuits: str generated via qss.serialization.serialize_circuit()
+        serialized_circuits: String generated via `qss.serialization.serialize_circuit()`.
 
     Returns:
-        a list of QuantumCircuits
+        A list containing the deserialized circuits.
+
+    Raises:
+        ValueError: If `serialized_circuits` can't be deserialized.
     """
-    buf = io.BytesIO(gss.serialization._str_to_bytes(serialized_circuits))
+    buf = io.BytesIO(gss.serialization.str_to_bytes(serialized_circuits))
 
-    with warnings.catch_warnings(record=False):
-        warnings.filterwarnings("ignore", "The qiskit version", UserWarning, "qiskit")
-        circuits = qiskit.qpy.load(buf)
+    try:
+        with warnings.catch_warnings(record=False):
+            warnings.filterwarnings("ignore", "The qiskit version", UserWarning, "qiskit")
+            circuits = qiskit.qpy.load(buf)
+
+    except Exception as e:
+        qpy_version_match = re.match(b"QISKIT(.)", buf.getvalue())
+        circuits_qpy_version = ord(qpy_version_match.group(1)) if qpy_version_match else 0
+        if circuits_qpy_version > qiskit.qpy.common.QPY_VERSION:
+            # If the circuit was serialized with a newer version of QPY, that's probably what caused
+            # this error. In this case we should just tell the user to update.
+            raise ValueError(
+                "Circuits failed to deserialize. This is likely because your version of "
+                f"qiskit-terra ({qiskit.__version__}) is out of date. Consider updating it."
+            )
+        else:
+            # Otherwise there is probably a more complicated issue.
+            raise ValueError(
+                "Circuits failed to deserialize. Please contact superstaq@infleqtion.com or file a "
+                "report at https://github.com/Infleqtion/client-superstaq/issues containing "
+                "the following information (as well as any other relevant context):\n\n"
+                f"qiskit-superstaq version: {qss.__version__}\n"
+                f"qiskit-terra version: {qiskit.__version__}\n"
+                f"error: {e!r}"
+            )
 
     for circuit in circuits:
         for pc, (inst, qargs, cargs) in enumerate(circuit._data):
             new_inst = qss.custom_gates.custom_resolver(inst)
             if new_inst is not None:
-                circuit._data[pc] = (new_inst, qargs, cargs)
+                circuit._data[pc] = qiskit.circuit.CircuitInstruction(new_inst, qargs, cargs)
 
     return circuits
```

## qiskit_superstaq/serialization_test.py

```diff
@@ -1,18 +1,58 @@
+# pylint: disable=missing-function-docstring
 import io
+import json
 import warnings
 from unittest import mock
 
 import general_superstaq as gss
+import numpy as np
 import pytest
 import qiskit
 
 import qiskit_superstaq as qss
 
 
+def test_to_json() -> None:
+    real_part = np.random.uniform(-1, 1, size=(4, 4))
+    imag_part = np.random.uniform(-1, 1, size=(4, 4))
+
+    val = [
+        {"abc": 123},
+        real_part,
+        real_part + 1j * imag_part,
+    ]
+
+    json_str = qss.serialization.to_json(val)
+    assert json.loads(json_str) == [
+        {
+            "abc": 123,
+        },
+        {
+            "type": "qss_array",
+            "real": real_part.tolist(),
+            "imag": 4 * [[0, 0, 0, 0]],
+        },
+        {
+            "type": "qss_array",
+            "real": real_part.tolist(),
+            "imag": imag_part.tolist(),
+        },
+    ]
+    resolved_val = json.loads(json_str, object_hook=qss.serialization.json_resolver)
+    assert resolved_val[0] == val[0]
+    assert isinstance(resolved_val[1], np.ndarray)
+    assert isinstance(resolved_val[2], np.ndarray)
+    assert np.all(resolved_val[1] == val[1])
+    assert np.all(resolved_val[2] == val[2])
+
+    with pytest.raises(TypeError, match="not JSON serializable"):
+        qss.serialization.to_json(qiskit.QuantumCircuit())
+
+
 def test_assign_unique_inst_names() -> None:
     inst_0 = qss.ZZSwapGate(0.1)
     inst_1 = qss.ZZSwapGate(0.2)
     inst_2 = qss.ZZSwapGate(0.1)
 
     circuit = qiskit.QuantumCircuit(4)
     circuit.append(inst_0, [0, 1])
@@ -39,15 +79,16 @@
     circuit_0 = qiskit.QuantumCircuit(3)
     circuit_0.cx(2, 1)
     circuit_0.rz(0.86, 0)
 
     circuit_1 = qiskit.QuantumCircuit(4)
     circuit_1.append(qss.AceCR("+-"), [0, 1])
     circuit_1.append(qss.AceCR("-+"), [1, 2])
-    circuit_1.append(qss.AceCR("+-", 1.23), [0, 1])
+    circuit_1.append(qss.AceCR("+-", sandwich_rx_rads=1.23), [0, 1])
+    circuit_1.append(qss.AceCR(np.pi / 3), [0, 1])
     circuit_1.append(qss.ZZSwapGate(0.75), [2, 0])
     circuit_1.append(qss.AQTiCCXGate(), [0, 1, 2])
     circuit_1.append(qss.custom_gates.iCCXGate(), [0, 1, 2])
     circuit_1.append(qss.custom_gates.iCCXGate(ctrl_state="10"), [0, 1, 2])
     circuit_1.append(qss.custom_gates.iCCXGate(ctrl_state="01"), [0, 1, 2])
     circuit_1.append(qss.custom_gates.iCCXdgGate(), [0, 1, 2])
     circuit_1.append(qss.custom_gates.iCCXdgGate(ctrl_state="10"), [0, 1, 2])
@@ -99,14 +140,38 @@
     # QPY encodes qiskit.__version__ into the serialized circuit, so mocking a newer version string
     # during serialization will cause a QPY version UserWarning during deserialization
     with mock.patch("qiskit.qpy.interface.__version__", newer_version):
         serialized_circuit = qss.serialization.serialize_circuits(circuit)
 
     # Check that a warning would normally be thrown
     with pytest.warns(UserWarning):
-        buf = io.BytesIO(gss.serialization._str_to_bytes(serialized_circuit))
+        buf = io.BytesIO(gss.serialization.str_to_bytes(serialized_circuit))
         _ = qiskit.qpy.load(buf)
 
     # Check that it is suppressed by deserialize_circuits
     with warnings.catch_warnings():
         warnings.filterwarnings("error")
         _ = qss.serialization.deserialize_circuits(serialized_circuit)
+
+
+def test_deserialization_errors() -> None:
+    circuit = qiskit.QuantumCircuit(3)
+    circuit.x(0)
+
+    # Mock a circuit serialized with a newer version of QPY:
+    with mock.patch("qiskit.qpy.common.QPY_VERSION", qiskit.qpy.common.QPY_VERSION + 1):
+        serialized_circuit = qss.serialize_circuits(circuit)
+
+    # Remove a few bytes to force a deserialization error
+    serialized_circuit = gss.serialization.bytes_to_str(
+        gss.serialization.str_to_bytes(serialized_circuit)[:-4]
+    )
+
+    with pytest.raises(ValueError, match="your version of qiskit-terra"):
+        _ = qss.deserialize_circuits(serialized_circuit)
+
+    # Mock a circuit serialized with an older of QPY:
+    with mock.patch("qiskit.qpy.common.QPY_VERSION", 3):
+        serialized_circuit = qss.serialize_circuits(circuit)
+
+    with pytest.raises(ValueError, match="Please contact"):
+        _ = qss.deserialize_circuits(serialized_circuit)
```

## qiskit_superstaq/superstaq_backend.py

```diff
@@ -7,69 +7,37 @@
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
-import re
-from typing import Any, Dict, List, Optional, Union
+from __future__ import annotations
 
+import json
+from typing import Any, Dict, List, Mapping, Optional, Sequence, Union
+
+import general_superstaq as gss
+import numpy as np
+import numpy.typing as npt
 import qiskit
 
 import qiskit_superstaq as qss
 
 
-def validate_target(target: str) -> None:
-    vendor_prefixes = [
-        "aqt",
-        "aws",
-        "cq",
-        "hqs",
-        "ibmq",
-        "ionq",
-        "neutral",
-        "oxford",
-        "quera",
-        "rigetti",
-        "sandia",
-        "ss",
-    ]
-
-    target_device_types = ["qpu", "simulator"]
-
-    # Check valid format
-    match = re.fullmatch("^([A-Za-z0-9-]+)_([A-Za-z0-9-.]+)_([a-z]+)", target)
-    if not match:
-        raise ValueError(
-            f"{target} does not have a valid string format. "
-            "Valid target strings should be in the form: "
-            "<provider>_<device>_<type>, e.g. ibmq_lagos_qpu."
-        )
-
-    prefix, _, device_type = match.groups()
-
-    # Check valid prefix
-    if prefix not in vendor_prefixes:
-        raise ValueError(
-            f"{target} does not have a valid target prefix. "
-            f"Valid target prefixes are: {vendor_prefixes}."
-        )
-
-    # Check for valid device type
-    if device_type not in target_device_types:
-        raise ValueError(
-            f"{target} does not have a valid target device type. "
-            f"Valid target device types are: {target_device_types}."
-        )
+class SuperstaqBackend(qiskit.providers.BackendV1):
+    """This class represents a Superstaq backend."""
 
+    def __init__(self, provider: qss.SuperstaqProvider, target: str) -> None:
+        """Initializes a SuperstaqBackend.
 
-class SuperstaQBackend(qiskit.providers.BackendV1):
-    def __init__(self, provider: "qss.SuperstaQProvider", remote_host: str, target: str) -> None:
-        self.remote_host = remote_host
+        Args:
+            provider: Provider for a Superstaq backend.
+            target: A string containing the name of a target backend.
+        """
         self._provider = provider
         self.configuration_dict = {
             "backend_name": target,
             "backend_version": "n/a",
             "n_qubits": -1,
             "basis_gates": None,
             "gates": [],
@@ -78,44 +46,59 @@
             "conditional": False,
             "open_pulse": False,
             "memory": False,
             "max_shots": -1,
             "coupling_map": None,
         }
 
-        validate_target(target)
+        gss.validation.validate_target(target)
 
         super().__init__(
             configuration=qiskit.providers.models.BackendConfiguration.from_dict(
                 self.configuration_dict
             ),
             provider=provider,
         )
 
     @classmethod
     def _default_options(cls) -> qiskit.providers.Options:
         return qiskit.providers.Options(shots=1000)
 
     def __eq__(self, other: Any) -> bool:
-        if not isinstance(other, qss.SuperstaQBackend):
+        if not isinstance(other, qss.SuperstaqBackend):
             return False
 
         return (
             self._provider == other._provider
             and self.configuration_dict == other.configuration_dict
         )
 
     def run(
         self,
-        circuits: Union[qiskit.QuantumCircuit, List[qiskit.QuantumCircuit]],
+        circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]],
         shots: int,
         method: Optional[str] = None,
-        options: Optional[Dict[str, Any]] = None,
-    ) -> "qss.SuperstaQJob":
-
+        **kwargs: Any,
+    ) -> qss.SuperstaqJob:
+        """Runs circuits on the stored Superstaq backend.
+
+        Args:
+            circuits: A list of circuits to run.
+            shots: The number of execution shots (times to run the circuit).
+            method:  An optional string that describes the execution method
+                (e.g. 'dry-run', 'statevector', etc.).
+            kwargs: Other optimization and execution parameters.
+
+        Returns:
+            A Superstaq job storing ID and other related info.
+
+        Raises:
+            ValueError: If `circuits` contains invalid circuits for submission.
+        """
+        qss.validation.validate_qiskit_circuits(circuits)
         if isinstance(circuits, qiskit.QuantumCircuit):
             circuits = [circuits]
 
         if not all(circuit.count_ops().get("measure") for circuit in circuits):
             # TODO: only raise if the run method actually requires samples (and not for e.g. a
             # statevector simulation)
             raise ValueError("Circuit has no measurements to sample.")
@@ -123,16 +106,281 @@
         qiskit_circuits = qss.serialization.serialize_circuits(circuits)
 
         result = self._provider._client.create_job(
             serialized_circuits={"qiskit_circuits": qiskit_circuits},
             repetitions=shots,
             target=self.name(),
             method=method,
-            options=options,
+            **kwargs,
         )
 
         #  we make a virtual job_id that aggregates all of the individual jobs
         # into a single one, that comma-separates the individual jobs:
         job_id = ",".join(result["job_ids"])
-        job = qss.SuperstaQJob(self, job_id)
+        job = qss.SuperstaqJob(self, job_id)
 
         return job
+
+    def compile(
+        self,
+        circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]],
+        **kwargs: Any,
+    ) -> qss.compiler_output.CompilerOutput:
+        """Compiles the given circuit(s) to the backend's native gateset.
+
+        Args:
+            circuits: The qiskit QuantumCircuit(s) to compile.
+            kwargs: Other desired compile options.
+
+        Returns:
+            A CompilerOutput object whose .circuit(s) attribute contains optimized compiled
+            circuit(s).
+
+        Raises:
+            ValueError: If this backend does not support compilation.
+        """
+        if self.name().startswith("ibmq_"):
+            return self.ibmq_compile(circuits, **kwargs)
+
+        elif self.name().startswith("aqt_"):
+            return self.aqt_compile(circuits, **kwargs)
+
+        elif self.name().startswith("sandia_"):
+            return self.qscout_compile(circuits, **kwargs)
+
+        elif self.name().startswith("cq_"):
+            return self.cq_compile(circuits, **kwargs)
+
+        request_json = self._get_compile_request_json(circuits, **kwargs)
+        circuits_is_list = not isinstance(circuits, qiskit.QuantumCircuit)
+        json_dict = self._provider._client.compile(request_json)
+        return qss.compiler_output.read_json_only_circuits(json_dict, circuits_is_list)
+
+    def _get_compile_request_json(
+        self,
+        circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]],
+        **kwargs: Any,
+    ) -> Dict[str, str]:
+        qss.validation.validate_qiskit_circuits(circuits)
+        gss.validation.validate_target(self.name())
+
+        serialized_circuits = qss.serialization.serialize_circuits(circuits)
+        request_json = {
+            "qiskit_circuits": serialized_circuits,
+            "target": self.name(),
+        }
+        if kwargs:
+            request_json["options"] = qss.serialization.to_json(kwargs)
+        return request_json
+
+    def aqt_compile(
+        self,
+        circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]],
+        *,
+        num_eca_circuits: Optional[int] = None,
+        random_seed: Optional[int] = None,
+        atol: Optional[float] = None,
+        gate_defs: Optional[Mapping[str, Union[str, npt.NDArray[np.complex_], None]]] = None,
+        **kwargs: Any,
+    ) -> qss.compiler_output.CompilerOutput:
+        """Compiles and optimizes the given circuit(s) for the Advanced Quantum Testbed (AQT).
+
+        AQT is a superconducting transmon quantum computing testbed at Lawrence Berkeley National
+        Laboratory. More information can be found at https://aqt.lbl.gov.
+
+        Specifying a nonzero value for `num_eca_circuits` enables compilation with Equivalent
+        Circuit Averaging (ECA). See https://arxiv.org/abs/2111.04572 for a description of ECA.
+
+        Args:
+            circuits: The circuit(s) to compile.
+            num_eca_circuits: Optional number of logically equivalent random circuits to generate
+                from each input circuit for Equivalent Circuit Averaging (ECA).
+            random_seed: Optional seed used for approximate synthesis and ECA.
+            atol: An optional tolerance to use for approximate gate synthesis.
+            gate_defs: An optional dictionary mapping names in qtrl configs to operations, where
+                each operation can be either a unitary matrix or None. More specific associations
+                take precedence, for example `{"SWAP": <matrix1>, "SWAP/C5C4": <matrix2>}` implies
+                `<matrix1>` for all "SWAP" calibrations except "SWAP/C5C4" (which will instead be
+                mapped to `<matrix2>` applied to qubits 4 and 5). Setting any calibration to None
+                will disable that calibration.
+            kwargs: Other desired compile options.
+
+        Returns:
+            Object whose .circuit(s) attribute contains the optimized circuits(s). Alternatively for
+            ECA, an Object whose .circuits attribute is a list (or list of lists) of logically
+            equivalent circuits. If qtrl is installed, the object's .seq attribute is a qtrl
+            Sequence object containing pulse sequences for each compiled circuit, and its
+            .pulse_list(s) attribute contains the corresponding list(s) of cycles.
+
+        Raises:
+            ValueError: If this is not an AQT backend.
+        """
+        if not self.name().startswith("aqt_"):
+            raise ValueError(f"{self.name()!r} is not a valid AQT target.")
+
+        options: Dict[str, Any] = {**kwargs}
+        if num_eca_circuits is not None:
+            gss.validation.validate_integer_param(num_eca_circuits)
+            options["num_eca_circuits"] = int(num_eca_circuits)
+        if random_seed is not None:
+            gss.validation.validate_integer_param(random_seed)
+            options["random_seed"] = int(random_seed)
+        if atol is not None:
+            options["atol"] = float(atol)
+        if gate_defs is not None:
+            options["gate_defs"] = gate_defs
+
+        request_json = self._get_compile_request_json(circuits, **options)
+        circuits_is_list = not isinstance(circuits, qiskit.QuantumCircuit)
+        json_dict = self._provider._client.aqt_compile(request_json)
+        return qss.compiler_output.read_json_aqt(json_dict, circuits_is_list, num_eca_circuits)
+
+    def ibmq_compile(
+        self,
+        circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]],
+        **kwargs: Any,
+    ) -> qss.compiler_output.CompilerOutput:
+        """Compiles and optimizes the given circuit(s) for IBMQ devices.
+
+        Args:
+            circuits: The qiskit QuantumCircuit(s) to compile.
+            kwargs: Other desired compile options.
+
+        Returns:
+            An IBMQ CompilerOutput object whose .circuit(s) attribute is an optimized qiskit
+            QuantumCircuit(s).
+
+        Raises:
+            ValueError: If this is not an IBMQ backend.
+        """
+        if not self.name().startswith("ibmq_"):
+            raise ValueError(f"{self.name()!r} is not a valid IBMQ target.")
+
+        request_json = self._get_compile_request_json(circuits, **kwargs)
+        json_dict = self._provider._client.compile(request_json)
+        compiled_circuits = qss.serialization.deserialize_circuits(json_dict["qiskit_circuits"])
+
+        pulses = None
+        if "pulses" in json_dict:
+            pulses = gss.serialization.deserialize(json_dict["pulses"])
+        final_logical_to_physicals: List[Dict[int, int]] = list(
+            map(dict, json.loads(json_dict["final_logical_to_physicals"]))
+        )
+        if isinstance(circuits, qiskit.QuantumCircuit):
+            pulse_sequence = None if pulses is None else pulses[0]
+            return qss.compiler_output.CompilerOutput(
+                compiled_circuits[0], final_logical_to_physicals[0], pulse_sequences=pulse_sequence
+            )
+
+        return qss.compiler_output.CompilerOutput(
+            compiled_circuits,
+            final_logical_to_physicals,
+            pulse_sequences=pulses,
+        )
+
+    def qscout_compile(
+        self,
+        circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]],
+        mirror_swaps: bool = True,
+        base_entangling_gate: str = "xx",
+        **kwargs: Any,
+    ) -> qss.compiler_output.CompilerOutput:
+        """Compiles and optimizes the given circuit(s) for the QSCOUT trapped-ion testbed at Sandia
+        National Laboratories [1].
+
+        Compiled circuits are returned as both `qiskit.QuantumCircuit` objects and corresponding
+        Jaqal [2] programs (strings).
+
+        References:
+            [1] S. M. Clark et al., *Engineering the Quantum Scientific Computing Open User
+                Testbed*, IEEE Transactions on Quantum Engineering Vol. 2, 3102832 (2021).
+                https://doi.org/10.1109/TQE.2021.3096480.
+            [2] B. Morrison, et al., *Just Another Quantum Assembly Language (Jaqal)*, 2020 IEEE
+                International Conference on Quantum Computing and Engineering (QCE), 402-408 (2020).
+                https://arxiv.org/abs/2008.08042.
+
+        Args:
+            circuits: The circuit(s) to compile.
+            mirror_swaps: Whether to use mirror swapping to reduce two-qubit gate overhead.
+            base_entangling_gate: The base entangling gate to use (either "xx" or "zz").
+            kwargs: Other desired qscout_compile options.
+
+        Returns:
+            Object whose .circuit(s) attribute contains optimized `qiskit QuantumCircuit`(s), and
+            `.jaqal_program(s)` attribute contains the corresponding Jaqal program(s).
+
+        Raises:
+            ValueError: If this is not a Sandia backend.
+            ValueError: If `base_entangling_gate` is not a valid entangling basis.
+        """
+        if not self.name().startswith("sandia_"):
+            raise ValueError(f"{self.name()!r} is not a valid Sandia target.")
+
+        if base_entangling_gate not in ("xx", "zz"):
+            raise ValueError("base_entangling_gate must be either 'xx' or 'zz'")
+
+        options = {
+            **kwargs,
+            "mirror_swaps": mirror_swaps,
+            "base_entangling_gate": base_entangling_gate,
+        }
+        request_json = self._get_compile_request_json(circuits, **options)
+        circuits_is_list = not isinstance(circuits, qiskit.QuantumCircuit)
+        json_dict = self._provider._client.qscout_compile(request_json)
+        return qss.compiler_output.read_json_qscout(json_dict, circuits_is_list)
+
+    def cq_compile(
+        self,
+        circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]],
+        **kwargs: Any,
+    ) -> qss.compiler_output.CompilerOutput:
+        """Compiles and optimizes the given circuit(s) for CQ devices.
+
+        Args:
+            circuits: The qiskit QuantumCircuit(s) to compile.
+            kwargs: Other desired compile options.
+
+        Returns:
+            An CQ CompilerOutput object.
+
+        Raises:
+            ValueError: If this is not a CQ backend.
+        """
+        if not self.name().startswith("cq_"):
+            raise ValueError(f"{self.name()!r} is not a valid CQ target.")
+
+        request_json = self._get_compile_request_json(circuits, **kwargs)
+        circuits_is_list = not isinstance(circuits, qiskit.QuantumCircuit)
+        json_dict = self._provider._client.compile(request_json)
+        return qss.compiler_output.read_json_only_circuits(json_dict, circuits_is_list)
+
+    def target_info(self) -> Dict[str, Any]:
+        """Returns information about this backend.
+
+        Returns:
+            A dictionary of target information.
+        """
+        return self._provider._client.target_info(self.name())["target_info"]
+
+    def resource_estimate(
+        self, circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]]
+    ) -> Union[gss.ResourceEstimate, List[gss.ResourceEstimate]]:
+        """Generates resource estimates for qiskit circuit(s).
+
+        Args:
+            circuits: The circuit(s) used during resource estimation.
+
+        Returns:
+            ResourceEstimate(s) containing resource costs (after compilation) for running circuit(s)
+            on this backend.
+        """
+        request_json = self._get_compile_request_json(circuits)
+        circuits_is_list = not isinstance(circuits, qiskit.QuantumCircuit)
+        json_dict = self._provider._client.resource_estimate(request_json)
+
+        resource_estimates = [
+            gss.ResourceEstimate(json_data=resource_estimate)
+            for resource_estimate in json_dict["resource_estimates"]
+        ]
+        if circuits_is_list:
+            return resource_estimates
+        return resource_estimates[0]
```

## qiskit_superstaq/superstaq_backend_test.py

```diff
@@ -1,132 +1,285 @@
-from unittest.mock import MagicMock
+# pylint: disable=missing-function-docstring,missing-class-docstring
+import json
+import textwrap
+from unittest.mock import DEFAULT, MagicMock, patch
 
 import general_superstaq as gss
 import pytest
 import qiskit
 
 import qiskit_superstaq as qss
 
 
 def test_default_options() -> None:
-    ss_provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
-    device = qss.SuperstaQBackend(
-        provider=ss_provider,
-        remote_host=gss.API_URL,
-        target="ibmq_qasm_simulator",
-    )
-
-    assert qiskit.providers.Options(shots=1000) == device._default_options()
-
-
-class MockProvider(qss.SuperstaQProvider):
-    def __init__(self) -> None:
-        self.api_key = "super.tech"
-
-
-class MockDevice(qss.SuperstaQBackend):
-    def __init__(self) -> None:
-        super().__init__(MockProvider(), "super.tech", "ss_example_qpu")
-        self._provider = MockProvider()
-
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
+    backend = qss.SuperstaqBackend(provider=provider, target="ibmq_qasm_simulator")
 
-def test_validate_target() -> None:
-    provider = qss.SuperstaQProvider(api_key="123")
-    with pytest.raises(ValueError, match="does not have a valid string format"):
-        qss.SuperstaQBackend(provider=provider, remote_host=gss.API_URL, target="invalid_target")
-
-    with pytest.raises(ValueError, match="does not have a valid target device type"):
-        qss.SuperstaQBackend(
-            provider=provider, remote_host=gss.API_URL, target="ibmq_invalid_device"
-        )
-
-    with pytest.raises(ValueError, match="does not have a valid target prefix"):
-        qss.SuperstaQBackend(provider=provider, remote_host=gss.API_URL, target="invalid_test_qpu")
+    assert qiskit.providers.Options(shots=1000) == backend._default_options()
 
 
 def test_run() -> None:
     qc = qiskit.QuantumCircuit(2, 2)
     qc.h(0)
     qc.cx(0, 1)
     qc.measure([0, 0], [1, 1])
-    device = MockDevice()
-
-    mock_client = MagicMock()
-    mock_client.create_job.return_value = {
-        "job_ids": ["job_id"],
-        "status": "ready",
-    }
 
-    device._provider._client = mock_client
+    backend = qss.SuperstaqProvider(api_key="123").get_backend("ss_example_qpu")
 
-    answer = device.run(circuits=qc, shots=1000)
-    expected = qss.SuperstaQJob(device, "job_id")
-    assert answer == expected
+    with patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.create_job",
+        return_value={"job_ids": ["job_id"], "status": "ready"},
+    ):
+        answer = backend.run(circuits=qc, shots=1000)
+        expected = qss.SuperstaqJob(backend, "job_id")
+        assert answer == expected
 
     with pytest.raises(ValueError, match="Circuit has no measurements to sample"):
         qc.remove_final_measurements()
-        device.run(qc, shots=1000)
+        backend.run(qc, shots=1000)
 
 
 def test_multi_circuit_run() -> None:
-    device = MockDevice()
-
     qc1 = qiskit.QuantumCircuit(1, 1)
     qc1.h(0)
     qc1.measure(0, 0)
 
     qc2 = qiskit.QuantumCircuit(2, 2)
     qc2.h(0)
     qc2.cx(0, 1)
     qc2.measure([0, 1], [0, 1])
 
-    mock_client = MagicMock()
-    mock_client.create_job.return_value = {
-        "job_ids": ["job_id"],
-        "status": "ready",
-    }
-    device._provider._client = mock_client
+    backend = qss.SuperstaqProvider(api_key="123").get_backend("ss_example_qpu")
 
-    answer = device.run(circuits=[qc1, qc2], shots=1000)
-    expected = qss.SuperstaQJob(device, "job_id")
-
-    assert answer == expected
+    with patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.create_job",
+        return_value={"job_ids": ["job_id"], "status": "ready"},
+    ):
+        answer = backend.run(circuits=[qc1, qc2], shots=1000)
+        expected = qss.SuperstaqJob(backend, "job_id")
+        assert answer == expected
 
 
 def test_multi_arg_run() -> None:
     qc = qiskit.QuantumCircuit(2, 2)
     qc.h(0)
     qc.cx(0, 1)
     qc.measure([0, 0], [1, 1])
-    device = MockDevice()
-
-    mock_client = MagicMock()
-    mock_client.create_job.return_value = {
-        "job_ids": ["job_id"],
-        "status": "ready",
-    }
 
-    device._provider._client = mock_client
+    backend = qss.SuperstaqProvider(api_key="123").get_backend("ss_example_qpu")
 
-    answer = device.run(circuits=qc, shots=1000, method="fake_method", options={"test": "123"})
-    expected = qss.SuperstaQJob(device, "job_id")
-    assert answer == expected
+    with patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.create_job",
+        return_value={"job_ids": ["job_id"], "status": "ready"},
+    ):
+        answer = backend.run(circuits=qc, shots=1000, method="fake_method", test="123")
+        expected = qss.SuperstaqJob(backend, "job_id")
+        assert answer == expected
 
 
 def test_eq() -> None:
+    provider = qss.SuperstaqProvider(api_key="123")
+
+    backend1 = provider.get_backend("ibmq_qasm_simulator")
+    assert backend1 != 3
+
+    backend2 = provider.get_backend("ibmq_athens_qpu")
+    assert backend1 != backend2
 
-    assert MockDevice() != 3
+    backend3 = provider.get_backend("ibmq_qasm_simulator")
+    assert backend1 == backend3
 
-    provider = qss.SuperstaQProvider(api_key="123")
 
-    backend1 = qss.SuperstaQBackend(
-        provider=provider, remote_host=gss.API_URL, target="ibmq_qasm_simulator"
+@patch("requests.post")
+def test_aqt_compile(mock_post: MagicMock) -> None:
+    # AQT compile
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
+    backend = provider.get_backend("aqt_keysight_qpu")
+
+    qc = qiskit.QuantumCircuit(8)
+    qc.cz(4, 5)
+
+    mock_post.return_value.json = lambda: {
+        "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": "[[[1, 4]]]",
+        "state_jp": gss.serialization.serialize({}),
+        "pulse_lists_jp": gss.serialization.serialize([[[]]]),
+    }
+    out = backend.compile(qc)
+    assert out.circuit == qc
+    assert out.final_logical_to_physical == {1: 4}
+    assert not hasattr(out, "circuits") and not hasattr(out, "pulse_lists")
+    mock_post.assert_called_with(
+        f"{provider._client.url}/aqt_compile",
+        headers=provider._client.headers,
+        verify=provider._client.verify_https,
+        json={
+            "qiskit_circuits": qss.serialize_circuits(qc),
+            "target": "aqt_keysight_qpu",
+        },
     )
-    backend2 = qss.SuperstaQBackend(
-        provider=provider, remote_host=gss.API_URL, target="ibmq_athens_qpu"
+
+    out = backend.compile([qc], atol=1e-2)
+    assert out.circuits == [qc]
+    assert out.final_logical_to_physicals == [{1: 4}]
+    assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
+    mock_post.assert_called_with(
+        f"{provider._client.url}/aqt_compile",
+        headers=provider._client.headers,
+        verify=provider._client.verify_https,
+        json={
+            "qiskit_circuits": qss.serialize_circuits(qc),
+            "target": "aqt_keysight_qpu",
+            "options": json.dumps({"atol": 1e-2}),
+        },
     )
-    assert backend1 != backend2
 
-    backend3 = qss.SuperstaQBackend(
-        provider=provider, remote_host=gss.API_URL, target="ibmq_qasm_simulator"
+    mock_post.return_value.json = lambda: {
+        "qiskit_circuits": qss.serialization.serialize_circuits([qc, qc]),
+        "final_logical_to_physicals": "[[], []]",
+        "state_jp": gss.serialization.serialize({}),
+        "pulse_lists_jp": gss.serialization.serialize([[[]], [[]]]),
+    }
+    matrix = qiskit.circuit.library.CRXGate(1.23).to_matrix()
+    out = backend.compile([qc, qc], gate_defs={"CRX": matrix})
+    assert out.circuits == [qc, qc]
+    assert out.final_logical_to_physicals == [{}, {}]
+    assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
+    mock_post.assert_called_with(
+        f"{provider._client.url}/aqt_compile",
+        headers=provider._client.headers,
+        verify=provider._client.verify_https,
+        json={
+            "qiskit_circuits": qss.serialize_circuits([qc, qc]),
+            "target": "aqt_keysight_qpu",
+            "options": qss.serialization.to_json({"gate_defs": {"CRX": matrix}}),
+        },
     )
-    assert backend1 == backend3
+
+    with pytest.raises(ValueError, match="'aqt_keysight_qpu' is not a valid IBMQ target."):
+        backend.ibmq_compile([qc])
+
+    with pytest.raises(ValueError, match="'aqt_keysight_qpu' is not a valid Sandia target."):
+        backend.qscout_compile([qc])
+
+    with pytest.raises(ValueError, match="'aqt_keysight_qpu' is not a valid CQ target."):
+        backend.cq_compile([qc])
+
+    # AQT ECA compile
+    mock_post.return_value.json = lambda: {
+        "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": "[[]]",
+        "state_jp": gss.serialization.serialize({}),
+        "pulse_lists_jp": gss.serialization.serialize([[[]]]),
+    }
+
+    out = backend.compile(qc, num_eca_circuits=1, random_seed=1234, atol=1e-2, test_options="yes")
+    assert out.circuits == [qc]
+    assert out.final_logical_to_physicals == [{}]
+    assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
+
+    # AQT ECA compile
+    mock_post.return_value.json = lambda: {
+        "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": "[[]]",
+        "state_jp": gss.serialization.serialize({}),
+        "pulse_lists_jp": gss.serialization.serialize([[[]]]),
+    }
+
+    out = backend.compile(qc, num_eca_circuits=1, random_seed=1234, atol=1e-2, test_options="yes")
+    assert out.circuits == [qc]
+    assert out.final_logical_to_physicals == [{}]
+    assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
+
+
+@patch("requests.post")
+def test_ibmq_compile(mock_post: MagicMock) -> None:
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
+    backend = provider.get_backend("ibmq_jakarta_qpu")
+
+    qc = qiskit.QuantumCircuit(8)
+    qc.cz(4, 5)
+
+    final_logical_to_physical = {0: 4, 1: 5}
+    mock_post.return_value.json = lambda: {
+        "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": "[[[0, 4], [1, 5]]]",
+        "pulses": gss.serialization.serialize([DEFAULT]),
+    }
+    assert backend.compile(
+        qiskit.QuantumCircuit(), test_options="yes"
+    ) == qss.compiler_output.CompilerOutput(qc, final_logical_to_physical, pulse_sequences=DEFAULT)
+    assert backend.compile([qiskit.QuantumCircuit()]) == qss.compiler_output.CompilerOutput(
+        [qc], [final_logical_to_physical], pulse_sequences=[DEFAULT]
+    )
+
+    with pytest.raises(ValueError, match="'ibmq_jakarta_qpu' is not a valid AQT target."):
+        backend.aqt_compile([qc])
+
+
+@patch("requests.post")
+def test_qscout_compile(mock_post: MagicMock) -> None:
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
+    backend = provider.get_backend("sandia_qscout_qpu")
+
+    qc = qiskit.QuantumCircuit(1)
+    qc.h(0)
+    jaqal_program = textwrap.dedent(
+        """\
+        register allqubits[1]
+
+        prepare_all
+        R allqubits[0] -1.5707963267948966 1.5707963267948966
+        Rz allqubits[0] -3.141592653589793
+        measure_all
+        """
+    )
+    logical_to_physical = {0: 13}
+    mock_post.return_value.json = lambda: {
+        "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": json.dumps([list(logical_to_physical.items())]),
+        "jaqal_programs": [jaqal_program],
+    }
+    out = backend.compile(qc, test_options="yes")
+    assert out.circuit == qc
+    assert out.final_logical_to_physical == logical_to_physical
+
+    out = backend.compile([qc])
+    assert out.circuits == [qc]
+    assert out.final_logical_to_physicals == [{0: 13}]
+
+    mock_post.return_value.json = lambda: {
+        "qiskit_circuits": qss.serialization.serialize_circuits([qc, qc]),
+        "final_logical_to_physicals": json.dumps([[(0, 13)], [(0, 13)]]),
+        "jaqal_programs": [jaqal_program, jaqal_program],
+    }
+    out = provider.qscout_compile([qc, qc])
+    assert out.circuits == [qc, qc]
+    assert out.final_logical_to_physicals == [{0: 13}, {0: 13}]
+
+
+@patch("requests.post")
+def test_compile(mock_post: MagicMock) -> None:
+    # Compilation to a simulator (e.g., AWS)
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
+    backend = provider.get_backend("aws_sv1_simulator")
+
+    qc = qiskit.QuantumCircuit(1)
+    qc.h(0)
+    mock_post.return_value.json = lambda: {
+        "qiskit_circuits": qss.serialization.serialize_circuits([qc]),
+        "final_logical_to_physicals": json.dumps([[(0, 0)]]),
+    }
+    out = backend.compile([qc], test_options="yes")
+    assert out.circuits == [qc]
+    assert out.final_logical_to_physicals == [{0: 0}]
+
+
+def test_target_info() -> None:
+    target = "ibmq_qasm_simulator"
+    backend = qss.SuperstaqProvider(api_key="123").get_backend(target)
+    fake_data = {"target_info": {"backend_name": target}}
+    with patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.target_info",
+        return_value=fake_data,
+    ):
+        assert backend.target_info() == fake_data["target_info"]
```

## qiskit_superstaq/superstaq_job.py

```diff
@@ -8,132 +8,176 @@
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
-import time
 from typing import Any, Dict, List, Optional
 
 import general_superstaq as gss
 import qiskit
-import requests
 
 import qiskit_superstaq as qss
 
 
-class SuperstaQJob(qiskit.providers.JobV1):
-    def __init__(
-        self,
-        backend: qss.SuperstaQBackend,
-        job_id: str,
-    ) -> None:
+class SuperstaqJob(qiskit.providers.JobV1):
+    """This class represents a Superstaq job instance."""
 
-        # Can we stop setting qobj and access_token to None
+    TERMINAL_STATES = ("Done", "Cancelled", "Failed")
+    PROCESSING_STATES = ("Queued", "Submitted", "Running")
+    ALL_STATES = TERMINAL_STATES + PROCESSING_STATES
+
+    def __init__(self, backend: qss.SuperstaqBackend, job_id: str) -> None:
         """Initialize a job instance.
 
-        Parameters:
-            backend (SuperstaQBackend): Backend that job was executed on.
-            job_id (str): The unique job ID from SuperstaQ.
-            access_token (str): The access token.
+        Args:
+            backend: The `qss.SuperstaqBackend` that the job was created with.
+            job_id: The unique job ID string from Superstaq.
         """
         super().__init__(backend, job_id)
+        self._overall_status = "Submitted"
+        self._job_info: Dict[str, Any] = {}
 
-    def __eq__(self, other: Any) -> bool:
+    def __eq__(self, other: object) -> bool:
 
-        if not (isinstance(other, SuperstaQJob)):
+        if not (isinstance(other, SuperstaqJob)):
             return False
 
         return self._job_id == other._job_id
 
-    def _wait_for_results(
-        self, timeout: Optional[float] = None, wait: float = 5
-    ) -> List[Dict[str, Optional[int]]]:
-
-        result_list: List[Dict[str, Optional[int]]] = []
-        job_ids = self._job_id.split(",")  # separate aggregated job_ids
-
-        for jid in job_ids:
-            start_time = time.time()
-            while True:
-                elapsed = time.time() - start_time
-
-                if timeout and elapsed >= timeout:
-                    raise qiskit.providers.JobTimeoutError(
-                        "Timed out waiting for result"
-                    )  # pragma: no cover b/c don't want slow test or mocking time
-
-                getstr = f"{self._backend.remote_host}/{gss.API_VERSION}/job/{jid}"
-                result = requests.get(
-                    getstr,
-                    headers=self._backend._provider._http_headers(),
-                    verify=(self._backend.remote_host == gss.API_URL),
-                ).json()
-                if result["status"] == "Done":
-                    break
-                if result["status"] == "Error":
-                    raise qiskit.providers.JobError("API returned error:\n" + str(result))
-                time.sleep(wait)  # pragma: no cover b/c don't want slow test or mocking time
-            result_list.append(result)
-        return result_list
+    def _wait_for_results(self, timeout: float, wait: float = 5) -> List[Dict[str, Dict[str, int]]]:
+        """Waits for the results till either the job is done or some error in the job occurs.
+
+        Args:
+            timeout: Time to wait for results. Defaults to None.
+            wait: Time to wait before checking again. Defaults to 5.
+
+        Returns:
+            Results from the job.
+        """
+
+        self.wait_for_final_state(timeout, wait)  # should call self.status()
+
+        return [self._job_info[job_id] for job_id in self._job_id.split(",")]
 
     def result(self, timeout: Optional[float] = None, wait: float = 5) -> qiskit.result.Result:
-        # Get the result data of a circuit.
+        """Retrieves the result data associated with a Superstaq job.
+
+        Args:
+            timeout: An optional parameter that fixes when result retrieval times out. Units are
+                in seconds.
+            wait: An optional parameter that sets the interval to check for Superstaq job results.
+                Units are in seconds. Defaults to 5.
+
+        Returns:
+            A qiskit result object containing job information.
+        """
+        timeout = timeout or self._backend._provider._client.max_retry_seconds
         results = self._wait_for_results(timeout, wait)
 
         # create list of result dictionaries
         results_list = []
         for result in results:
+            counts = result["samples"]
+            if counts:  # change endianess to match Qiskit
+                counts = dict((key[::-1], value) for (key, value) in counts.items())
             results_list.append(
-                {"success": True, "shots": result["shots"], "data": {"counts": result["samples"]}}
+                {
+                    "success": result["status"] == "Done",
+                    "status": result["status"],
+                    "shots": result["shots"],
+                    "data": {"counts": counts},
+                }
             )
 
         return qiskit.result.Result.from_dict(
             {
                 "results": results_list,
                 "qobj_id": -1,
                 "backend_name": self._backend._configuration.backend_name,
                 "backend_version": self._backend._configuration.backend_version,
-                "success": True,
+                "success": self._overall_status == "Done",
+                "status": self._overall_status,
                 "job_id": self._job_id,
             }
         )
 
-    def status(self) -> qiskit.providers.jobstatus.JobStatus:
-        """Query for the job status."""
+    def _check_if_stopped(self) -> None:
+        """Verifies that the job status is not in a cancelled or failed state and
+        raises an exception if it is.
+
+        Raises:
+            SuperstaqUnsuccessfulJobException: If the job been cancelled or has
+        failed.
+            SuperstaqException: If unable to get the status of the job from the API.
+        """
+        if self._overall_status in ("Cancelled", "Failed"):
+            raise gss.superstaq_exceptions.SuperstaqUnsuccessfulJobException(
+                self._job_id, self._overall_status
+            )
+
+    def _refresh_job(self) -> None:
+        """Queries the server for an updated job result."""
+
+        for job_id in self._job_id.split(","):
+
+            if (job_id not in self._job_info) or (
+                job_id in self._job_info
+                and self._job_info[job_id]["status"] not in self.TERMINAL_STATES
+            ):
+                result = self._backend._provider._client.get_job(job_id)
+                self._job_info[job_id] = result
+
+        self._update_status_queue_info()
+
+    def _update_status_queue_info(self) -> None:
+        """Updates the overall status based on status queue info.
+
+        Note:
+            When we have multiple jobs, we will take the "worst status" among the jobs.
+            The worst status check follows the chain: Submitted -> Queued -> Running -> Failed
+            -> Cancelled -> Done. For example, if any of the jobs are still queued (even if
+            some are done), we report 'Queued' as the overall status of the entire batch.
+        """
 
         job_id_list = self._job_id.split(",")  # separate aggregated job ids
 
-        status = "Done"
+        status_occurrence = {self._job_info[job_id]["status"] for job_id in job_id_list}
+        status_priority_order = ("Submitted", "Queued", "Running", "Failed", "Cancelled", "Done")
 
-        # when we have multiple jobs, we will take the "worst status" among the jobs
-        # For example, if any of the jobs are still queued, we report Queued as the status
-        # for the entire batch.
-        for job_id in job_id_list:
-            get_url = f"{self._backend.remote_host}/{gss.API_VERSION}/job/{job_id}"
-            result = requests.get(
-                get_url,
-                headers=self._backend._provider._http_headers(),
-                verify=(self._backend.remote_host == gss.API_URL),
-            )
+        for temp_status in status_priority_order:
+            if temp_status in status_occurrence:
+                self._overall_status = temp_status
+                return
+
+    def status(self) -> qiskit.providers.jobstatus.JobStatus:
+        """Query for the equivalent qiskit job status.
 
-            temp_status = result.json()["status"]
+        Returns:
+            The equivalent `qiskit.providers.jobstatus.JobStatus` type.
+        """
+
+        status_match = {
+            "Queued": qiskit.providers.jobstatus.JobStatus.QUEUED,
+            "Running": qiskit.providers.jobstatus.JobStatus.RUNNING,
+            "Submitted": qiskit.providers.jobstatus.JobStatus.INITIALIZING,
+            "Cancelled": qiskit.providers.jobstatus.JobStatus.CANCELLED,
+            "Failed": qiskit.providers.jobstatus.JobStatus.ERROR,
+            "Done": qiskit.providers.jobstatus.JobStatus.DONE,
+        }
+
+        if self._overall_status in self.TERMINAL_STATES:
+            return status_match.get(self._overall_status)
 
-            if temp_status == "Queued":
-                status = "Queued"
-                break
-            elif temp_status == "Running":
-                status = "Running"
-
-        assert status in ["Queued", "Running", "Done"]
-
-        if status == "Queued":
-            status = qiskit.providers.jobstatus.JobStatus.QUEUED
-        elif status == "Running":
-            status = qiskit.providers.jobstatus.JobStatus.RUNNING
-        else:
-            status = qiskit.providers.jobstatus.JobStatus.DONE
-        return status
+        self._refresh_job()
+        status = self._overall_status
+
+        return status_match.get(status)
 
     def submit(self) -> None:
-        raise NotImplementedError("Submit through SuperstaQBackend, not through SuperstaqJob")
+        """Unsupported submission call.
+
+        Raises:
+            NotImplementedError: If a job is submitted via SuperstaqJob.
+        """
+        raise NotImplementedError("Submit through SuperstaqBackend, not through SuperstaqJob")
```

## qiskit_superstaq/superstaq_job_test.py

```diff
@@ -1,126 +1,210 @@
-import json
-from typing import Any, Dict
+# pylint: disable=missing-function-docstring,missing-class-docstring
+from typing import Dict, Union
+from unittest import mock
 
 import general_superstaq as gss
 import pytest
 import qiskit
-import requests
 
 import qiskit_superstaq as qss
 
 
-class MockConfiguration:
-    backend_name = "superstaq_backend"
-    backend_version = gss.API_VERSION
+def mock_response(status_str: str) -> Dict[str, Union[str, int, Dict[str, int]]]:
+    return {"status": status_str, "samples": {"10": 100}, "shots": 100}
 
 
-class MockProvider(qss.SuperstaQProvider):
-    def __init__(self) -> None:
-        self.api_key = "very.tech"
+@pytest.fixture
+def backend() -> qss.SuperstaqBackend:
+    provider = qss.SuperstaqProvider(api_key="token")
+    return provider.get_backend("ss_example_qpu")
+
+
+def test_wait_for_results(backend: qss.SuperstaqBackend) -> None:
+    job = qss.SuperstaqJob(backend=backend, job_id="123abc")
+    jobs = qss.SuperstaqJob(backend=backend, job_id="123abc,456def")
+
+    with mock.patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.get_job",
+        return_value=mock_response("Done"),
+    ):
+        assert job._wait_for_results(timeout=backend._provider._client.max_retry_seconds) == [
+            mock_response("Done")
+        ]
+        assert jobs._wait_for_results(timeout=backend._provider._client.max_retry_seconds) == [
+            mock_response("Done"),
+            mock_response("Done"),
+        ]
+
+
+def test_timeout(backend: qss.SuperstaqBackend) -> None:
+    job = qss.SuperstaqJob(backend=backend, job_id="123abc")
+
+    with mock.patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.get_job",
+        side_effect=[mock_response("Queued"), mock_response("Queued"), mock_response("Done")],
+    ) as mocked_get_job:
+        assert job._wait_for_results(
+            timeout=backend._provider._client.max_retry_seconds, wait=0.0
+        ) == [mock_response("Done")]
+        assert mocked_get_job.call_count == 3
 
 
-class MockDevice(qss.SuperstaQBackend):
-    def __init__(self) -> None:
-        self._provider = MockProvider()
-        self.diff = ""
+def test_result(backend: qss.SuperstaqBackend) -> None:
+    job = qss.SuperstaqJob(backend=backend, job_id="123abc")
 
-    _configuration = MockConfiguration()
-
-    remote_host = "super.tech"
-
-
-class MockJob(qss.SuperstaQJob):
-    def __init__(self) -> None:
-        self._backend = MockDevice()
-        self._job_id = "123abc"
-        self.qobj = None
-
-
-class MockJobs(qss.SuperstaQJob):
-    def __init__(self) -> None:
-        self._backend = MockDevice()
-        self._job_id = "123abc,456def"
-        self.qobj = None
-
-
-class MockResponse:
-    def __init__(self, status_str: str) -> None:
-        self.content = json.dumps({"status": status_str, "samples": None, "shots": 100})
-
-    def json(self) -> Dict[str, str]:
-        return json.loads(self.content)
-
-
-def test_wait_for_results(monkeypatch: Any) -> None:
-
-    job = MockJob()
-
-    monkeypatch.setattr(requests, "get", lambda *_, **__: MockResponse("Done"))
-    assert job._wait_for_results() == [{"status": "Done", "samples": None, "shots": 100}]
-
-    monkeypatch.setattr(requests, "get", lambda *_, **__: MockResponse("Error"))
-
-    with pytest.raises(qiskit.providers.JobError, match="API returned error"):
-        job._wait_for_results()
-
-    jobs = MockJobs()
-
-    monkeypatch.setattr(requests, "get", lambda *_, **__: MockResponse("Done"))
-    assert jobs._wait_for_results() == [
-        {"status": "Done", "samples": None, "shots": 100},
-        {"status": "Done", "samples": None, "shots": 100},
-    ]
-
-
-def test_result(monkeypatch: Any) -> None:
-    job = MockJob()
-
-    monkeypatch.setattr(requests, "get", lambda *_, **__: MockResponse("Done"))
-
-    expected_results = [{"success": True, "shots": 100, "data": {"counts": None}}]
+    expected_results = [{"success": True, "shots": 100, "data": {"counts": {"01": 100}}}]
 
     expected = qiskit.result.Result.from_dict(
         {
             "results": expected_results,
             "qobj_id": -1,
-            "backend_name": "superstaq_backend",
+            "backend_name": "ss_example_qpu",
             "backend_version": gss.API_VERSION,
             "success": True,
             "job_id": "123abc",
         }
     )
 
-    ans = job.result()
-
-    assert ans.backend_name == expected.backend_name
-    assert ans.job_id == expected.job_id
-
-
-def test_status(monkeypatch: Any) -> None:
-    job = MockJob()
-
-    monkeypatch.setattr(requests, "get", lambda *_, **__: MockResponse("Queued"))
-    assert job.status() == qiskit.providers.JobStatus.QUEUED
-
-    monkeypatch.setattr(requests, "get", lambda *_, **__: MockResponse("Running"))
-    assert job.status() == qiskit.providers.JobStatus.RUNNING
-
-    monkeypatch.setattr(requests, "get", lambda *_, **__: MockResponse("Done"))
-    assert job.status() == qiskit.providers.JobStatus.DONE
-
-
-def test_submit() -> None:
-    job = qss.SuperstaQJob(backend=MockDevice(), job_id="12345")
-    with pytest.raises(NotImplementedError, match="Submit through SuperstaQBackend"):
+    with mock.patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.get_job",
+        return_value=mock_response("Done"),
+    ):
+        ans = job.result()
+
+        assert ans.backend_name == expected.backend_name
+        assert ans.job_id == expected.job_id
+
+
+def test_check_if_stopped(backend: qss.SuperstaqBackend) -> None:
+
+    for status in ("Cancelled", "Failed"):
+        job = qss.SuperstaqJob(backend=backend, job_id="123abc")
+        job._overall_status = status
+        with pytest.raises(gss.SuperstaqUnsuccessfulJobException, match=status):
+            job._check_if_stopped()
+
+
+def test_refresh_job(backend: qss.SuperstaqBackend) -> None:
+    job = qss.SuperstaqJob(backend=backend, job_id="123abc,456abc,789abc")
+
+    with mock.patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.get_job",
+        return_value=mock_response("Queued"),
+    ):
+        job._refresh_job()
+        assert job._overall_status == "Queued"
+
+    with mock.patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.get_job",
+        return_value=mock_response("Running"),
+    ):
+        job._refresh_job()
+        assert job._overall_status == "Running"
+
+    with mock.patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.get_job",
+        return_value=mock_response("Done"),
+    ):
+        job._refresh_job()
+        assert job._overall_status == "Done"
+
+    job = qss.SuperstaqJob(backend=backend, job_id="321cba")
+    with mock.patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.get_job",
+        return_value=mock_response("Failed"),
+    ):
+        job._refresh_job()
+        assert job._overall_status == "Failed"
+
+    job = qss.SuperstaqJob(backend=backend, job_id="654cba")
+    with mock.patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.get_job",
+        return_value=mock_response("Cancelled"),
+    ):
+        job._refresh_job()
+        assert job._overall_status == "Cancelled"
+
+
+def test_update_status_queue_info(backend: qss.SuperstaqBackend) -> None:
+    job = qss.SuperstaqJob(backend=backend, job_id="123abc,456abc,789abc")
+
+    for job_id in job._job_id.split(","):
+        job._job_info[job_id] = mock_response("Done")
+
+    job._refresh_job()
+    assert job._overall_status == "Done"
+
+    mock_statuses = [
+        mock_response("Queued"),
+        mock_response("Cancelled"),
+        mock_response("Cancelled"),
+    ]
+    for index, job_id in enumerate(job._job_id.split(",")):
+        job._job_info[job_id] = mock_statuses[index]
+    job._update_status_queue_info()
+    assert job._overall_status == "Queued"
+
+    mock_statuses = [
+        mock_response("Cancelled"),
+        mock_response("Cancelled"),
+        mock_response("Queued"),
+    ]
+    for index, job_id in enumerate(job._job_id.split(",")):
+        job._job_info[job_id] = mock_statuses[index]
+    job._update_status_queue_info()
+    assert job._overall_status == "Queued"
+
+    mock_statuses = [mock_response("Done"), mock_response("Done"), mock_response("Failed")]
+    for index, job_id in enumerate(job._job_id.split(",")):
+        job._job_info[job_id] = mock_statuses[index]
+    job._update_status_queue_info()
+    assert job._overall_status == "Failed"
+
+
+def test_status(backend: qss.SuperstaqBackend) -> None:
+
+    job = qss.SuperstaqJob(backend=backend, job_id="123abc")
+
+    with mock.patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.get_job",
+        return_value=mock_response("Queued"),
+    ):
+        assert job.status() == qiskit.providers.JobStatus.QUEUED
+
+    with mock.patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.get_job",
+        return_value=mock_response("Running"),
+    ):
+        assert job.status() == qiskit.providers.JobStatus.RUNNING
+
+    with mock.patch(
+        "general_superstaq.superstaq_client._SuperstaqClient.get_job",
+        return_value=mock_response("Done"),
+    ):
+        assert job.status() == qiskit.providers.JobStatus.DONE
+
+    job = qss.SuperstaqJob(backend=backend, job_id="123done")
+    for status_msg in job.TERMINAL_STATES:
+        if status_msg == "Done":
+            job._overall_status = "Done"
+            assert job.status() == qiskit.providers.JobStatus.DONE
+        else:
+            job._overall_status = "Cancelled"
+            assert job.status() == qiskit.providers.JobStatus.CANCELLED
+
+
+def test_submit(backend: qss.SuperstaqBackend) -> None:
+    job = qss.SuperstaqJob(backend=backend, job_id="12345")
+    with pytest.raises(NotImplementedError, match="Submit through SuperstaqBackend"):
         job.submit()
 
 
-def test_eq() -> None:
-    job = qss.SuperstaQJob(backend=MockDevice(), job_id="12345")
+def test_eq(backend: qss.SuperstaqBackend) -> None:
+    job = qss.SuperstaqJob(backend=backend, job_id="12345")
     assert job != "super.tech"
 
-    job2 = qss.SuperstaQJob(backend=MockDevice(), job_id="123456")
+    job2 = qss.SuperstaqJob(backend=backend, job_id="123456")
     assert job != job2
 
-    job3 = qss.SuperstaQJob(backend=MockDevice(), job_id="12345")
+    job3 = qss.SuperstaqJob(backend=backend, job_id="12345")
     assert job == job3
```

## qiskit_superstaq/superstaq_provider.py

```diff
@@ -8,337 +8,370 @@
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
-import json
-import os
-from typing import Dict, List, Optional, Sequence, Tuple, Union
+import warnings
+from typing import Any, Dict, List, Mapping, Optional, Sequence, Tuple, Union
 
 import general_superstaq as gss
 import numpy as np
 import numpy.typing as npt
 import qiskit
-from general_superstaq import ResourceEstimate, finance, logistics, superstaq_client, user_config
 
 import qiskit_superstaq as qss
 
 
-class SuperstaQProvider(
-    qiskit.providers.ProviderV1, finance.Finance, logistics.Logistics, user_config.UserConfig
-):
-    """Provider for SuperstaQ backend.
+class SuperstaqProvider(qiskit.providers.ProviderV1, gss.user_config.UserConfig):
+    """Provider for Superstaq backend.
 
     Typical usage is:
 
     .. code-block:: python
 
         import qiskit_superstaq as qss
 
-        ss_provider = qss.SuperstaQProvider('MY_TOKEN')
+        ss_provider = qss.SuperstaqProvider('MY_TOKEN')
 
         backend = ss_provider.get_backend('target')
 
-    where `'MY_TOKEN'` is the access token provided by SuperstaQ,
-    and 'target' is the name of the desired backend.
-
-    Args:
-        api_key: A string key which allows access to the API. If this is None,
-            then this instance will use the environment variable  `SUPERSTAQ_API_KEY`. If that
-            variable is not set, then this will raise an `EnvironmentError`.
-        remote_host: The location of the API in the form of a URL. If this is None,
-            then this instance will use the environment variable `SUPERSTAQ_REMOTE_HOST`.
-            If that variable is not set, then this uses
-            `https://superstaq.super.tech/{api_version}`,
-            where `{api_version}` is the `api_version` specified below.
-        api_version: Version of the API.
-        max_retry_seconds: The number of seconds to retry calls for. Defaults to one hour.
-        verbose: Whether to print to stdio and stderr on retriable errors.
-    Raises:
-        EnvironmentError: if the `api_key` is None and has no corresponding environment
-            variable set.
+    where `MY_TOKEN` is the access token provided by Superstaq,
+    and `target` is the name of the desired backend.
     """
 
     def __init__(
         self,
         api_key: Optional[str] = None,
         remote_host: Optional[str] = None,
         api_version: str = gss.API_VERSION,
         max_retry_seconds: int = 3600,
         verbose: bool = False,
     ) -> None:
+        """Initializes a SuperstaqProvider.
+
+        Args:
+            api_key: A string that allows access to the Superstaq API. If no key is provided, then
+                this instance tries to use the environment variable `SUPERSTAQ_API_KEY`. If
+                `SUPERSTAQ_API_KEY` is not set, then this instance checks for the
+                following files:
+                - `$XDG_DATA_HOME/super.tech/superstaq_api_key`
+                - `$XDG_DATA_HOME/coldquanta/superstaq_api_key`
+                - `~/.super.tech/superstaq_api_key`
+                - `~/.coldquanta/superstaq_api_key`
+                If one of those files exists, then it is treated as a plain text file, and the first
+                line of this file is interpreted as an API key.  Failure to find an API key raises
+                an `EnvironmentError`.
+            remote_host: The location of the API in the form of a URL. If this is None,
+                then this instance will use the environment variable `SUPERSTAQ_REMOTE_HOST`.
+                If that variable is not set, then this uses
+                `https://superstaq.super.tech/{api_version}`,
+                where `{api_version}` is the `api_version` specified below.
+            api_version: The version of the API.
+            max_retry_seconds: The number of seconds to retry calls for. Defaults to one hour.
+            verbose: Whether to print to stdio and stderr on retriable errors.
+
+        Raises:
+            EnvironmentError: If an API key was not provided and could not be found.
+        """
         self._name = "superstaq_provider"
-        self.remote_host = remote_host or os.getenv("SUPERSTAQ_REMOTE_HOST") or gss.API_URL
-        api_key = api_key or os.getenv("SUPERSTAQ_API_KEY")
-        if not api_key:
-            raise EnvironmentError(
-                "Parameter api_key was not specified and the environment variable "
-                "SUPERSTAQ_API_KEY was also not set."
-            )
-        self.api_key: str = api_key
 
-        self._client = superstaq_client._SuperstaQClient(
+        self._client = gss.superstaq_client._SuperstaqClient(
             client_name="qiskit-superstaq",
-            remote_host=self.remote_host,
-            api_key=self.api_key,
+            remote_host=remote_host,
+            api_key=api_key,
             api_version=api_version,
             max_retry_seconds=max_retry_seconds,
             verbose=verbose,
         )
 
     def __str__(self) -> str:
-        return f"<SuperstaQProvider {self._name}>"
+        return f"<SuperstaqProvider {self._name}>"
 
     def __repr__(self) -> str:
-        repr1 = f"<SuperstaQProvider(api_key={self.api_key}, "
-        return repr1 + f"name={self._name})>"
+        return f"<SuperstaqProvider(api_key={self._client.api_key}, name={self._name})>"
 
-    def get_backend(self, target: str) -> "qss.SuperstaQBackend":
-        return qss.SuperstaQBackend(provider=self, remote_host=self.remote_host, target=target)
+    def get_backend(self, target: str) -> qss.SuperstaqBackend:
+        """Returns a Superstaq backend.
 
-    def get_access_token(self) -> str:
-        return self.api_key
+        Args:
+            target: A string containing the name of a target backend.
+
+        Returns:
+            A Superstaq backend.
+        """
+        return qss.SuperstaqBackend(provider=self, target=target)
 
-    def backends(self) -> List[qss.SuperstaQBackend]:
+    def backends(self) -> List[qss.SuperstaqBackend]:
+        """Lists the backends available from this provider.
+
+        Returns:
+            A list of Superstaq backends.
+        """
         targets = self._client.get_targets()["superstaq_targets"]
         backends = []
         for target in targets["compile-and-run"]:
             backends.append(self.get_backend(target))
         return backends
 
-    def _http_headers(self) -> Dict[str, str]:
-        return {
-            "Authorization": self.get_access_token(),
-            "Content-Type": "application/json",
-            "X-Client-Name": "qiskit-superstaq",
-            "X-Client-Version": gss.API_VERSION,
-        }
-
     def resource_estimate(
-        self, circuits: Union[qiskit.QuantumCircuit, List[qiskit.QuantumCircuit]], target: str
-    ) -> Union[ResourceEstimate, List[ResourceEstimate]]:
-        """Generates resource estimates for circuit(s).
+        self, circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]], target: str
+    ) -> Union[gss.ResourceEstimate, List[gss.ResourceEstimate]]:
+        """Generates resource estimates for qiskit circuit(s).
 
         Args:
-            circuits: qiskit QuantumCircuit(s).
-            target: string of target representing target device
+            circuits: The circuit(s) used during resource estimation.
+            target: A string containing the name of a target backend.
+
         Returns:
-            ResourceEstimate(s) containing resource costs (after compilation)
-            for running circuit(s) on target.
+            ResourceEstimate(s) containing resource costs (after compilation) for running circuit(s)
+            on a backend.
         """
-        serialized_circuits = qss.serialization.serialize_circuits(circuits)
-        circuit_is_list = not isinstance(circuits, qiskit.QuantumCircuit)
-
-        request_json = {
-            "qiskit_circuits": serialized_circuits,
-            "target": target,
-        }
-
-        json_dict = self._client.resource_estimate(request_json)
-
-        resource_estimates = [
-            ResourceEstimate(json_data=resource_estimate)
-            for resource_estimate in json_dict["resource_estimates"]
-        ]
-        if circuit_is_list:
-            return resource_estimates
-        return resource_estimates[0]
+        return self.get_backend(target).resource_estimate(circuits)
 
     def aqt_compile(
         self,
-        circuits: Union[qiskit.QuantumCircuit, List[qiskit.QuantumCircuit]],
+        circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]],
         target: str = "aqt_keysight_qpu",
-    ) -> "qss.compiler_output.CompilerOutput":
-        """Compiles the given circuit(s) to AQT device, optimized to its native gate set.
+        *,
+        num_eca_circuits: Optional[int] = None,
+        random_seed: Optional[int] = None,
+        atol: Optional[float] = None,
+        gate_defs: Optional[Mapping[str, Union[str, npt.NDArray[np.complex_], None]]] = None,
+        **kwargs: Any,
+    ) -> qss.compiler_output.CompilerOutput:
+        """Compiles and optimizes the given circuit(s) for the Advanced Quantum Testbed (AQT).
+
+        AQT is a superconducting transmon quantum computing testbed at Lawrence Berkeley National
+        Laboratory. More information can be found at https://aqt.lbl.gov.
+
+        Specifying a nonzero value for `num_eca_circuits` enables compilation with Equivalent
+        Circuit Averaging (ECA). See https://arxiv.org/abs/2111.04572 for a description of ECA.
 
         Args:
-            circuits: qiskit QuantumCircuit(s)
+            circuits: The circuit(s) to compile.
+            target: A string containing the name of a target AQT backend.
+            num_eca_circuits: Optional number of logically equivalent random circuits to generate
+                from each input circuit for Equivalent Circuit Averaging (ECA).
+            random_seed: Optional seed used for approximate synthesis and ECA.
+            atol: An optional tolerance to use for approximate gate synthesis.
+            gate_defs: An optional dictionary mapping names in qtrl configs to operations, where
+                each operation can be either a unitary matrix or None. More specific associations
+                take precedence, for example `{"SWAP": <matrix1>, "SWAP/C5C4": <matrix2>}` implies
+                `<matrix1>` for all "SWAP" calibrations except "SWAP/C5C4" (which will instead be
+                mapped to `<matrix2>` applied to qubits 4 and 5). Setting any calibration to None
+                will disable that calibration.
+            kwargs: Other desired compile options.
+
         Returns:
-            object whose .circuit(s) attribute is an optimized qiskit QuantumCircuit(s)
-            If qtrl is installed, the object's .seq attribute is a qtrl Sequence object of the
-            pulse sequence corresponding to the optimized qiskit.QuantumCircuit(s) and the
-            .pulse_list(s) attribute is the list(s) of cycles.
+            Object whose .circuit(s) attribute contains the optimized circuits(s). Alternatively for
+            ECA, an Object whose .circuits attribute is a list (or list of lists) of logically
+            equivalent circuits. If qtrl is installed, the object's .seq attribute is a qtrl
+            Sequence object containing pulse sequences for each compiled circuit, and its
+            .pulse_list(s) attribute contains the corresponding list(s) of cycles.
+
+        Raises:
+            ValueError: If `target` is not a valid AQT target.
         """
         if not target.startswith("aqt_"):
-            raise ValueError(f"{target} is not an AQT target")
+            raise ValueError(f"{target!r} is not a valid AQT target.")
 
-        serialized_circuits = qss.serialization.serialize_circuits(circuits)
-        circuits_is_list = not isinstance(circuits, qiskit.QuantumCircuit)
-
-        json_dict = self._client.aqt_compile(
-            {"qiskit_circuits": serialized_circuits, "target": target}
+        return self.get_backend(target).compile(
+            circuits,
+            num_eca_circuits=num_eca_circuits,
+            random_seed=random_seed,
+            atol=atol,
+            gate_defs=gate_defs,
+            **kwargs,
         )
 
-        return qss.compiler_output.read_json_aqt(json_dict, circuits_is_list)
-
     def aqt_compile_eca(
         self,
         circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]],
         num_equivalent_circuits: int,
         random_seed: Optional[int] = None,
         target: str = "aqt_keysight_qpu",
-    ) -> "qss.compiler_output.CompilerOutput":
-        """Compiles the given circuit(s) to target AQT device with Equivalent Circuit Averaging
-        (ECA).
+        atol: Optional[float] = None,
+        gate_defs: Optional[Mapping[str, Union[str, npt.NDArray[np.complex_], None]]] = None,
+        **kwargs: Any,
+    ) -> qss.compiler_output.CompilerOutput:
+        """Compiles and optimizes the given circuit(s) for the Advanced Quantum Testbed (AQT) at
+        Lawrence Berkeley National Laboratory using Equivalent Circuit Averaging (ECA).
 
         See arxiv.org/pdf/2111.04572.pdf for a description of ECA.
 
+        Note:
+            This method has been deprecated. Instead, use the `num_eca_circuits` argument of
+            `aqt_compile()`.
+
         Args:
-            circuits: qiskit QuantumCircuit(s) to compile.
-            num_equivalent_circuits: number of logically equivalent random circuits to generate for
+            circuits: The circuit(s) to compile.
+            num_equivalent_circuits: Number of logically equivalent random circuits to generate for
                 each input circuit.
-            random_seed: optional seed for circuit randomizer.
-            target: string of target AQT device.
+            random_seed: Optional seed for circuit randomizer.
+            target: A string containing the name of a target AQT backend.
+            atol: An optional tolerance to use for approximate gate synthesis.
+            gate_defs: An optional dictionary mapping names in qtrl configs to operations, where
+                each operation can be either a unitary matrix or None. More specific associations
+                take precedence, for example `{"SWAP": <matrix1>, "SWAP/C5C4": <matrix2>}` implies
+                `<matrix1>` for all "SWAP" calibrations except "SWAP/C5C4" (which will instead be
+                mapped to `<matrix2>` applied to qubits 4 and 5). Setting any calibration to None
+                will disable that calibration.
+            kwargs: Other desired aqt_compile_eca options.
+
         Returns:
-            object whose .circuits attribute is a list (or list of lists) of logically equivalent
-                QuantumCircuit(s).
+            Object whose .circuits attribute is a list (or list of lists) of logically equivalent
+            circuits. If qtrl is installed, the object's .seq attribute is a qtrl Sequence object
+            containing pulse sequences for each compiled circuit, and its .pulse_list(s) attribute
+            contains the corresponding list(s) of cycles.
 
-            If qtrl is installed, the object's .seq attribute is a qtrl Sequence object of the
-            pulse sequence corresponding to the QuantumCircuits and the .pulse_lists attribute is
-            the list(s) of cycles.
+        Raises:
+            ValueError: If `target` is not a valid AQT target.
         """
-        if not target.startswith("aqt_"):
-            raise ValueError(f"{target} is not an AQT target")
-
-        serialized_circuits = qss.serialization.serialize_circuits(circuits)
-        circuits_is_list = not isinstance(circuits, qiskit.QuantumCircuit)
+        warnings.warn(
+            "The `aqt_compile_eca()` method has been deprecated, and will be removed in a future "
+            "version of qiskit-superstaq. Instead, use the `num_eca_circuits` argument of "
+            "`aqt_compile()` to compile circuits for ECA.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
 
-        options_dict = {"num_eca_circuits": num_equivalent_circuits}
-        if random_seed is not None:
-            options_dict["random_seed"] = random_seed
-
-        request_json = {
-            "qiskit_circuits": serialized_circuits,
-            "target": target,
-            "options": json.dumps(options_dict),
-        }
-
-        json_dict = self._client.post_request("/aqt_compile", request_json)
-        return qss.compiler_output.read_json_aqt(
-            json_dict, circuits_is_list, num_equivalent_circuits
+        return self.aqt_compile(
+            circuits,
+            num_eca_circuits=num_equivalent_circuits,
+            random_seed=random_seed,
+            atol=atol,
+            gate_defs=gate_defs,
+            **kwargs,
         )
 
     def ibmq_compile(
         self,
-        circuits: Union[qiskit.QuantumCircuit, List[qiskit.QuantumCircuit]],
+        circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]],
         target: str = "ibmq_qasm_simulator",
-    ) -> "qss.compiler_output.CompilerOutput":
-        """Returns pulse schedule(s) for the given circuit(s) and target."""
+        **kwargs: Any,
+    ) -> qss.compiler_output.CompilerOutput:
+        """Returns pulse schedule(s) for the given qiskit circuit(s) and target.
 
-        if not target.startswith("ibmq_"):
-            raise ValueError(f"{target} is not an IBMQ target")
+        Args:
+            circuits: The circuit(s) to compile.
+            target: A string containing the name of a target IBMQ backend.
+            kwargs: Other desired ibmq_compile options.
 
-        serialized_circuits = qss.serialization.serialize_circuits(circuits)
+        Returns:
+            object whose .circuit(s) attribute is an optimized qiskit circuit(s).
 
-        json_dict = self._client.ibmq_compile(
-            {"qiskit_circuits": serialized_circuits, "target": target}
-        )
-        compiled_circuits = qss.serialization.deserialize_circuits(json_dict["qiskit_circuits"])
-        pulses = gss.serialization.deserialize(json_dict["pulses"])
+        Raises:
+            ValueError: If `target` is not a valid IBMQ target.
+        """
+        if not target.startswith("ibmq_"):
+            raise ValueError(f"{target!r} is not a valid IBMQ target.")
 
-        if isinstance(circuits, qiskit.QuantumCircuit):
-            return qss.compiler_output.CompilerOutput(
-                circuits=compiled_circuits[0], pulse_sequences=pulses[0]
-            )
-        return qss.compiler_output.CompilerOutput(
-            circuits=compiled_circuits, pulse_sequences=pulses
-        )
+        return self.get_backend(target).compile(circuits, **kwargs)
 
     def qscout_compile(
         self,
-        circuits: Union[qiskit.QuantumCircuit, List[qiskit.QuantumCircuit]],
-        mirror_swaps: bool = True,
+        circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]],
+        mirror_swaps: bool = False,
+        base_entangling_gate: str = "xx",
         target: str = "sandia_qscout_qpu",
-    ) -> "qss.compiler_output.CompilerOutput":
-        """Compiles the given circuit(s) to AQT device, optimized to its native gate set.
+        **kwargs: Any,
+    ) -> qss.compiler_output.CompilerOutput:
+        """Compiles and optimizes the given circuit(s) for the QSCOUT trapped-ion testbed at
+        Sandia National Laboratories [1].
+
+        Compiled circuits are returned as both `qiskit.QuantumCircuit` objects and corresponding
+        Jaqal [2] programs (strings).
+
+        References:
+            [1] S. M. Clark et al., *Engineering the Quantum Scientific Computing Open User
+                Testbed*, IEEE Transactions on Quantum Engineering Vol. 2, 3102832 (2021).
+                https://doi.org/10.1109/TQE.2021.3096480.
+            [2] B. Morrison, et al., *Just Another Quantum Assembly Language (Jaqal)*, 2020 IEEE
+                International Conference on Quantum Computing and Engineering (QCE), 402-408 (2020).
+                https://arxiv.org/abs/2008.08042.
 
         Args:
-            circuits: qiskit QuantumCircuit(s)
+            circuits: The circuit(s) to compile.
+            target: A string containing the name of a target backend.
+            mirror_swaps: Whether to use mirror swapping to reduce two-qubit gate overhead.
+            base_entangling_gate: The base entangling gate to use (either "xx" or "zz").
+            kwargs: Other desired qscout_compile options.
+
         Returns:
-            object whose .circuit(s) attribute is an optimized qiskit QuantumCircuit(s)
-            If qtrl is installed, the object's .seq attribute is a qtrl Sequence object of the
-            pulse sequence corresponding to the optimized qiskit.QuantumCircuit(s) and the
-            .pulse_list(s) attribute is the list(s) of cycles.
+            Object whose .circuit(s) attribute contains optimized `qiskit QuantumCircuit`(s), and
+            `.jaqal_program(s)` attribute contains the corresponding Jaqal program(s).
+
+        Raises:
+            ValueError: If `target` is not a valid Sandia target.
+            ValueError: If `base_entangling_gate` is not a valid gate option.
         """
         if not target.startswith("sandia_"):
-            raise ValueError(f"{target} is not a QSCOUT target")
+            raise ValueError(f"{target!r} is not a valid Sandia target.")
 
-        qss.superstaq_backend.validate_target(target)
-
-        serialized_circuits = qss.serialization.serialize_circuits(circuits)
-        circuits_is_list = not isinstance(circuits, qiskit.QuantumCircuit)
-        options_dict = {"mirror_swaps": mirror_swaps}
-        json_dict = self._client.qscout_compile(
-            {
-                "qiskit_circuits": serialized_circuits,
-                "target": target,
-                "options": json.dumps(options_dict),
-            }
+        return self.get_backend(target).compile(
+            circuits, mirror_swaps=mirror_swaps, base_entangling_gate=base_entangling_gate, **kwargs
         )
-        return qss.compiler_output.read_json_qscout(json_dict, circuits_is_list)
 
     def cq_compile(
         self,
-        circuits: Union[qiskit.QuantumCircuit, List[qiskit.QuantumCircuit]],
+        circuits: Union[qiskit.QuantumCircuit, Sequence[qiskit.QuantumCircuit]],
         target: str = "cq_hilbert_qpu",
-    ) -> "qss.compiler_output.CompilerOutput":
+        **kwargs: Any,
+    ) -> qss.compiler_output.CompilerOutput:
         """Compiles the given circuit(s) to CQ device, optimized to its native gate set.
 
         Args:
-            circuits: qiskit QuantumCircuit(s)
-            target: the hardware to compile for
+            circuits: The circuit(s) to compile.
+            target: A string containing the name of a target backend.
+            kwargs: Other desired cq_compile options.
+
         Returns:
-            object whose .circuit(s) attribute is an optimized qiskit QuantumCircuit(s)
+            object whose .circuit(s) attribute is an optimized qiskit circuit(s).
+
+        Raises:
+            ValueError: If `target` is not a valid CQ target.
         """
         if not target.startswith("cq_"):
-            raise ValueError(f"{target} is not a CQ target")
+            raise ValueError(f"{target!r} is not a valid CQ target.")
 
-        qss.superstaq_backend.validate_target(target)
+        return self.get_backend(target).compile(circuits, **kwargs)
 
-        serialized_circuits = qss.serialization.serialize_circuits(circuits)
-        circuits_is_list = not isinstance(circuits, qiskit.QuantumCircuit)
-        json_dict = self._client.cq_compile(
-            {"qiskit_circuits": serialized_circuits, "target": target}
-        )
+    def supercheq(
+        self, files: List[List[int]], num_qubits: int, depth: int
+    ) -> Tuple[List[qiskit.QuantumCircuit], npt.NDArray[np.float_]]:
+        """Returns Supercheq randomly generated circuits and the corresponding fidelity matrices.
 
-        return qss.compiler_output.read_json_only_circuits(json_dict, circuits_is_list)
+        References:
+            [1] P. Gokhale et al., *SupercheQ: Quantum Advantage for Distributed Databases*, (2022).
+                https://arxiv.org/abs/2212.03850.
 
-    def neutral_atom_compile(
-        self,
-        circuits: Union[qiskit.QuantumCircuit, List[qiskit.QuantumCircuit]],
-        target: str = "neutral_atom_qpu",
-    ) -> Union[qiskit.QuantumCircuit, List[qiskit.QuantumCircuit]]:
-        """Returns pulse schedule for the given circuit and target.
+        Args:
+            files: A list of files specified as binary using ints.
+                For example: [[1, 0, 1], [1, 1, 1]].
+            num_qubits: The number of qubits to run Supercheq on.
+            depth: The depth of the circuits to run Supercheq on.
 
-        Pulser must be installed for returned object to correctly deserialize to a pulse schedule.
+        Returns:
+            A tuple containing a list of `qiskit.QuantumCircuit`s and a list of corresponding
+                fidelity matrices.
         """
-        if not (target.startswith("neutral_") or target.startswith("cq_")):
-            raise ValueError(f"{target} is not a Neutral Atom Compiler target")
-
-        qss.superstaq_backend.validate_target(target)
-
-        serialized_circuits = qss.serialization.serialize_circuits(circuits)
-
-        json_dict = self._client.neutral_atom_compile(
-            {"qiskit_circuits": serialized_circuits, "target": target}
-        )
-        try:
-            pulses = gss.serialization.deserialize(json_dict["pulses"])
-        except ModuleNotFoundError as e:
-            raise gss.SuperstaQModuleNotFoundException(
-                name=str(e.name), context="neutral_atom_compile"
-            )
-
-        if isinstance(circuits, qiskit.QuantumCircuit):
-            return pulses[0]
-        return pulses
-
-    def supercheq(
-        self, files: List[List[int]], num_qubits: int, depth: int
-    ) -> Tuple[List[qiskit.QuantumCircuit], npt.NDArray[np.float_]]:
-        """Docstring."""
         json_dict = self._client.supercheq(files, num_qubits, depth, "qiskit_circuits")
         circuits = qss.serialization.deserialize_circuits(json_dict["qiskit_circuits"])
         fidelities = gss.serialization.deserialize(json_dict["fidelities"])
         return circuits, fidelities
+
+    def target_info(self, target: str) -> Dict[str, Any]:
+        """Returns information about the device specified by `target`.
+
+        Args:
+            target: A string containing the name of a target backend.
+
+        Returns:
+            Information about a target backend.
+        """
+        return self._client.target_info(target)["target_info"]
+
+    def get_targets(self) -> Dict[str, Any]:
+        """Gets list of available targets."""
+        return self._client.get_targets()["superstaq_targets"]
```

## qiskit_superstaq/superstaq_provider_test.py

```diff
@@ -1,7 +1,8 @@
+# pylint: disable=missing-function-docstring
 import json
 import os
 import textwrap
 from unittest import mock
 from unittest.mock import MagicMock, patch
 
 import general_superstaq as gss
@@ -11,30 +12,26 @@
 from general_superstaq import ResourceEstimate
 
 import qiskit_superstaq as qss
 
 
 @patch.dict(os.environ, {"SUPERSTAQ_API_KEY": ""})
 def test_provider() -> None:
-    ss_provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
+    ss_provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
 
-    with pytest.raises(EnvironmentError, match="api_key was not "):
-        qss.SuperstaQProvider()
+    with pytest.raises(EnvironmentError, match="Superstaq API key not specified and not found."):
+        qss.SuperstaqProvider()
 
     assert str(ss_provider.get_backend("ibmq_qasm_simulator")) == str(
-        qss.SuperstaQBackend(
-            provider=ss_provider,
-            remote_host=gss.API_URL,
-            target="ibmq_qasm_simulator",
-        )
+        qss.SuperstaqBackend(provider=ss_provider, target="ibmq_qasm_simulator")
     )
 
-    assert str(ss_provider) == "<SuperstaQProvider superstaq_provider>"
+    assert str(ss_provider) == "<SuperstaqProvider superstaq_provider>"
 
-    assert repr(ss_provider) == "<SuperstaQProvider(api_key=MY_TOKEN, name=superstaq_provider)>"
+    assert repr(ss_provider) == "<SuperstaqProvider(api_key=MY_TOKEN, name=superstaq_provider)>"
 
     targets = {
         "superstaq_targets": {
             "compile-and-run": [
                 "ibmq_qasm_simulator",
                 "ibmq_armonk_qpu",
                 "ibmq_santiago_qpu",
@@ -55,146 +52,170 @@
             ],
             "compile-only": ["aqt_keysight_qpu", "sandia_qscout_qpu"],
         }
     }
 
     expected_backends = []
     for target in targets["superstaq_targets"]["compile-and-run"]:
-        expected_backends.append(
-            qss.SuperstaQBackend(provider=ss_provider, remote_host=gss.API_URL, target=target)
-        )
+        expected_backends.append(qss.SuperstaqBackend(provider=ss_provider, target=target))
 
     mock_client = MagicMock()
     mock_client.get_targets.return_value = targets
     ss_provider._client = mock_client
     assert ss_provider.backends() == expected_backends
 
 
 @patch.dict(os.environ, {"SUPERSTAQ_API_KEY": ""})
 def test_get_balance() -> None:
-    ss_provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
+    ss_provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
     mock_client = MagicMock()
     mock_client.get_balance.return_value = {"balance": 12345.6789}
     ss_provider._client = mock_client
 
     assert ss_provider.get_balance() == "$12,345.68"
     assert ss_provider.get_balance(pretty_output=False) == 12345.6789
 
 
 @patch("requests.post")
 def test_aqt_compile(mock_post: MagicMock) -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
 
     qc = qiskit.QuantumCircuit(8)
     qc.cz(4, 5)
 
     mock_post.return_value.json = lambda: {
         "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": "[[[1, 4]]]",
         "state_jp": gss.serialization.serialize({}),
         "pulse_lists_jp": gss.serialization.serialize([[[]]]),
     }
     out = provider.aqt_compile(qc)
     assert out.circuit == qc
+    assert out.final_logical_to_physical == {1: 4}
     assert not hasattr(out, "circuits") and not hasattr(out, "pulse_lists")
 
-    out = provider.aqt_compile([qc])
+    out = provider.aqt_compile([qc], atol=1e-2)
     assert out.circuits == [qc]
+    assert out.final_logical_to_physicals == [{1: 4}]
     assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
 
     mock_post.return_value.json = lambda: {
         "qiskit_circuits": qss.serialization.serialize_circuits([qc, qc]),
+        "final_logical_to_physicals": "[[], []]",
         "state_jp": gss.serialization.serialize({}),
         "pulse_lists_jp": gss.serialization.serialize([[[]], [[]]]),
     }
-    out = provider.aqt_compile([qc, qc])
+    out = provider.aqt_compile([qc, qc], test_options="yes")
     assert out.circuits == [qc, qc]
+    assert out.final_logical_to_physicals == [{}, {}]
     assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
 
 
-def test_invalid_target_service_aqt_compile() -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
-    with pytest.raises(ValueError, match="not an AQT target"):
-        provider.aqt_compile(qiskit.QuantumCircuit(), target="invalid_target")
+def test_invalid_target_aqt_compile() -> None:
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
+    with pytest.raises(ValueError, match="'ss_example_qpu' is not a valid AQT target."):
+        provider.aqt_compile(qiskit.QuantumCircuit(), target="ss_example_qpu")
 
 
 @patch("requests.post")
-def test_service_aqt_compile_eca(mock_post: MagicMock) -> None:
-    provider = qss.superstaq_provider.SuperstaQProvider(api_key="MY_TOKEN")
+def test_aqt_compile_eca(mock_post: MagicMock) -> None:
+    provider = qss.superstaq_provider.SuperstaqProvider(api_key="MY_TOKEN")
 
     qc = qiskit.QuantumCircuit(8)
     qc.cz(4, 5)
 
     mock_post.return_value.json = lambda: {
         "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": "[[]]",
         "state_jp": gss.serialization.serialize({}),
         "pulse_lists_jp": gss.serialization.serialize([[[]]]),
     }
 
-    out = provider.aqt_compile_eca(qc, num_equivalent_circuits=1, random_seed=1234)
+    out = provider.aqt_compile(qc, num_eca_circuits=1, random_seed=1234, atol=1e-2)
     assert out.circuits == [qc]
-    assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
-
-
-def test_invalid_target_service_aqt_compile_eca() -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
-    with pytest.raises(ValueError, match="not an AQT target"):
-        provider.aqt_compile_eca(
-            qiskit.QuantumCircuit(), num_equivalent_circuits=1, target="invalid_target"
+    assert out.final_logical_to_physicals == [{}]
+    assert not hasattr(out, "circuit")
+    assert not hasattr(out, "pulse_list")
+    assert not hasattr(out, "final_logical_to_physical")
+
+    out = provider.aqt_compile([qc], num_eca_circuits=1, random_seed=1234, atol=1e-2)
+    assert out.circuits == [[qc]]
+    assert out.final_logical_to_physicals == [[{}]]
+
+    with pytest.warns(DeprecationWarning, match="has been deprecated"):
+        deprecated_out = provider.aqt_compile_eca(
+            [qc], num_equivalent_circuits=1, random_seed=1234, atol=1e-2
         )
+        assert deprecated_out.circuits == out.circuits
+        assert deprecated_out.final_logical_to_physicals == out.final_logical_to_physicals
 
 
-@patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.ibmq_compile",
-)
-def test_service_ibmq_compile(mock_ibmq_compile: MagicMock) -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
+@patch("requests.post")
+def test_ibmq_compile(mock_post: MagicMock) -> None:
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
     qc = qiskit.QuantumCircuit(8)
     qc.cz(4, 5)
-    mock_ibmq_compile.return_value = {
+    final_logical_to_physical = {0: 4, 1: 5}
+    mock_post.return_value.json = lambda: {
         "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": json.dumps([list(final_logical_to_physical.items())]),
         "pulses": gss.serialization.serialize([mock.DEFAULT]),
     }
 
-    assert provider.ibmq_compile(qiskit.QuantumCircuit()) == qss.compiler_output.CompilerOutput(
-        qc, mock.DEFAULT
+    assert provider.ibmq_compile(
+        qiskit.QuantumCircuit(), test_options="yes"
+    ) == qss.compiler_output.CompilerOutput(
+        qc, final_logical_to_physical, pulse_sequences=mock.DEFAULT
     )
     assert provider.ibmq_compile([qiskit.QuantumCircuit()]) == qss.compiler_output.CompilerOutput(
-        [qc], [mock.DEFAULT]
+        [qc], [final_logical_to_physical], pulse_sequences=[mock.DEFAULT]
     )
 
+    mock_post.return_value.json = lambda: {
+        "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": json.dumps([list(final_logical_to_physical.items())]),
+    }
 
-def test_invalid_target_service_ibmq_compile() -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
-    with pytest.raises(ValueError, match="not an IBMQ target"):
-        provider.ibmq_compile(qiskit.QuantumCircuit(), target="invalid_target")
+    assert provider.ibmq_compile(
+        qiskit.QuantumCircuit(), test_options="yes"
+    ) == qss.compiler_output.CompilerOutput(qc, final_logical_to_physical, pulse_sequences=None)
+    assert provider.ibmq_compile([qiskit.QuantumCircuit()]) == qss.compiler_output.CompilerOutput(
+        [qc], [final_logical_to_physical], pulse_sequences=None
+    )
+
+
+def test_invalid_target_ibmq_compile() -> None:
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
+    with pytest.raises(ValueError, match="'ss_example_qpu' is not a valid IBMQ target."):
+        provider.ibmq_compile(qiskit.QuantumCircuit(), target="ss_example_qpu")
 
 
 @patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.resource_estimate",
+    "general_superstaq.superstaq_client._SuperstaqClient.resource_estimate",
 )
-def test_service_resource_estimate(mock_resource_estimate: MagicMock) -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
+def test_resource_estimate(mock_resource_estimate: MagicMock) -> None:
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
 
     resource_estimate = ResourceEstimate(0, 1, 2)
 
     mock_resource_estimate.return_value = {
         "resource_estimates": [{"num_single_qubit_gates": 0, "num_two_qubit_gates": 1, "depth": 2}]
     }
 
     assert (
         provider.resource_estimate(qiskit.QuantumCircuit(), "ibmq_qasm_simulator")
         == resource_estimate
     )
 
 
 @patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.resource_estimate",
+    "general_superstaq.superstaq_client._SuperstaqClient.resource_estimate",
 )
-def test_service_resource_estimate_list(mock_resource_estimate: MagicMock) -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
+def test_resource_estimate_list(mock_resource_estimate: MagicMock) -> None:
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
 
     resource_estimates = [ResourceEstimate(0, 1, 2), ResourceEstimate(3, 4, 5)]
 
     mock_resource_estimate.return_value = {
         "resource_estimates": [
             {"num_single_qubit_gates": 0, "num_two_qubit_gates": 1, "depth": 2},
             {"num_single_qubit_gates": 3, "num_two_qubit_gates": 4, "depth": 5},
@@ -205,15 +226,15 @@
         provider.resource_estimate([qiskit.QuantumCircuit()], "ibmq_qasm_simulator")
         == resource_estimates
     )
 
 
 @patch("requests.post")
 def test_qscout_compile(mock_post: MagicMock) -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
 
     qc = qiskit.QuantumCircuit(1)
     qc.h(0)
 
     jaqal_program = textwrap.dedent(
         """\
         register allqubits[1]
@@ -223,109 +244,177 @@
         Rz allqubits[0] -3.141592653589793
         measure_all
         """
     )
 
     mock_post.return_value.json = lambda: {
         "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": json.dumps([[(0, 13)]]),
         "jaqal_programs": [jaqal_program],
     }
-    out = provider.qscout_compile(qc)
+    out = provider.qscout_compile(qc, test_options="yes")
     assert out.circuit == qc
+    assert out.final_logical_to_physical == {0: 13}
 
     out = provider.qscout_compile([qc])
     assert out.circuits == [qc]
+    assert out.final_logical_to_physicals == [{0: 13}]
 
     mock_post.return_value.json = lambda: {
         "qiskit_circuits": qss.serialization.serialize_circuits([qc, qc]),
+        "final_logical_to_physicals": json.dumps([[(0, 13)], [(0, 13)]]),
         "jaqal_programs": [jaqal_program, jaqal_program],
     }
     out = provider.qscout_compile([qc, qc])
     assert out.circuits == [qc, qc]
+    assert out.final_logical_to_physicals == [{0: 13}, {0: 13}]
 
 
-def test_invalid_target_service_qscout_compile() -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
-    with pytest.raises(ValueError, match="not a QSCOUT target"):
-        provider.qscout_compile(qiskit.QuantumCircuit(), target="invalid_target")
+def test_invalid_target_qscout_compile() -> None:
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
+    with pytest.raises(ValueError, match="'ss_example_qpu' is not a valid Sandia target."):
+        provider.qscout_compile(qiskit.QuantumCircuit(), target="ss_example_qpu")
 
 
 @patch("requests.post")
 @pytest.mark.parametrize("mirror_swaps", (True, False))
 def test_qscout_compile_swap_mirror(mock_post: MagicMock, mirror_swaps: bool) -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
 
     qc = qiskit.QuantumCircuit()
 
     mock_post.return_value.json = lambda: {
         "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": json.dumps([[(0, 13)]]),
         "jaqal_programs": [""],
     }
     _ = provider.qscout_compile(qc, mirror_swaps=mirror_swaps)
     mock_post.assert_called_once()
     _, kwargs = mock_post.call_args
-    assert json.loads(kwargs["json"]["options"]) == {"mirror_swaps": mirror_swaps}
+    assert json.loads(kwargs["json"]["options"]) == {
+        "mirror_swaps": mirror_swaps,
+        "base_entangling_gate": "xx",
+    }
+
+
+@patch("requests.post")
+@pytest.mark.parametrize("base_entangling_gate", ("xx", "zz"))
+def test_qscout_compile_change_entangler(mock_post: MagicMock, base_entangling_gate: str) -> None:
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
+
+    qc = qiskit.QuantumCircuit()
+
+    mock_post.return_value.json = lambda: {
+        "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": "[[]]",
+        "jaqal_programs": [""],
+    }
+    _ = provider.qscout_compile(qc, base_entangling_gate=base_entangling_gate)
+    mock_post.assert_called_once()
+    _, kwargs = mock_post.call_args
+    assert json.loads(kwargs["json"]["options"]) == {
+        "mirror_swaps": False,
+        "base_entangling_gate": base_entangling_gate,
+    }
+
+
+@patch("requests.post")
+def test_qscout_compile_wrong_entangler(mock_post: MagicMock) -> None:
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
+
+    qc = qiskit.QuantumCircuit()
+
+    with pytest.raises(ValueError):
+        _ = provider.qscout_compile(qc, base_entangling_gate="yy")
 
 
 @patch("requests.post")
 def test_cq_compile(mock_post: MagicMock) -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
 
     qc = qiskit.QuantumCircuit(1)
     qc.h(0)
 
     mock_post.return_value.json = lambda: {
-        "qiskit_circuits": qss.serialization.serialize_circuits(qc)
+        "qiskit_circuits": qss.serialization.serialize_circuits(qc),
+        "final_logical_to_physicals": "[[[3, 0]]]",
     }
-    out = provider.cq_compile(qc)
+    out = provider.cq_compile(qc, test_options="yes")
     assert out.circuit == qc
+    assert out.final_logical_to_physical == {3: 0}
 
     out = provider.cq_compile([qc])
     assert out.circuits == [qc]
+    assert out.final_logical_to_physicals == [{3: 0}]
 
     mock_post.return_value.json = lambda: {
-        "qiskit_circuits": qss.serialization.serialize_circuits([qc, qc])
+        "qiskit_circuits": qss.serialization.serialize_circuits([qc, qc]),
+        "final_logical_to_physicals": "[[], []]",
     }
     out = provider.cq_compile([qc, qc])
     assert out.circuits == [qc, qc]
+    assert out.final_logical_to_physicals == [{}, {}]
 
 
-def test_invalid_target_service_cq_compile() -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
-    with pytest.raises(ValueError, match="not a CQ target"):
-        provider.cq_compile(qiskit.QuantumCircuit(), target="invalid_target")
-
-
-@patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.neutral_atom_compile",
-    return_value={"pulses": gss.serialization.serialize([mock.DEFAULT])},
-)
-def test_neutral_atom_compile(mock_ibmq_compile: MagicMock) -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
-    assert provider.neutral_atom_compile(qiskit.QuantumCircuit()) == mock.DEFAULT
-    assert provider.neutral_atom_compile([qiskit.QuantumCircuit()]) == [mock.DEFAULT]
-
-    with mock.patch.dict("sys.modules", {"unittest": None}), pytest.raises(
-        gss.SuperstaQModuleNotFoundException,
-        match="'neutral_atom_compile' requires module 'unittest'",
-    ):
-        _ = provider.neutral_atom_compile(qiskit.QuantumCircuit())
-
-
-def test_invalid_target_service_neutral_atom_compile() -> None:
-    provider = qss.SuperstaQProvider(api_key="MY_TOKEN")
-    with pytest.raises(ValueError, match="not a Neutral Atom Compiler target"):
-        provider.neutral_atom_compile(qiskit.QuantumCircuit(), target="invalid_target")
+def test_invalid_target_cq_compile() -> None:
+    provider = qss.SuperstaqProvider(api_key="MY_TOKEN")
+    with pytest.raises(ValueError, match="'ss_example_qpu' is not a valid CQ target."):
+        provider.cq_compile(qiskit.QuantumCircuit(), target="ss_example_qpu")
 
 
 @mock.patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.supercheq",
+    "general_superstaq.superstaq_client._SuperstaqClient.supercheq",
 )
-def test_service_supercheq(mock_supercheq: mock.MagicMock) -> None:
-    service = qss.SuperstaQProvider(api_key="key")
+def test_supercheq(mock_supercheq: mock.MagicMock) -> None:
+    provider = qss.SuperstaqProvider(api_key="key")
     circuits = [qiskit.QuantumCircuit()]
     fidelities = np.array([1])
     mock_supercheq.return_value = {
         "qiskit_circuits": qss.serialization.serialize_circuits(circuits),
+        "final_logical_to_physicals": "[[]]",
         "fidelities": gss.serialization.serialize(fidelities),
     }
-    assert service.supercheq([[0]], 1, 1) == (circuits, fidelities)
+    assert provider.supercheq([[0]], 1, 1) == (circuits, fidelities)
+
+
+@patch("requests.post")
+def test_target_info(mock_post: MagicMock) -> None:
+    provider = qss.SuperstaqProvider(api_key="key")
+    fake_data = {"target_info": {"backend_name": "ss_example_qpu", "max_experiments": 1234}}
+    mock_post.return_value.json = lambda: fake_data
+    assert provider.target_info("ss_example_qpu") == fake_data["target_info"]
+
+
+def test_get_targets() -> None:
+    provider = qss.SuperstaqProvider(api_key="key", remote_host="http://example.com")
+    mock_client = mock.MagicMock()
+    targets = {
+        "superstaq_targets": {
+            "compile-and-run": [
+                "ibmq_qasm_simulator",
+                "ibmq_armonk_qpu",
+                "ibmq_santiago_qpu",
+                "ibmq_bogota_qpu",
+                "ibmq_lima_qpu",
+                "ibmq_belem_qpu",
+                "ibmq_quito_qpu",
+                "ibmq_statevector_simulator",
+                "ibmq_mps_simulator",
+                "ibmq_extended-stabilizer_simulator",
+                "ibmq_stabilizer_simulator",
+                "ibmq_manila_qpu",
+                "aws_dm1_simulator",
+                "aws_sv1_simulator",
+                "d-wave_advantage-system4.1_qpu",
+                "d-wave_dw-2000q-6_qpu",
+                "aws_tn1_simulator",
+                "rigetti_aspen-9_qpu",
+                "d-wave_advantage-system1.1_qpu",
+                "ionq_ion_qpu",
+            ],
+            "compile-only": ["aqt_keysight_qpu", "aqt_zurich_qpu", "sandia_qscout_qpu"],
+        }
+    }
+    mock_client.get_targets.return_value = targets
+    provider._client = mock_client
+
+    assert provider.get_targets() == targets["superstaq_targets"]
```

## Comparing `qiskit_superstaq-0.3.9.dist-info/METADATA` & `qiskit_superstaq-0.4.0.dist-info/METADATA`

 * *Files 16% similar despite different names*

```diff
@@ -1,70 +1,65 @@
 Metadata-Version: 2.1
 Name: qiskit-superstaq
-Version: 0.3.9
-Summary: The Qiskit module that provides tools and access to SuperstaQ
-Home-page: https://github.com/SupertechLabs/qiskit-superstaq
-Author: Super.tech
-Author-email: pranav@super.tech
+Version: 0.4.0
+Summary: The Qiskit module that provides tools and access to Superstaq
+Home-page: https://github.com/Infleqtion/client-superstaq
+Author: Superstaq development team
+Author-email: superstaq@infleqtion.com
 License: Apache 2
 Platform: UNKNOWN
-Requires-Python: >=3.7.0
+Requires-Python: >=3.8.0
 Description-Content-Type: text/markdown
-Requires-Dist: general-superstaq (~=0.3.4)
+Requires-Dist: general-superstaq (~=0.4.0)
 Requires-Dist: matplotlib (~=3.0)
-Requires-Dist: qiskit (<0.37.0,>=0.35.0)
+Requires-Dist: qiskit (>=0.40.0)
+Requires-Dist: symengine (<0.10.0)
 Provides-Extra: dev
-Requires-Dist: general-superstaq[dev] (~=0.3.4) ; extra == 'dev'
+Requires-Dist: general-superstaq[dev] (~=0.4.0) ; extra == 'dev'
 Provides-Extra: examples
 Requires-Dist: notebook (~=6.4.12) ; extra == 'examples'
-Requires-Dist: pulser (~=0.7.0) ; extra == 'examples'
+Requires-Dist: pylatexenc ; extra == 'examples'
 
-![qiskit-superstaq's default workflow](https://github.com/SupertechLabs/qiskit-superstaq/actions/workflows/ci.yml/badge.svg)
+![qiskit-superstaq's default workflow](https://github.com/Infleqtion/client-superstaq/actions/workflows/ci.yml/badge.svg)
 
-This package is used to access SuperstaQ via a Web API through [Qiskit](https://qiskit.org/). Qiskit programmers
+This package is used to access Superstaq via a Web API through [Qiskit](https://qiskit.org/). Qiskit programmers
 can take advantage of the applications, pulse level optimizations, and write-once-target-all
-features of SuperstaQ with this package.
+features of Superstaq with this package.
 
 
-Please note that Python version `3.7` or higher is required. qiskit-superstaq and all of its
+Please note that Python version `3.8` or higher is required. `qiskit-superstaq` and all of its
 dependencies can be installed via:
 
 ```
 python3 -m venv venv_qiskit_superstaq
 source venv_qiskit_superstaq/bin/activate
 pip install qiskit-superstaq
 
 # Run the following to install dev requirements (required if you intend to run checks locally)
 pip install .[dev]
-
-# Run the following to install neutral atom device dependencies.
-pip install -r neutral-atom-requirements.txt
 ```
 
 ### Creating and submitting a circuit through qiskit-superstaq
 ```python3
 
 import qiskit
 import qiskit_superstaq as qss
 
 token = "Insert superstaq token that you received from https://superstaq.super.tech"
 
-superstaq = qss.superstaq_provider.SuperstaQProvider(
-    token,
-    remote_host=qss.API_URL,
-)
+superstaq = qss.superstaq_provider.SuperstaqProvider(token)
 
 backend = superstaq.get_backend("ibmq_qasm_simulator")
 qc = qiskit.QuantumCircuit(2, 2)
 qc.h(0)
 qc.cx(0, 1)
 qc.measure(0, 0)
 qc.measure(1, 1)
 
 print(qc)
 
-# Submitting a circuit to "ibmq_qasm_simulator". Providing the "dry-run" method parameter instructs SuperstaQ to simulate the circuit, and is available to free trial users.
+# Submitting a circuit to "ibmq_qasm_simulator". Providing the "dry-run" method parameter instructs Superstaq to simulate the circuit, and is available to free trial users.
 job = backend.run(qc, shots=100, method="dry-run")
 print(job.result().get_counts())
 ```
```

## Comparing `qiskit_superstaq-0.3.9.dist-info/RECORD` & `qiskit_superstaq-0.4.0.dist-info/RECORD`

 * *Files 26% similar despite different names*

```diff
@@ -1,22 +1,23 @@
-qiskit_superstaq/__init__.py,sha256=EhvrvYHq8bYDmwG55ZDfz61hwTirlgB_VOFo86soiEs,645
-qiskit_superstaq/_version.py,sha256=xmkmdvq15kb61xdtCoa1YARnvHBnUgI-0GWIJYvHNeA,22
-qiskit_superstaq/_version_test.py,sha256=gacKBlXolNazGYXflSgUHChZZ6QiEtdb1RKzAyOHg-g,245
-qiskit_superstaq/compiler_output.py,sha256=97itclyfOQ0vg4JN9RSEI9VupgcZ5pH6wsgIXO7i4q4,7720
-qiskit_superstaq/compiler_output_test.py,sha256=GaOCOc_qgfXK0WmmJ6bDzuhhVHkzZVUPGb0r_7d4ztY,7102
-qiskit_superstaq/custom_gates.py,sha256=OMBOSzJAtBdJdcvj5cSm4HFa-FNLY0yN2lVh1uLNyUY,12754
-qiskit_superstaq/custom_gates_test.py,sha256=B8gp6_2GySK-iyu7Q2k3MajDMlVjFVN0mM6g9GKbI7Q,8614
-qiskit_superstaq/daily_integration_test.py,sha256=M7Q-CnjesHwVajzEDWojef_EVJEpdfsrV-9UlpEKggc,7750
+qiskit_superstaq/__init__.py,sha256=PWFiqfQ4XZub2Kmity9E0pfGNv3uBLJ6w0_UCQHTTCk,918
+qiskit_superstaq/_version.py,sha256=42STGor_9nKYXumfeV5tiyD_M8VdcddX7CEexmibPBk,22
+qiskit_superstaq/_version_test.py,sha256=L74txQGUT3Wnz2MxCtCQfogANHrr04OiXGKHuCgn5TU,290
+qiskit_superstaq/compiler_output.py,sha256=XY7nmbGFtb_dUT-EPc_avG3zEyz4kKObjdHmEdZAUL8,12027
+qiskit_superstaq/compiler_output_test.py,sha256=tcHC7KsTehDy_FYoVlsdx0t56JdZr3GHFLloTp7P5MY,9574
+qiskit_superstaq/custom_gates.py,sha256=SvxGFgwcO2y4ADxqKLnqcGaSFozGg1z9iINxRFZ1GKk,18928
+qiskit_superstaq/custom_gates_test.py,sha256=d0R95TpPFbO6m9aKv1MutWla5Jo9VaJflC5d0Biam6U,9858
+qiskit_superstaq/daily_integration_test.py,sha256=vNC-iLcmeJTa3tz-CkXsxFdK1qL2npD_f_CTjnWhsh0,8418
 qiskit_superstaq/py.typed,sha256=2DnKRKK8fmvD_m6TmNUqVJZBNb2xKGaCjcHkkVpRsMc,68
-qiskit_superstaq/serialization.py,sha256=FVA4o0oXTvS6epcesBcawj1Fp32qOsIRXhEkfEtQWiY,3544
-qiskit_superstaq/serialization_test.py,sha256=dUEhoaP_EHOBYAHl9edhBUaPhO2HyWufaL5uHdzlils,3791
-qiskit_superstaq/superstaq_backend.py,sha256=RbP9kvmbX8fU0zB4-hG7_3TRPpHr3BFw9LhF0zRu8yM,4282
-qiskit_superstaq/superstaq_backend_test.py,sha256=tMI572TXGWiGBLJw6QMzfXRrIKuuI74ypw2rjO6Ru7Y,3651
-qiskit_superstaq/superstaq_job.py,sha256=CZxe3xxm3xK8uCBRyi31nyVH4H4ssuCOBjIhhUkbozY,4951
-qiskit_superstaq/superstaq_job_test.py,sha256=WX9cvxFB21BrFTZTXvJWkmCSn2Sx--tN7X7pJI24V3U,3503
-qiskit_superstaq/superstaq_provider.py,sha256=dQuc3_ZpytsqZj6nDa56SHU2d0xGnDlRQERaMSncx9M,13771
-qiskit_superstaq/superstaq_provider_test.py,sha256=MvL1esBy3EPDFsaIIcjFWbftZ4fuY2qJ4vS2_RqoXgA,11406
-qiskit_superstaq-0.3.9.dist-info/LICENSE.txt,sha256=-P8Wao0KqlfGI_5nyy8snm7pAKy21CFWtPdAZ69FsDk,11416
-qiskit_superstaq-0.3.9.dist-info/METADATA,sha256=EeOwpkpoqnDA3e5_lveKCA0iDKUX4HKYrWandEIpHTU,2253
-qiskit_superstaq-0.3.9.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-qiskit_superstaq-0.3.9.dist-info/top_level.txt,sha256=xis4x-IZ03YaIz8-_Edz-OR01jcFLGtdoLqKCub2u8k,17
-qiskit_superstaq-0.3.9.dist-info/RECORD,,
+qiskit_superstaq/serialization.py,sha256=zOyh9H7x8YK8Z2mQh9mUZ9ELNuLPhrjc8Be2nk-L-X4,6338
+qiskit_superstaq/serialization_test.py,sha256=swLoFiX6Kw1DRpVzlBUG-EqM2N79D-wxVaR4Q40C_JA,5933
+qiskit_superstaq/superstaq_backend.py,sha256=b0fvq-L4ldqoUG0KoBVTAogOuUvngGOoTt1tBEKqW9Q,15719
+qiskit_superstaq/superstaq_backend_test.py,sha256=QF8cnQc3-nja5OFeM_FzRGDpeTJaojqov05_R7_tLHU,10173
+qiskit_superstaq/superstaq_job.py,sha256=qlCwHvhbie9TmCGQEyFW94o9N2ScI3pvvrjB69i5-og,6944
+qiskit_superstaq/superstaq_job_test.py,sha256=1XIpy8oW2neshKZqyGMnWJUL9-HsKbR076mdGeFY5h0,7118
+qiskit_superstaq/superstaq_provider.py,sha256=Yq_D9vMAHFLPPlMBZlrAd_MJWaUT-hFj2Ok56tX4a2I,16192
+qiskit_superstaq/superstaq_provider_test.py,sha256=KBAnT7GyjvOE8BqNuBsUAQwAjVSIGFoaa2Wv4iab2r0,15299
+qiskit_superstaq/validation.py,sha256=amKHPIrCHwg9XlmbG-lYoPzmjmiOBxwtFuJiG835LvA,826
+qiskit_superstaq/validation_test.py,sha256=IHhAFxXoAIt2L301pp8EE3HNIRvT3KUlo_lZp0jMjTI,764
+qiskit_superstaq-0.4.0.dist-info/METADATA,sha256=RredHw1Oz2tnofucHvtON2I5CrJhE6uFQgmMZP-_Tgo,2146
+qiskit_superstaq-0.4.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+qiskit_superstaq-0.4.0.dist-info/top_level.txt,sha256=xis4x-IZ03YaIz8-_Edz-OR01jcFLGtdoLqKCub2u8k,17
+qiskit_superstaq-0.4.0.dist-info/RECORD,,
```

