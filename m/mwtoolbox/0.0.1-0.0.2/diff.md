# Comparing `tmp/mwtoolbox-0.0.1-py3-none-any.whl.zip` & `tmp/mwtoolbox-0.0.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,8 +1,8 @@
-Zip file size: 173599 bytes, number of entries: 32
+Zip file size: 174174 bytes, number of entries: 32
 -rw-rw-rw-  2.0 fat        0 b- defN 20-Jul-17 10:08 em/__init__.py
 -rw-rw-rw-  2.0 fat        0 b- defN 20-Jul-17 10:08 em/fdfd_2d/__init__.py
 -rw-rw-rw-  2.0 fat    52847 b- defN 22-Feb-24 18:22 em/fdfd_2d/fdfd_2d.py
 -rw-rw-rw-  2.0 fat    18053 b- defN 22-Feb-24 17:21 em/fdfd_2d/grid3.py
 -rw-rw-rw-  2.0 fat    54872 b- defN 22-Feb-18 09:30 em/fdfd_2d/old/fdfd_cs3.py
 -rw-rw-rw-  2.0 fat    47481 b- defN 21-Apr-24 02:31 em/fdfd_2d/old/fdfd_cs3_old_working.py
 -rw-rw-rw-  2.0 fat    16235 b- defN 20-Jul-19 08:31 em/fdfd_2d/old/grid.py
@@ -10,25 +10,25 @@
 -rw-rw-rw-  2.0 fat        0 b- defN 20-Jul-17 10:08 em/mode_matching/__init__.py
 -rw-rw-rw-  2.0 fat     8677 b- defN 20-Jul-19 08:31 em/mode_matching/mode_matching_module.py
 -rw-rw-rw-  2.0 fat     8350 b- defN 20-Jul-19 08:31 em/mode_matching/old/mode_matching_module.py
 -rw-rw-rw-  2.0 fat     6320 b- defN 20-Jul-19 08:31 em/mode_matching/old/modematching - Copy.py
 -rw-rw-rw-  2.0 fat     6057 b- defN 20-Jul-19 08:31 em/mode_matching/old/modematching.py
 -rw-rw-rw-  2.0 fat     6492 b- defN 20-Jul-19 08:31 em/mode_matching/old/modematching_gen.py
 -rw-rw-rw-  2.0 fat     6385 b- defN 20-Jul-19 08:31 em/mode_matching/old/modematching_mp.py
--rw-rw-rw-  2.0 fat      138 b- defN 23-Jun-06 16:19 mwtoolbox/__init__.py
--rw-rw-rw-  2.0 fat    76585 b- defN 23-May-23 13:35 mwtoolbox/components.py
+-rw-rw-rw-  2.0 fat      138 b- defN 23-Jun-27 10:03 mwtoolbox/__init__.py
+-rw-rw-rw-  2.0 fat    76586 b- defN 23-Jun-14 12:48 mwtoolbox/components.py
 -rw-rw-rw-  2.0 fat    15140 b- defN 23-May-23 13:47 mwtoolbox/filters.py
 -rw-rw-rw-  2.0 fat    27551 b- defN 23-May-10 14:01 mwtoolbox/genel.py
 -rw-rw-rw-  2.0 fat      821 b- defN 22-Jul-05 18:35 mwtoolbox/mwutils.py
 -rw-rw-rw-  2.0 fat      414 b- defN 22-Jul-19 09:02 mwtoolbox/myconstants.py
 -rw-rw-rw-  2.0 fat    14316 b- defN 23-Apr-24 19:04 mwtoolbox/network.py
 -rw-rw-rw-  2.0 fat    13965 b- defN 23-Apr-24 19:04 mwtoolbox/networksym.py
 -rw-rw-rw-  2.0 fat     8654 b- defN 20-Apr-16 20:52 mwtoolbox/pysmith.py
 -rw-rw-rw-  2.0 fat   139988 b- defN 23-May-10 12:27 mwtoolbox/rfnetwork.py
 -rw-rw-rw-  2.0 fat   138621 b- defN 23-Apr-24 18:40 mwtoolbox/touchstone.py
--rw-rw-rw-  2.0 fat   133622 b- defN 23-May-23 13:36 mwtoolbox/transmission_lines.py
--rw-rw-rw-  2.0 fat     1091 b- defN 23-Jun-06 16:31 mwtoolbox-0.0.1.dist-info/LICENSE
--rw-rw-rw-  2.0 fat      948 b- defN 23-Jun-06 16:31 mwtoolbox-0.0.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Jun-06 16:31 mwtoolbox-0.0.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       10 b- defN 23-Jun-06 16:31 mwtoolbox-0.0.1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     2659 b- defN 23-Jun-06 16:31 mwtoolbox-0.0.1.dist-info/RECORD
-32 files, 824174 bytes uncompressed, 169367 bytes compressed:  79.5%
+-rw-rw-rw-  2.0 fat   136964 b- defN 23-Jun-16 07:54 mwtoolbox/transmission_lines.py
+-rw-rw-rw-  2.0 fat     1091 b- defN 23-Jun-27 10:07 mwtoolbox-0.0.2.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1074 b- defN 23-Jun-27 10:07 mwtoolbox-0.0.2.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jun-27 10:07 mwtoolbox-0.0.2.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       10 b- defN 23-Jun-27 10:07 mwtoolbox-0.0.2.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2660 b- defN 23-Jun-27 10:07 mwtoolbox-0.0.2.dist-info/RECORD
+32 files, 827644 bytes uncompressed, 169942 bytes compressed:  79.5%
```

## zipnote {}

```diff
@@ -75,23 +75,23 @@
 
 Filename: mwtoolbox/touchstone.py
 Comment: 
 
 Filename: mwtoolbox/transmission_lines.py
 Comment: 
 
-Filename: mwtoolbox-0.0.1.dist-info/LICENSE
+Filename: mwtoolbox-0.0.2.dist-info/LICENSE
 Comment: 
 
-Filename: mwtoolbox-0.0.1.dist-info/METADATA
+Filename: mwtoolbox-0.0.2.dist-info/METADATA
 Comment: 
 
-Filename: mwtoolbox-0.0.1.dist-info/WHEEL
+Filename: mwtoolbox-0.0.2.dist-info/WHEEL
 Comment: 
 
-Filename: mwtoolbox-0.0.1.dist-info/top_level.txt
+Filename: mwtoolbox-0.0.2.dist-info/top_level.txt
 Comment: 
 
-Filename: mwtoolbox-0.0.1.dist-info/RECORD
+Filename: mwtoolbox-0.0.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mwtoolbox/__init__.py

```diff
@@ -1,8 +1,8 @@
 """
 mwtoolbox
 
 An python library for processing of RF/Microwave networks.
 """
 
-__version__ = "0.0.1"
+__version__ = "0.0.2"
 __author__ = 'Tuncay Erdöl'
```

## mwtoolbox/components.py

```diff
@@ -979,15 +979,15 @@
 
     Args:
         arg(list): First 3 arguments are inputs.
 
             1. Impedance (Zo); impedance
             2. Center Frequency ;  frequency
             3. Electrical Length (theta) ; angle
-            4. Impedance (Z); impedance
+            4. Impedance (Zx); impedance
             5. Capacitance ; capacitance
 
         defaultunits(list, optional): Default units for quantities in *arg* list. Default is [] which means SI units will be used if no unit is given in *arg*.
 
     Returns:
         list: arg
     """
```

## mwtoolbox/transmission_lines.py

```diff
@@ -62,15 +62,15 @@
             1. f ; frequency
             2. sigma ; conductivity
             3. mu ; relative permeability
             4. er ; relative permittivity
     """
     return csqrt(1.0 / sigma / mu / mu0 / pi / f)*csqrt(csqrt(1+(2*pi*f*er*eps0/sigma)**2)+2*pi*f*er*eps0/sigma)
 
-def synthesis_bisection_1d(fonk, _args, k, target_value, init_value, limits = None):
+def synthesis_bisection_1d(fonk, _args, k, target_value, init_value, limits = None, tol = 1e-10):
     """
     This function calculates x such that f(x)=y.
     This function is added because NLOPT version in =synthesis= function does not work fast.
     This function works faster because it employs the fact that all the fonk functions are monotonic functions,
     so bisection method can be used securely.
 
     Args:
@@ -88,15 +88,15 @@
     args=_args[:]
     args[k] = init_value
     argsmid = args[:]
     if not limits:
         lim = []
     else:
         lim = limits[:]
-    tol = 1e-10
+    # print(f"{tol=}")
     tt=0
     midpoint=0.5*(lim[0]+lim[1])
     while((fonk(*argsmid)-target_value)**2>tol):
         if tt!=2:
             argsmin=args[:]
             argsmin[k]=lim[0]
             fmin=fonk(*argsmin)-target_value
@@ -107,20 +107,27 @@
             fmax=fonk(*argsmax)-target_value
 
         midpoint=0.5*(lim[0]+lim[1])
         argsmid=args[:]
         argsmid[k]=midpoint
         fmid=fonk(*argsmid)-target_value
 
-        if fmin*fmid<0:
+        if (fmin<0 and fmid>0) or (fmin>0 and fmid<0):
             lim[1]=midpoint
             tt=1
-        elif fmax*fmid<0:
+        elif (fmax<0 and fmid>0) or (fmax>0 and fmid<0):
             lim[0]=midpoint
             tt=2
+        else:
+            print("Out of bounds!")
+            return None
+            # if fmid < 0:
+            #     return lim[0]
+            # else:
+            #     return lim[1]
     return midpoint
 
 def synthesis(fonk, _args, k, target_value, init_value, limits):
     r"""Function that is used to calculate the parameter value of a function
     that will give target value. There are 2 versions in this function (SciPy and NLOPT).
     NLOPT is added to avoid SciPy for smaller package size for packed applications.
 
@@ -261,14 +268,88 @@
     dw1 = t / pi * log(4. * exp(1) / csqrt((th) ** 2 + 1 / pi / (wt + 1.1)))
     dwr = 0.5 * dw1 * (1. + (1./ er))
 #    w1=w+dw1
     wr = w + dwr
     x = er_eff_qs_thin_microstrip(wr, h, er)
     return (z_qs_thin_microstrip(wr, h, 1)/ csqrt(x))
 
+def z_qs_thick_embedded_microstrip_1(w, h1, h2, er, t=0):
+    r"""Impedance of microstrip transmission line ignoring dispersion.
+    Reference:  https://www.eeweb.com/tools/embedded-microstrip-impedance/ (IPC-2141A paragraph 4.2.3)
+    TODO: Has a problem, does not give meaningful results.
+
+    Args:
+        w (float): Line width.
+        h1 (float): Thickness of the substrate under the line.
+        h2 (float): Total thickness of the substrate.
+        er (float): Dielectric permittivity of the substrate.
+        t (float): Thickness of metal.
+
+    Returns:
+        float: Characteristic impedance.
+    """
+    eeff = er_eff_qs_thick_embedded_microstrip(w, h1, h2, er, t)
+    temp = np.sqrt(np.exp(-2*h2/h1)+er/eeff*(1-np.exp(-2*h2/h1)))
+    z0 = z_qs_thick_microstrip_wheeler(w, h2, er, t) / temp
+    return z0
+
+def z_qs_thick_embedded_microstrip(w, h, h1, er, t):
+    r"""Impedance of embedded microstrip transmission line ignoring dispersion.
+    Reference:  https://www.rfwireless-world.com/calculators/Embedded-Microstrip-Impedance-Calculator.html
+
+    Args:
+        w (float): Line width.
+        h (float): Thickness of the substrate under the line.
+        h1 (float): Total thickness of the substrate.
+        er (float): Dielectric permittivity of the substrate.
+        t (float): Thickness of metal.
+
+    Returns:
+        float: Characteristic impedance.
+    """
+    eeff = er_eff_qs_thick_embedded_microstrip(w, h, h1, er, t)
+    z0 = 60/np.sqrt(eeff) * np.log(5.98*h/(0.8*w+t))
+    return z0
+
+def er_eff_qs_thick_embedded_microstrip(w, h, h1, er, t):
+    r"""Effective permittivity of embedded microstrip transmission line ignoring dispersion.
+    Reference:  https://www.rfwireless-world.com/calculators/Embedded-Microstrip-Impedance-Calculator.html
+
+    Args:
+        w (float): Line width.
+        h (float): Thickness of the substrate under the line.
+        h1 (float): Total thickness of the substrate.
+        er (float): Dielectric permittivity of the substrate.
+        t (float): Thickness of metal.
+
+    Returns:
+        float: Characteristic impedance.
+    """
+    eeff = er*(1-np.exp(-1.55*h1/h))
+    return eeff
+
+def z_qs_thick_microstrip_wheeler(w, h, er, t):
+    r"""Impedance of microstrip transmission line ignoring dispersion.
+    Reference:  Wheeler's Equation ( https://www.eeweb.com/tools/microstrip/ )
+
+    Args:
+        w (float): Line width (in m).
+        h (float): Thickness of the substrate (in m).
+        er (float): Dielectric permittivity of the substrate.
+        t (float. optional): Thickness of metal. Default is 0.
+
+    Returns:
+        float: Characteristic impedance.
+    """
+    weff = w + (t/np.pi) * np.log(4*np.exp(1)/np.sqrt((t/h)**2+(t/(w*np.pi+1.1*t*np.pi))**2))*(er+1)/(2*er)
+    x1 = 4 * (14*er+8)/(11*er)*(h/weff)
+    x2 = 16 * (h/weff)**2 * ((14*er+8)/(11*er))**2 + (er+1)/(2*er)*np.pi**2
+    x2 = np.sqrt(x2)
+    z0 = eta0 / (2*np.pi*np.sqrt(2*(er+1)))*np.log(1 + 4*h/weff*(x1+x2))
+    return z0
 
 def er_eff_qs_thick_microstrip(w, h, er, t=0.0):
     """
     Ref: (Hammerstad and Jensen denenecek), Wheeler,  Qucs Technical, s.150
     """
     th = (t/ h)
     dw1=0.0
@@ -519,15 +600,17 @@
     if len(defaultunits) == 0:
         defaultunits = [""] * len(arg) * 3
     arg = arg[:14]
     newargs = convert2pq(arg, defaultunits)
     _, h, t, er, tand, Kd, sigma, mu, roughness, freq, _, Z, rad, dT = tuple(
         newargs)
     w = h
-    w = synthesis_bisection_1d(z_disp_thick_microstrip, [w, h, t, er, freq], 0, Z , h , [h/1000.0,1000.0*h])
+    w = synthesis_bisection_1d(z_disp_thick_microstrip, [w, h, t, er, freq], 0, Z , h , [h/1000.0,1000.0*h], tol = 1e-5)
+    if not w: # no solution is found
+        return None
     eeff = er_eff_disp_thick_microstrip(w, h, t, er, freq)
     length = physical_length(eeff, freq, rad)
     cond_loss = conductor_loss_microstrip(
         w, h, t, er, sigma, mu, roughness, freq)
     Pave = average_power_rating_thick_microstrip(
         w, h, t, er, freq, tand, sigma, mu, roughness, Kd, dT)
     skindepth = skin_depth(freq, sigma, mu)
@@ -681,52 +764,60 @@
         Zk2 = 2.0 * log(2.0)
     Zo2 = 94.15 / csqrt(er) / ((wb/ (1 - tb)) + (Zk2/  pi))
     if wb>0.35:
         return Zo2
     else:
         return Zo1
 
-def z_thick_offset_stripline(w, eps_r, h1, h2, t):
+def z_thick_offset_stripline(w, eps_r, h1, h2, t, imp=1):
     """Characteristic impedance of asymmetric stripline transmission line.
-    Ref: Transmssion Line Design Handbook, p. 129
+    Ref-1: Transmssion Line Design Handbook, p. 129
+    Ref-2: Compare with ref "IPC-2141A, https://www.eeweb.com/tools/asymmetric-stripline-impedance/"
 
     Args:
-        w (float): Line width (in m).
+        w (float): Line width.
         eps_r (float): Dielectric permittivity of the substrate.
-        h1 (float): Thickness of the substrate under the line (in m).
-        h2 (float): Thickness of the substrate above the line (in m).
-        t (float): Thickness of the metal (in m).
+        h1 (float): Thickness of the substrate under the line.
+        h2 (float): Thickness of the substrate above the line.
+        t (float): Thickness of the metal.
+        imp (int, optional): Type of implementation. Default is 1.
 
     Returns:
         float: Characteristic impedance.
     """
-    # print(w, eps_r, h1, h2, t)
-    seterr(all='raise')
-    def F(x):
-        return (1-2*x)*((1-x)*log(1-x)-x*log(x))
-    b = h1+h2+t
-    s= fabs(h1-h2)
-    eeff = eps_r
-    cl=(b-s)/2
-    if w/(b-t)<0.35:
-        x=min(t,w)/max(w,t)
-        d0 = w*(0.5008+1.0235*x-1.023*x**2+1.1564*x**3-0.4749*x**4)
-        A=sin(pi*cl/b)/tanh(pi*d0/2/b)
-        z_0 = eta0*arccosh(A)/2/pi/sqrt(eps_r)
-    else:
-        if w/(b-t)<t/b:
-            k = 1.0/cosh(pi*w/2/b)
-            k_ = tanh(pi*w/2/b)
-            w_b = w/b+(1-t/b)**8*(ekpolyfit(k_)/ekpolyfit(k)-2/pi*log(2)-w/b)
+    if imp==1:
+        seterr(all='raise')
+        def F(x):
+            return (1-2*x)*((1-x)*log(1-x)-x*log(x))
+        b = h1+h2+t
+        s= fabs(h1-h2)
+        eeff = eps_r
+        cl=(b-s)/2
+        if w/(b-t)<0.35:
+            x=min(t,w)/max(w,t)
+            d0 = w*(0.5008+1.0235*x-1.023*x**2+1.1564*x**3-0.4749*x**4)
+            A=sin(pi*cl/b)/tanh(pi*d0/2/b)
+            z_0 = eta0*arccosh(A)/2/pi/sqrt(eps_r)
         else:
-            w_b = w/b
-        beta = 1-t/b
-        gamma = cl/b-t/2/b
-        cf=eps_r*eps0/pi*(2*log(1/gamma/(beta-gamma))+1/gamma/(beta-gamma)*(F(t/b)-F(cl/b)))
-        z_0=eta0/sqrt(eps_r)/(w_b/gamma+w_b/(beta-gamma)+2*cf/eps_r/eps0)
+            if w/(b-t)<t/b:
+                k = 1.0/cosh(pi*w/2/b)
+                k_ = tanh(pi*w/2/b)
+                w_b = w/b+(1-t/b)**8*(ekpolyfit(k_)/ekpolyfit(k)-2/pi*log(2)-w/b)
+            else:
+                w_b = w/b
+            beta = 1-t/b
+            gamma = cl/b-t/2/b
+            cf=eps_r*eps0/pi*(2*log(1/gamma/(beta-gamma))+1/gamma/(beta-gamma)*(F(t/b)-F(cl/b)))
+            z_0=eta0/sqrt(eps_r)/(w_b/gamma+w_b/(beta-gamma)+2*cf/eps_r/eps0)
+
+    elif imp==2:
+        Z0air = 2 * (z_thick_stripline(w, h1, t, eps_r) * z_thick_stripline(w, h2, t, eps_r)) /  (z_thick_stripline(w, h1, t, eps_r) + z_thick_stripline(w, h2, t, eps_r))
+        dZ0air = 0.0325 * np.pi * Z0air**2 * np.pow(0.5-0.5*(2*h1+t)/(h1+h2+t),2.2) * np.pow((t+w)/(h1+h2+t),2.9)
+        z_0 = 1.0/np.sqrt(eps_r) * (z_thick_stripline(w, h1+h2+t, t, 1) - dZ0air)
+
     return z_0
 
 def conductor_loss_stripline(w, b, t, er, f, sigma, mu):
     """Calculation of conductor loss of stripline with incremental inductance rule.
 
     Args:
         w (float): Width of line (in m).
@@ -826,15 +917,16 @@
     newargs = convert2pq(arg, defaultunits)
     w, b, t, er, tand, sigma, mu, roughness, freq, length, Zc, elec_length = tuple(
         newargs)
     eeff = er
     w = (b/ 5.0)
 
     w = synthesis_bisection_1d(z_thick_stripline, [w, b, t, er], 0, Zc , b , [b/1000.0,1000.0*b])
-
+    if not w: # no solution is found
+        return None
     print("ee ", eeff, freq, elec_length)
     length = physical_length(eeff, freq, elec_length)
     cond_loss = conductor_loss_stripline(w, b, t, er, freq, sigma, mu)
     diel_loss = dielectric_loss(eeff, er, freq, tand)
     arg[0] = prettystring(w, defaultunits[0])
     arg[9] = prettystring(length, defaultunits[9])
     argout = [eeff, cond_loss, diel_loss]
@@ -995,14 +1087,16 @@
     Ref: Transmssion Line Design Handbook, p47, r-inner diameter, d-outer diameter
     """
     arg = arg[:11]
     newargs = convert2pq(arg, defaultunits)
     r, d, er, tand, sigma, mu, roughness, freq, length, Z, deg = tuple(newargs)
     output = synthesis(lambda *x: z_coaxial(*x), [er, r, d], [1], target_value=[Z],
                     init_value=[(d/2.0)], limits=[((d/ 100.0), d * 100.0)])
+    if not output: # no solution is found
+        return None
     r = output[0]
     Z = z_coaxial(er, r, d)
     eeff = er
     #deg = electrical_length(eeff, freq, length)
     length = physical_length(eeff, freq, deg)
     print("df ",eeff,freq,length,deg)
     cond_loss = conductor_loss_coaxial(er, r, d, freq, sigma, mu)
@@ -1191,14 +1285,16 @@
     """
 
     arg = arg[:13]
     newargs = convert2pq(arg, defaultunits)
     w, t, a, b, er, tand, sigma, mu, roughness, freq, length, Z ,deg = tuple(newargs)
     output = synthesis(lambda *x: z_rectangular_coaxial(*x), [w, b, t, a, er], [0], target_value=[Z],
                     init_value=[b], limits=[((b/ 100.0), b * 100.0)])
+    if not output: # no solution is found
+        return None
     w = output[0]
     Z = z_rectangular_coaxial(w, b, t, a, er)
     eeff = er
     length = physical_length(eeff, freq, deg)
     #deg = electrical_length(eeff, freq, length)
     sd = skin_depth(freq, sigma, mu)
     cond_loss = -mu * pi * freq / Z / co * (z_rectangular_coaxial(w, b, t, a, 1.0) - z_rectangular_coaxial(
@@ -1275,14 +1371,16 @@
     """
 
     arg = arg[:11]
     newargs = convert2pq(arg, defaultunits)
     er, r, d, tand, sigma, mu, roughness, freq, length, Z, deg = tuple(newargs)
     output = synthesis(lambda *x: z_square_coaxial_square_center(*x), [er, r, d], [1], target_value=[Z],
                     init_value=[(d/2.0)], limits=[((d/ 1000.0), d * 1000.0)])
+    if not output: # no solution is found
+        return None
     r = output[0]
     Z = z_square_coaxial_square_center(er, r, d)
     eeff = er
     length = physical_length(eeff, freq, deg)
     #deg = electrical_length(eeff, freq, length)
     sd = skin_depth(freq, sigma, mu)
     cond_loss = -mu * pi * freq / Z / co * (z_square_coaxial_square_center(1.0, r, d) - z_square_coaxial_square_center(
@@ -1651,14 +1749,16 @@
 
     """
 
     arg = arg[:13]
     newargs = convert2pq(arg, defaultunits)
     w, t, h, hu, hl, er, tand, sigma, mu, roughness, freq, length, Z, deg = tuple(newargs)
     output = synthesis(lambda *x:Z_eeff_suspended_stripline(*x)[0], [w, t, h, hu, hl, er, freq], [0],target_value=[Z],init_value=[b], limits = [((a/1000.0),a*1000.0)])
+    if not output: # no solution is found
+        return None
     w= output[0]
     Z, eeff = z_eeff_suspended_stripline(w, t, h, hu, hl, er, freq)
     length = physical_length(eeff, freq, deg)
     sd = skin_depth(freq, sigma, mu)
     cond_loss = -mu * pi * freq / Z / co * (z_eeff_suspended_stripline(w, t, h, hu, hl, 1.0, freq)[0] - z_eeff_suspended_stripline(
         w - sd, t - sd,  h, hu + sd, hl + sd, 1.0, freq)[0]) * 20.0 * log10(exp(1))  # dB/m, incremental inductance
     diel_loss = dielectric_loss(eeff, er, freq, tand)
@@ -1745,17 +1845,17 @@
 
     """
 
     arg = arg[:13]
     newargs = convert2pq(arg, defaultunits)
     w, t, a, b, er, tand, sigma, mu, roughness, freq, length, Z, deg = tuple(newargs)
     output =synthesis(lambda *x:Z_eeff_suspended_microstripline(*x)[0], [w, t, a, b, er, freq], [0],target_value=[Z],init_value=[b], limits = [((a/1000.0),a*1000.0)])
+    if not output: # no solution is found
+        return None
     w= output[0]
-
-
     Z, eeff = z_eeff_suspended_microstripline(w, t, a, b, er, freq)
     length = physical_length(eeff, freq, deg)
     sd = skin_depth(freq, sigma, mu)
     cond_loss = -mu * pi * freq / Z / co * (z_eeff_suspended_microstripline(w, t, a, b, 1.0, freq)[0] - z_eeff_suspended_microstripline(
         w - sd, t - sd, a, b + sd, 1.0, freq)[0]) * 20.0 * log10(exp(1))  # dB/m, incremental inductance
     diel_loss = dielectric_loss(eeff, er, freq, tand)
     argout = [Z, deg, eeff, cond_loss, diel_loss]
@@ -1866,14 +1966,16 @@
     """
 
     arg = arg[:13]
     newargs = convert2pq(arg, defaultunits)
     w, h, b, a, er, tand, sigma, mu, roughness, freq, length,Z,deg = tuple(newargs)
     # Z, eeff = z_eeff_shielded_suspended_stripline(w, h, b, a, er)
     output =synthesis(lambda *x:Z_eeff_shielded_suspended_stripline(*x)[0], [w, h, b, a, er], [0],target_value=[Z],init_value=[b], limits = [((a/100.0),a*100.0)])
+    if not output: # no solution is found
+        return None
     w= output[0]
     Z, eeff = z_eeff_shielded_suspended_stripline(w, h, b, a, er)
     length = physical_length(eeff, freq, deg)
     sd = skin_depth(freq, sigma, mu)
     cond_loss = -mu * pi * freq / Z / co * (z_eeff_shielded_suspended_stripline(w, h, b, a, 1.0)[0] - z_eeff_shielded_suspended_stripline(
         w - sd, h + sd, b + sd, a + sd, 1.0)[0]) * 20.0 * log10(exp(1))  # dB/m, incremental inductance
     diel_loss = dielectric_loss(eeff, er, freq, tand)
@@ -1931,24 +2033,24 @@
     k1=(sinh(pi*at/4.0/h)/ sinh(pi*bt/4.0/h))
     k1_=csqrt(1.0-k1*k1)
     eeff=1.0+(er-1.0)/2.0*ellipk(k_) * ellipk(k1) / (ellipk(k) * ellipk(k1_))
     eeff_t=eeff-((eeff-1.0)/((b-a)/2.0/0.7/t*ellipk(k)/ellipk(k_)+1.0))
     Zo=30.0*pi*ellipk(kt_)/ellipk(kt)/csqrt(eeff_t)
     return (Zo, eeff_t)
 
-def grounded_cpw_analysis(arg, defaultunits):
+def grounded_coplanar_waveguide_analysis(arg, defaultunits):
     r"""Analysis function for the grounded coplanar waveguide transmission line.
     Ref: Coplanar waveguide circuits, components and systems s89
 
     Args:
         arg(list): First 11 arguments are inputs.
 
             1. Line Width (w);length
             2. Line Spacing (s);length
-            3. Metal Thickness (th);length
+            3. Metal Thickness (t);length
             4. Dielectric Permittivity (<font size=+2>&epsilon;<sub>r</sub></font>);
             5. Substrate Thickness (h);length
             6. Dielectric Loss Tangent ;
             7. Metal Conductivity ;  electrical conductivity
             8. Metal Permeability ;
             9. Roughness ;length
             10. Frequency ; frequency
@@ -1970,15 +2072,15 @@
     cond_loss = -mu * pi * freq / Z / co * (z_eeff_grounded_cpw(w, th, 1.0, s, h)[0] - z_eeff_grounded_cpw(
         w - sd, th-sd, 1.0, s + sd, h + sd)[0]) * 20.0 * log10(exp(1))  # dB/m, incremental inductance
     diel_loss = dielectric_loss(eeff, er, freq, tand)
     argout = [Z, deg, eeff, cond_loss, diel_loss]
     arg = arg + [prettystring(argout[i], defaultunits[len(arg) + i]) for i in range(len(argout))]
     return arg
 
-def grounded_cpw_synthesis(arg, defaultunits):
+def grounded_coplanar_waveguide_synthesis(arg, defaultunits):
     r"""Synthesis function for the grounded coplanar waveguide transmission line.
     Ref: Coplanar waveguide circuits, components and systems s89
 
     Args:
         arg(list): First 10 arguments are inputs.
 
             1. Line Width (w);length
@@ -2000,14 +2102,16 @@
     """
 
     arg = arg[:12]
     newargs = convert2pq(arg, defaultunits)
     w, s, er, h, tand, sigma, mu, roughness, freq, length, Z, deg = tuple(newargs)
     output = synthesis(lambda *x: z_eeff_grounded_cpw(*x)[0], [w, er, s, h], [0], target_value=[Z],
                     init_value=[h], limits=[((h/ 1000.0), h * 1000.0)])
+    if not output: # no solution is found
+        return None
     w = output[0]
     Z, eeff = z_eeff_grounded_cpw(w, er, s, h)
     length = physical_length(eeff, freq, deg)
     sd = skin_depth(freq, sigma, mu)
     cond_loss = -mu * pi * freq / Z / co * (z_eeff_grounded_cpw(w, 1.0, s, h)[0] - z_eeff_grounded_cpw(
         w - sd, 1.0, s + sd, h + sd)[0]) * 20.0 * log10(exp(1))  # dB/m, incremental inductance
     diel_loss = dielectric_loss(eeff, er, freq, tand)
@@ -2099,15 +2203,16 @@
 
     """
 
     arg = arg[:13]
     newargs = convert2pq(arg, defaultunits)
     w, s, h, er, h1, tand, sigma, mu, roughness, freq, length, Z, deg = tuple(newargs)
     w = synthesis_bisection_1d(lambda *x: z_eeff_covered_grounded_cpw(*x)[0], [w, s, h, er, h1], 0, Z,h, limits=[h/ 100.0, h * 100.0])
-
+    if not w: # no solution is found
+        return None
     Z, eeff = z_eeff_covered_grounded_cpw(w, s, h, er, h1)
     length = physical_length(eeff, freq, deg)
     sd = skin_depth(freq, sigma, mu)
     cond_loss = -mu * pi * freq / Z / co * (z_eeff_covered_grounded_cpw(w, s, h, 1.0, h1)[0] - z_eeff_covered_grounded_cpw(
         w - sd, s + sd, h + sd, 1.0, h1 + sd)[0]) * 20.0 * log10(exp(1))  # dB/m, incremental inductance
     diel_loss = dielectric_loss(eeff, er, freq, tand)
     argout = [Z, deg, eeff, cond_loss, diel_loss]
@@ -2234,14 +2339,17 @@
 
     """
 
     arg = arg[:14]
     newargs = convert2pq(arg, defaultunits)
     w, s, t, h, er, tand, sigma, mu, roughness, freq, length, z_even, z_odd, elec_length = tuple(newargs)
     output =synthesis(lambda *x:Z_eeff_edge_coupled_microstrip(*x)[:2], [w, er, t, h, s, freq], [0,4],target_value=[Z_even, z_odd],init_value=[h,h], limits = [((h/100.0),h*10.0),((h/100.0),h*10.0)])
+
+    if not output: # no solution is found
+        return None
     w, s= tuple(output[0])
     z_even, z_odd, eeff_even, eeff_odd = z_eeff_edge_coupled_microstrip(
         w, er, t, h, s, freq)
     # deg_even = electrical_length(eeff_even, freq, length)
     length = physical_length(eeff_even, freq, elec_length)
     deg_odd = electrical_length(eeff_odd, freq, length)
     sd = skin_depth(freq, sigma, mu)
@@ -2523,14 +2631,16 @@
 
     """
 
     arg = arg[:14]
     newargs = convert2pq(arg, defaultunits)
     w, er, t, b, s, tand, sigma, mu, roughness, freq, length, z_even, z_odd, elec_length = tuple(newargs)
     output = synthesis(z_edge_coupled_thick_symmetric_stripline, [w, b, s, er, t], [0,2], [Z_even, z_odd] , [w,s] , [((b/100.0),10.0*b)])
+    if not output: # no solution is found
+        return None
     w, s= tuple(output[0])
     arg[0]=prettystring(w, defaultunits[0])
     arg[4]=prettystring(s, defaultunits[4])
     sd = skin_depth(freq, sigma, mu)
     z_even1, z_odd1 = z_edge_coupled_thick_symmetric_stripline(w - sd, b + sd, s + sd, 1.0, t)
     z_even2, z_odd2 = z_edge_coupled_thick_symmetric_stripline(w, b, s, 1.0, t)
     eeff = er
@@ -2630,14 +2740,16 @@
     """
 
     arg = arg[:13]
     newargs = convert2pq(arg, defaultunits)
     w, b, t, g, er, tand, sigma, mu, roughness, freq, length, Z, deg = tuple(newargs)
     output = synthesis(lambda *x: z_shielded_stripline(*x), [w, b, t, g, er], [0], target_value=[Z],
                     init_value=[b], limits=[((b/ 1000.0), b * 1000.0)])
+    if not output: # no solution is found
+        return None
     w = output[0]
     Z = z_shielded_stripline(w, b, t, g, er)
     eeff = er
     length = physical_length(eeff, freq, deg)
     cond_loss = conductor_loss_shielded_stripline( w, b, t, g, er, freq, sigma, mu)
     diel_loss = dielectric_loss(eeff, er, freq, tand)
     arg[0] = prettystring(w, defaultunits[0])
@@ -2973,70 +3085,37 @@
 # microstrip_analysis = microstrip_analysis
 # stripline_analysis = stripline_analysis
 edge_coupled_stripline_analysis = edge_coupled_stripline_analysis
 broadside_coupled_stripline_analysis = broadside_offset_coupled_stripline_analysis
 #symmetrical_shielded_stripline_analysis = shielded_stripline_analysis
 suspended_icrostripline_analysis = suspended_microstrip_analysis
 shielded_suspended_stripline_analysis = shielded_suspended_stripline_analysis
-grounded_coplanar_waveguide_analysis = grounded_cpw_analysis
+# grounded_coplanar_waveguide_analysis = grounded_cpw_analysis
 #covered_grounded_coplanar_waveguide_analysis = covered_grounded_cpw_analysis
 eccentric_coaxial_line_analysis = eccentric_coaxial_analysis
 #rectangular_coaxial_line_analysis = rectangular_coaxial_analysis
 coaxial_line_strip_center_analysis = coaxial_strip_center_analysis
 square_coaxial_line_circular_center_analysis = square_coaxial_circular_center_analysis
 #square_coaxial_line_square_center_analysis = square_coaxial_square_center_analysis
 parallel_wires_analysis = parallel_wires_analysis
 edge_coupled_microstrip_analysis = edge_coupled_microstrip_analysis
 
 # microstrip_synthesis = microstrip_synthesis
 # stripline_synthesis = stripline_synthesis
 # shielded_suspended_stripline_synthesis = shielded_suspended_stripline_synthesis
 #symmetrical_shielded_stripline_synthesis = shielded_stripline_synthesis
 suspended_microstripline_synthesis = suspended_microstrip_synthesis
-grounded_coplanar_waveguide_synthesis = grounded_cpw_synthesis
+# grounded_coplanar_waveguide_synthesis = grounded_cpw_synthesis
 edge_coupled_microstrip_synthesis = edge_coupled_microstrip_synthesis
 edge_coupled_stripline_synthesis = edge_coupled_stripline_synthesis
 broadside_coupled_stripline_synthesis = broadside_offset_coupled_stripline_synthesis
 
 if __name__ == "__main__":
     # arg =["55mil","0.1mil","5mil", "20mil", "20mil", "2.2","0.001","10e9","1.0","0.0","10GHz","100mil","50","100"]
     # args=covered_suspended_microstripline_analysis(arg,[""]*17)
     # print(args)
     # print(z_eeff_suspended_stripline(55, 0.1, 5, 20, 20, 2.2, 1000))
     # print(z_eeff_grounded_cpw_thick(100e-6, 0.1e-6, 3.0, 100e-6, 127e-6))
     # print(z_coaxial(3.4, 80 , 140))
     # print(stripline_step_in_width(130e-6, 200e-6, 3, 100e-6, 300e-6, 30e-6, 77e9))
     # print(stripline_step_in_width2(130e-6, 200e-6, 3, 100e-6, 300e-6, 30e-6, 77e9))
     print(microstrip_synthesis(["10mil","5mil","1mil","3.0","0","10","5e8","1","0","77GHz","100mil","50.0","90","100"],[]))
-    """Synthesis function for microstrip transmission lines.
-
-    Args:
-        arg(list): First 13 arguments are inputs.
-
-            1. Line Width ;length
-            2. Substrate Thickness ;length
-            3. Metal Thickness ;length
-            4. Dielectric Permittivity (<font size=+2>&epsilon;<sub>r</sub></font>);
-            5. Dielectric Loss Tangent ;
-            6. Dielectric Thermal Conductivity ;   thermal conductivity
-            7. Metal Conductivity ; electrical conductivity
-            8. Metal Permeability ;
-            9. Roughness ;length
-            10. Frequency ; frequency
-            11. Physical Length ;length
-            12. Impedance ;   impedance
-            13. Electrical Length ;  angle
-            14. Max Temp Difference (<sup>o</sup>C) ;
-            15. <font size=+2>&epsilon;<sub>eff</sub></font> ;
-            16. Conductor Loss ;  loss per length
-            17. Dielectric Loss ; loss per length
-            18. Skin Depth ;length
-            19. Cutoff Frequency for TE1 mode ; frequency
-            20. Transverse Resonance Frequency; frequency
-            21. Frequency Limit for Coupling to Surface Modes ; frequency
-            22. Time Delay ; time
-            23. L  per unit length ;
-            24. C per unit length ;
-            25. Surface Impedance ; impedance
-            26. Average Rated Power ; power
-            27. Max DC Current ; current
-    """
```

## Comparing `mwtoolbox-0.0.1.dist-info/LICENSE` & `mwtoolbox-0.0.2.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mwtoolbox-0.0.1.dist-info/METADATA` & `mwtoolbox-0.0.2.dist-info/METADATA`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mwtoolbox
-Version: 0.0.1
+Version: 0.0.2
 Summary: Microwave Toolbox
 Author-email: Tuncay Erdöl <terdol@hotmail.com>
 License: MIT
 Keywords: microwave,rf,s-parameters
 Classifier: Development Status :: 3 - Alpha
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
@@ -15,10 +15,15 @@
 License-File: LICENSE
 Requires-Dist: quantities
 Requires-Dist: numpy
 Requires-Dist: scipy
 Requires-Dist: sympy
 
 # Project Description
+
+Current version = "0.0.2"
+
 MWTOOLBOX is a library for general processing of multiport RF/Microwave networks. Detailed documentation is at [https://terdol.github.io/mwtoolboxdoc](https://terdol.github.io/mwtoolboxdoc).
 
+API documentation is at [https://terdol.github.io/apidoc](https://terdol.github.io/apidoc).
+
 Source code is available at: [https://github.com/terdol/microwave_toolbox](https://github.com/terdol/microwave_toolbox).
```

## Comparing `mwtoolbox-0.0.1.dist-info/RECORD` & `mwtoolbox-0.0.2.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -9,24 +9,24 @@
 em/mode_matching/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 em/mode_matching/mode_matching_module.py,sha256=bmysCYhw0UVPAKsk20bdv4VfCqfyC4bXWkIBmzXdjqM,8677
 em/mode_matching/old/mode_matching_module.py,sha256=wubFj29UpGmmI28N7P6_TKLL1bV-fqQ24WHwXYP82ic,8350
 em/mode_matching/old/modematching - Copy.py,sha256=E4Gtd4TCQZ5QoN5skfKwaHHYC0Dp7yf_1eIl1m6APZM,6320
 em/mode_matching/old/modematching.py,sha256=KsNH_HI5k9OqqiMthBQQX-RR06OJJUBAYbw1sBbFErY,6057
 em/mode_matching/old/modematching_gen.py,sha256=jWvU9oGYAMhHqNbwabKihQMWOryehNFajll9wZ9hDBg,6492
 em/mode_matching/old/modematching_mp.py,sha256=EgAqroH5aH02XysXkrwrH7zAnoxTbBzm_Qlsw5f5lj8,6385
-mwtoolbox/__init__.py,sha256=elLsqnkDrELKMixKZm1Vh47gaJPei-r_zI_GVANlBP8,138
-mwtoolbox/components.py,sha256=ztAIGmmUHb4M4WMkPcOVceJpk9A0ngFbkgsPiEVz8rw,76585
+mwtoolbox/__init__.py,sha256=GKoFV1sU-Xf6rG3BSWp_UTFTyVaTVovQdyijSaWPA4s,138
+mwtoolbox/components.py,sha256=ujgqc8P3T-iVKHzAb0v3D320XzSrIjJbPrdCwc9Yv2c,76586
 mwtoolbox/filters.py,sha256=G4_FOF7AF_vqCqgaqsL8fZ3jImJr0gpBl6OchbisIEs,15140
 mwtoolbox/genel.py,sha256=KV8Xmio6W3cdUjtw34VJxdmIwte-lOhz5CTM2no8exs,27551
 mwtoolbox/mwutils.py,sha256=WWhAEng6qtG56-un5V-I8zKBPCbapXOWikTZrXmI0XM,821
 mwtoolbox/myconstants.py,sha256=Q4N8YxSiddHTjCs_lVAkh54C2900Ze6lNEXTHwXuskQ,414
 mwtoolbox/network.py,sha256=9xH_g-BDNWjucb5eeriBUfNqkAqE64UhxInDJBrU0Ww,14316
 mwtoolbox/networksym.py,sha256=7vmZb2wudIzM7n6XJBrLy0SPmId7aZzmSr8zF3FfU98,13965
 mwtoolbox/pysmith.py,sha256=vvW8A8FIB67SvzHLEiqH5rnZBIKpSMCmyXeoglmGZys,8654
 mwtoolbox/rfnetwork.py,sha256=nywZdmae96eg5w1VRCt4xZ5ra-2qIJ-pHXtebYVuXVg,139988
 mwtoolbox/touchstone.py,sha256=56ZFs9ZnCSFHFw_zvE0PdKokYdQLvFm6F1rc-ZVePuM,138621
-mwtoolbox/transmission_lines.py,sha256=JY5ixQP70gqgWcuTchf-jZK6sv3SeGX9cQZuv4t2jGU,133622
-mwtoolbox-0.0.1.dist-info/LICENSE,sha256=tuR_bBIcppkUIJI_ieP-KjqWJ_HlG2YQzv92P70Cg6E,1091
-mwtoolbox-0.0.1.dist-info/METADATA,sha256=XGb6FW8hjsQhF7JjhsXC8HAv2yFra0w5R4G1I82cWsY,948
-mwtoolbox-0.0.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-mwtoolbox-0.0.1.dist-info/top_level.txt,sha256=IOcqs1LvX9iaUkbkZwv_DpeZSl9W_WkAnP_-9R1xzfk,10
-mwtoolbox-0.0.1.dist-info/RECORD,,
+mwtoolbox/transmission_lines.py,sha256=Oy22kWUrBa6cUKD8MtwLhpfomcFPARHh2bH2P99kdlg,136964
+mwtoolbox-0.0.2.dist-info/LICENSE,sha256=tuR_bBIcppkUIJI_ieP-KjqWJ_HlG2YQzv92P70Cg6E,1091
+mwtoolbox-0.0.2.dist-info/METADATA,sha256=hwxIFGutECvzgUuK71EairvMTpjNI54JB3bhwnTiTKI,1074
+mwtoolbox-0.0.2.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+mwtoolbox-0.0.2.dist-info/top_level.txt,sha256=IOcqs1LvX9iaUkbkZwv_DpeZSl9W_WkAnP_-9R1xzfk,10
+mwtoolbox-0.0.2.dist-info/RECORD,,
```

