# Comparing `tmp/cirq_superstaq-0.3.9-py3-none-any.whl.zip` & `tmp/cirq_superstaq-0.4.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,25 @@
-Zip file size: 40506 bytes, number of entries: 21
--rw-r--r--  2.0 unx     1563 b- defN 22-Dec-08 20:02 cirq_superstaq/__init__.py
--rw-r--r--  2.0 unx       22 b- defN 22-Dec-08 20:02 cirq_superstaq/_version.py
--rw-r--r--  2.0 unx      243 b- defN 22-Dec-08 20:02 cirq_superstaq/_version_test.py
--rw-r--r--  2.0 unx     8383 b- defN 22-Dec-08 20:02 cirq_superstaq/compiler_output.py
--rw-r--r--  2.0 unx     8422 b- defN 22-Dec-08 20:02 cirq_superstaq/compiler_output_test.py
--rw-r--r--  2.0 unx    25883 b- defN 22-Dec-08 20:02 cirq_superstaq/custom_gates.py
--rw-r--r--  2.0 unx    27032 b- defN 22-Dec-08 20:02 cirq_superstaq/custom_gates_test.py
--rw-r--r--  2.0 unx     8420 b- defN 22-Dec-08 20:02 cirq_superstaq/daily_integration_test.py
--rw-r--r--  2.0 unx     6463 b- defN 22-Dec-08 20:02 cirq_superstaq/job.py
--rw-r--r--  2.0 unx     6734 b- defN 22-Dec-08 20:02 cirq_superstaq/job_test.py
--rw-r--r--  2.0 unx       68 b- defN 22-Dec-08 20:02 cirq_superstaq/py.typed
--rw-r--r--  2.0 unx     3054 b- defN 22-Dec-08 20:02 cirq_superstaq/sampler.py
--rw-r--r--  2.0 unx     1301 b- defN 22-Dec-08 20:02 cirq_superstaq/serialization.py
--rw-r--r--  2.0 unx     1535 b- defN 22-Dec-08 20:02 cirq_superstaq/serialization_test.py
--rw-r--r--  2.0 unx    19694 b- defN 22-Dec-08 20:02 cirq_superstaq/service.py
--rw-r--r--  2.0 unx    16561 b- defN 22-Dec-08 20:02 cirq_superstaq/service_test.py
--rw-r--r--  2.0 unx    11357 b- defN 22-Dec-08 20:02 cirq_superstaq-0.3.9.dist-info/LICENSE
--rw-r--r--  2.0 unx     2271 b- defN 22-Dec-08 20:02 cirq_superstaq-0.3.9.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Dec-08 20:02 cirq_superstaq-0.3.9.dist-info/WHEEL
--rw-r--r--  2.0 unx       15 b- defN 22-Dec-08 20:02 cirq_superstaq-0.3.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1809 b- defN 22-Dec-08 20:02 cirq_superstaq-0.3.9.dist-info/RECORD
-21 files, 150922 bytes uncompressed, 37548 bytes compressed:  75.1%
+Zip file size: 52535 bytes, number of entries: 23
+-rw-r--r--  2.0 unx     2495 b- defN 23-Jun-27 19:52 cirq_superstaq/__init__.py
+-rw-r--r--  2.0 unx       22 b- defN 23-Jun-27 19:52 cirq_superstaq/_version.py
+-rw-r--r--  2.0 unx      288 b- defN 23-Jun-27 19:52 cirq_superstaq/_version_test.py
+-rw-r--r--  2.0 unx    11725 b- defN 23-Jun-27 19:52 cirq_superstaq/compiler_output.py
+-rw-r--r--  2.0 unx    13819 b- defN 23-Jun-27 19:52 cirq_superstaq/compiler_output_test.py
+-rw-r--r--  2.0 unx     9741 b- defN 23-Jun-27 19:52 cirq_superstaq/daily_integration_test.py
+-rw-r--r--  2.0 unx     6815 b- defN 23-Jun-27 19:52 cirq_superstaq/job.py
+-rw-r--r--  2.0 unx     6680 b- defN 23-Jun-27 19:52 cirq_superstaq/job_test.py
+-rw-r--r--  2.0 unx       68 b- defN 23-Jun-27 19:52 cirq_superstaq/py.typed
+-rw-r--r--  2.0 unx     3087 b- defN 23-Jun-27 19:52 cirq_superstaq/sampler.py
+-rw-r--r--  2.0 unx     1398 b- defN 23-Jun-27 19:52 cirq_superstaq/serialization.py
+-rw-r--r--  2.0 unx     1580 b- defN 23-Jun-27 19:52 cirq_superstaq/serialization_test.py
+-rw-r--r--  2.0 unx    28103 b- defN 23-Jun-27 19:52 cirq_superstaq/service.py
+-rw-r--r--  2.0 unx    23104 b- defN 23-Jun-27 19:52 cirq_superstaq/service_test.py
+-rw-r--r--  2.0 unx     1297 b- defN 23-Jun-27 19:52 cirq_superstaq/ops/__init__.py
+-rw-r--r--  2.0 unx    31937 b- defN 23-Jun-27 19:52 cirq_superstaq/ops/qubit_gates.py
+-rw-r--r--  2.0 unx    38554 b- defN 23-Jun-27 19:52 cirq_superstaq/ops/qubit_gates_test.py
+-rw-r--r--  2.0 unx    19196 b- defN 23-Jun-27 19:52 cirq_superstaq/ops/qudit_gates.py
+-rw-r--r--  2.0 unx    16965 b- defN 23-Jun-27 19:52 cirq_superstaq/ops/qudit_gates_test.py
+-rw-r--r--  2.0 unx     2329 b- defN 23-Jun-27 19:53 cirq_superstaq-0.4.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-27 19:53 cirq_superstaq-0.4.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       15 b- defN 23-Jun-27 19:53 cirq_superstaq-0.4.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1995 b- defN 23-Jun-27 19:53 cirq_superstaq-0.4.0.dist-info/RECORD
+23 files, 221305 bytes uncompressed, 49287 bytes compressed:  77.7%
```

## zipnote {}

```diff
@@ -9,20 +9,14 @@
 
 Filename: cirq_superstaq/compiler_output.py
 Comment: 
 
 Filename: cirq_superstaq/compiler_output_test.py
 Comment: 
 
-Filename: cirq_superstaq/custom_gates.py
-Comment: 
-
-Filename: cirq_superstaq/custom_gates_test.py
-Comment: 
-
 Filename: cirq_superstaq/daily_integration_test.py
 Comment: 
 
 Filename: cirq_superstaq/job.py
 Comment: 
 
 Filename: cirq_superstaq/job_test.py
@@ -42,23 +36,35 @@
 
 Filename: cirq_superstaq/service.py
 Comment: 
 
 Filename: cirq_superstaq/service_test.py
 Comment: 
 
-Filename: cirq_superstaq-0.3.9.dist-info/LICENSE
+Filename: cirq_superstaq/ops/__init__.py
+Comment: 
+
+Filename: cirq_superstaq/ops/qubit_gates.py
+Comment: 
+
+Filename: cirq_superstaq/ops/qubit_gates_test.py
+Comment: 
+
+Filename: cirq_superstaq/ops/qudit_gates.py
+Comment: 
+
+Filename: cirq_superstaq/ops/qudit_gates_test.py
 Comment: 
 
-Filename: cirq_superstaq-0.3.9.dist-info/METADATA
+Filename: cirq_superstaq-0.4.0.dist-info/METADATA
 Comment: 
 
-Filename: cirq_superstaq-0.3.9.dist-info/WHEEL
+Filename: cirq_superstaq-0.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: cirq_superstaq-0.3.9.dist-info/top_level.txt
+Filename: cirq_superstaq-0.4.0.dist-info/top_level.txt
 Comment: 
 
-Filename: cirq_superstaq-0.3.9.dist-info/RECORD
+Filename: cirq_superstaq-0.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cirq_superstaq/__init__.py

```diff
@@ -8,55 +8,103 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from cirq_superstaq import compiler_output, serialization
+from cirq_superstaq import compiler_output
 from cirq_superstaq._version import __version__
-from cirq_superstaq.compiler_output import active_qubit_indices
-from cirq_superstaq.custom_gates import (
+from cirq_superstaq.compiler_output import active_qubit_indices, measured_qubit_indices
+from cirq_superstaq.job import Job
+from cirq_superstaq.ops import (
     AQTICCX,
     AQTITOFFOLI,
+    BSWAP,
+    BSWAP_INV,
     CR,
+    CZ3,
+    CZ3_INV,
+    SWAP3,
     ZX,
     AceCR,
     AceCRMinusPlus,
     AceCRPlusMinus,
     Barrier,
+    BSwapPowGate,
     ParallelGates,
     ParallelRGate,
+    QubitSubspaceGate,
+    QuditSwapGate,
+    QutritCZPowGate,
+    QutritZ0,
+    QutritZ0PowGate,
+    QutritZ1,
+    QutritZ1PowGate,
+    QutritZ2,
+    QutritZ2PowGate,
     RGate,
+    StrippedCZGate,
     ZXPowGate,
     ZZSwapGate,
+    approx_eq_mod,
     barrier,
     parallel_gates_operation,
+    qubit_subspace_op,
+    qudit_swap_op,
 )
-from cirq_superstaq.job import Job
 from cirq_superstaq.sampler import Sampler
+from cirq_superstaq.serialization import (
+    SUPERSTAQ_RESOLVERS,
+    deserialize_circuits,
+    serialize_circuits,
+)
 from cirq_superstaq.service import Service
 
 __all__ = [
-    "__version__",
-    "active_qubit_indices",
+    "AQTICCX",
+    "AQTITOFFOLI",
     "AceCR",
     "AceCRMinusPlus",
     "AceCRPlusMinus",
-    "barrier",
+    "BSWAP",
+    "BSWAP_INV",
+    "BSwapPowGate",
     "Barrier",
-    "compiler_output",
     "CR",
-    "AQTICCX",
-    "AQTITOFFOLI",
+    "CZ3",
+    "CZ3_INV",
     "Job",
+    "measured_qubit_indices",
     "ParallelGates",
     "ParallelRGate",
-    "parallel_gates_operation",
-    "serialization",
+    "QubitSubspaceGate",
+    "QuditSwapGate",
+    "QutritCZPowGate",
+    "QutritZ0",
+    "QutritZ0PowGate",
+    "QutritZ1",
+    "QutritZ1PowGate",
+    "QutritZ2",
+    "QutritZ2PowGate",
     "RGate",
+    "SUPERSTAQ_RESOLVERS",
     "Sampler",
     "Service",
+    "StrippedCZGate",
+    "SWAP3",
     "ZX",
     "ZXPowGate",
     "ZZSwapGate",
+    "__version__",
+    "active_qubit_indices",
+    "approx_eq_mod",
+    "barrier",
+    "compiler_output",
+    "deserialize_circuits",
+    "ops",
+    "parallel_gates_operation",
+    "qubit_subspace_op",
+    "qudit_swap_op",
+    "serialization",
+    "serialize_circuits",
 ]
```

## cirq_superstaq/_version.py

```diff
@@ -1 +1 @@
-__version__ = "0.3.9"
+__version__ = "0.4.0"
```

## cirq_superstaq/_version_test.py

```diff
@@ -1,7 +1,8 @@
+# pylint: disable=missing-function-docstring
 import packaging.version
 
 import cirq_superstaq as css
 
 
 def test_version() -> None:
     assert (
```

## cirq_superstaq/compiler_output.py

```diff
@@ -1,7 +1,9 @@
+from __future__ import annotations
+
 import importlib
 import json
 import warnings
 from typing import Any, Dict, List, Optional, Set, Union
 
 import cirq
 import general_superstaq as gss
@@ -11,15 +13,17 @@
 try:
     import qtrl.sequence_utils.readout
 except ModuleNotFoundError:
     pass
 
 
 def active_qubit_indices(circuit: cirq.AbstractCircuit) -> List[int]:
-    """Returns the indices of the non-idle qubits in a quantum circuit."""
+    """Returns the indices of the non-idle qubits in a quantum circuit, where "index" refers to the
+    argument of a LineQubit (so e.g. cirq.LineQubit(5) has index 5 regardless of the total number
+    of qubits in the circuit)."""
 
     all_qubits: Set[cirq.Qid] = set()
     for op in circuit.all_operations():
         if not isinstance(op.gate, css.Barrier):
             all_qubits.update(op.qubits)
 
     qubit_indices: List[int] = []
@@ -27,30 +31,71 @@
         if not isinstance(q, (cirq.LineQubit, cirq.LineQid)):
             raise ValueError("Qubit indices can only be determined for line qubits")
         qubit_indices.append(int(q))
 
     return qubit_indices
 
 
+def measured_qubit_indices(circuit: cirq.AbstractCircuit) -> List[int]:
+    """Returns the indices of the measured qubits in a quantum circuit, where "index" refers to the
+    argument of a LineQubit (so e.g. cirq.LineQubit(5) has index 5 regardless of the total number
+    of qubits in the circuit)."""
+
+    unrolled_circuit = cirq.unroll_circuit_op(circuit, deep=True, tags_to_check=None)
+
+    measured_qubits: Set[cirq.Qid] = set()
+    for _, op in unrolled_circuit.findall_operations(cirq.is_measurement):
+        measured_qubits.update(op.qubits)
+
+    qubit_indices: Set[int] = set()
+    for q in measured_qubits:
+        if not isinstance(q, (cirq.LineQubit, cirq.LineQid)):
+            raise ValueError("Qubit indices can only be determined for line qubits")
+        qubit_indices.add(int(q))
+
+    return sorted(qubit_indices)
+
+
 class CompilerOutput:
+    """A class that arranges compiled circuit information."""
+
     def __init__(
         self,
         circuits: Union[cirq.Circuit, List[cirq.Circuit], List[List[cirq.Circuit]]],
+        final_logical_to_physicals: Union[
+            Dict[cirq.Qid, cirq.Qid],
+            List[Dict[cirq.Qid, cirq.Qid]],
+            List[List[Dict[cirq.Qid, cirq.Qid]]],
+        ],
         pulse_sequences: Optional[Any] = None,
-        seq: Optional["qtrl.sequencer.Sequence"] = None,
+        seq: Optional[qtrl.sequencer.Sequence] = None,
         jaqal_programs: Optional[Union[List[str], str]] = None,
         pulse_lists: Optional[Union[List[List[List[Any]]], List[List[List[List[Any]]]]]] = None,
     ) -> None:
+        """Initializes class attributes.
+
+        Args:
+            circuits: A list (of at most 2 dimensions) containing `cirq.Circuit` objects.
+            final_logical_to_physicals: Post-compilation mapping of logical qubits to physical
+                qubits.
+            pulse_sequences: Qiskit pulse schedules for the compiled circuit(s).
+            seq: Qtrl pulse sequence, if qtrl is available locally.
+            jaqal_programs: The Jaqal program (resp. programs) as a string (resp. list of
+                strings).
+            pulse_lists: Either 3 or 4 dimensional lists of pulse cycles.
+        """
         if isinstance(circuits, cirq.Circuit):
             self.circuit = circuits
+            self.final_logical_to_physical = final_logical_to_physicals
             self.pulse_list = pulse_lists
             self.pulse_sequence = pulse_sequences
             self.jaqal_program = jaqal_programs
         else:
             self.circuits = circuits
+            self.final_logical_to_physicals = final_logical_to_physicals
             self.pulse_lists = pulse_lists
             self.pulse_sequences = pulse_sequences
             self.jaqal_programs = jaqal_programs
 
         self.seq = seq
 
     def has_multiple_circuits(self) -> bool:
@@ -60,84 +105,110 @@
         represents a single circuit, and has .circuit and .pulse_list attributes.
         """
         return hasattr(self, "circuits")
 
     def __repr__(self) -> str:
         if not self.has_multiple_circuits():
             return (
-                f"CompilerOutput({self.circuit!r}, {self.pulse_sequence!r}, {self.seq!r}, "
-                f"{self.jaqal_program!r}, {self.pulse_list!r})"
+                f"CompilerOutput({self.circuit!r}, {self.final_logical_to_physical!r}, "
+                f"{self.pulse_sequence!r}, {self.seq!r}, {self.jaqal_program!r}, "
+                f"{self.pulse_list!r})"
             )
         return (
-            f"CompilerOutput({self.circuits!r}, {self.pulse_sequences!r}, {self.seq!r}, "
-            f"{self.jaqal_programs!r}, {self.pulse_lists!r})"
+            f"CompilerOutput({self.circuits!r}, {self.final_logical_to_physicals!r}, "
+            f"{self.pulse_sequences!r}, {self.seq!r}, {self.jaqal_programs!r}, "
+            f"{self.pulse_lists!r})"
         )
 
 
-def read_json_ibmq(json_dict: Dict[str, Any], circuits_is_list: bool) -> CompilerOutput:
-    """Reads out returned JSON from SuperstaQ API's IBMQ compilation endpoint.
+def read_json(json_dict: Dict[str, Any], circuits_is_list: bool) -> CompilerOutput:
+    """Reads out returned JSON from Superstaq API's IBMQ compilation endpoint.
 
     Args:
         json_dict: a JSON dictionary matching the format returned by /ibmq_compile endpoint
         circuits_is_list: bool flag that controls whether the returned object has a .circuits
             attribute (if True) or a .circuit attribute (False)
     Returns:
         a CompilerOutput object with the compiled circuit(s). If qiskit is available locally,
         the returned object also stores the pulse sequences in the .pulse_sequence(s) attribute.
     """
     compiled_circuits = css.serialization.deserialize_circuits(json_dict["cirq_circuits"])
+    final_logical_to_physicals: List[Dict[cirq.Qid, cirq.Qid]] = list(
+        map(dict, cirq.read_json(json_text=json_dict["final_logical_to_physicals"]))
+    )
     pulses = None
 
-    if importlib.util.find_spec("qiskit"):
-        import qiskit
-
-        if "0.20" < qiskit.__version__ < "0.21":
-            pulses = gss.serialization.deserialize(json_dict["pulses"])
+    if "pulses" in json_dict:
+        if importlib.util.find_spec("qiskit") and importlib.util.find_spec("qiskit.qpy"):
+            import qiskit
+
+            if "0.24" < qiskit.__version__ < "0.25":
+                pulses = gss.serialization.deserialize(json_dict["pulses"])
+            else:
+                warnings.warn(
+                    "ibmq_compile requires Qiskit Terra version 0.24.* to deserialize compiled "
+                    f"pulse sequences (you have {qiskit.__version__})."
+                )
         else:
             warnings.warn(
-                "ibmq_compile requires Qiskit Terra version 0.20.* to deserialize compiled pulse "
-                f"sequences (you have {qiskit.__version__})."
+                "ibmq_compile requires Qiskit Terra version 0.24.* to deserialize compiled pulse "
+                "sequences."
             )
-    else:
-        warnings.warn(
-            "ibmq_compile requires Qiskit Terra version 0.20.* to deserialize compiled pulse "
-            "sequences."
-        )
 
     if circuits_is_list:
-        return CompilerOutput(circuits=compiled_circuits, pulse_sequences=pulses)
-    return CompilerOutput(circuits=compiled_circuits[0], pulse_sequences=pulses and pulses[0])
+        return CompilerOutput(compiled_circuits, final_logical_to_physicals, pulse_sequences=pulses)
+    return CompilerOutput(
+        compiled_circuits[0], final_logical_to_physicals[0], pulse_sequences=pulses and pulses[0]
+    )
 
 
-def read_json_aqt(
-    json_dict: Dict[str, Any], circuits_is_list: bool, num_eca_circuits: int = 0
+def read_json_aqt(  # pylint: disable=missing-param-doc
+    json_dict: Dict[str, Any], circuits_is_list: bool, num_eca_circuits: Optional[int] = None
 ) -> CompilerOutput:
-    """Reads out returned JSON from SuperstaQ API's AQT compilation endpoint.
+    """Reads out returned JSON from Superstaq API's AQT compilation endpoint.
 
     Args:
-        json_dict: a JSON dictionary matching the format returned by /aqt_compile endpoint
-        circuits_is_list: bool flag that controls whether the returned object has a .circuits
-            attribute (if True) or a .circuit attribute (False)
+        json_dict: JSON dictionary matching the format returned by aqt_compile endpoint.
+        circuits_is_list: Bool flag that controls whether the returned object has a .circuits
+            attribute (if True) or a .circuit attribute (False).
+        num_eca_circuits: Number of logically equivalent random circuits to generate for each
+            input circuit.
     Returns:
-        a CompilerOutput object with the compiled circuit(s). If qtrl is available locally,
+        A CompilerOutput object with the compiled circuit(s). If qtrl is available locally,
         the returned object also stores the pulse sequence in the .seq attribute and the
         list(s) of cycles in the .pulse_list(s) attribute.
     """
 
     compiled_circuits: Union[List[cirq.Circuit], List[List[cirq.Circuit]]]
     compiled_circuits = css.serialization.deserialize_circuits(json_dict["cirq_circuits"])
 
+    final_logical_to_physicals_list: List[Dict[cirq.Qid, cirq.Qid]] = list(
+        map(dict, cirq.read_json(json_text=json_dict["final_logical_to_physicals"]))
+    )
+    final_logical_to_physicals: Union[
+        List[Dict[cirq.Qid, cirq.Qid]], List[List[Dict[cirq.Qid, cirq.Qid]]]
+    ] = final_logical_to_physicals_list
+
     seq = None
     pulse_lists = None
 
-    if importlib.util.find_spec(
-        "qtrl"
-    ):  # pragma: no cover, b/c qtrl is not open source so it is not in cirq-superstaq reqs
+    if "state_jp" not in json_dict:
+        warnings.warn(
+            "This output only contains compiled circuits (using a default AQT gate set). To "
+            "get back the corresponding pulse sequence, you must first upload your qtrl configs "
+            "using `service.aqt_upload_configs`."
+        )
+    elif not importlib.util.find_spec("qtrl"):
+        warnings.warn(
+            "This output only contains compiled circuits. The qtrl package must be installed in "
+            "order to deserialize compiled pulse sequences."
+        )
+    else:  # pragma: no cover, b/c qtrl is not open source so it is not in cirq-superstaq reqs
 
-        def _sequencer_from_state(state: Dict[str, Any]) -> "qtrl.sequencer.Sequence":
+        def _sequencer_from_state(state: Dict[str, Any]) -> qtrl.sequencer.Sequence:
             seq = qtrl.sequencer.Sequence(n_elements=1)
             seq.__setstate__(state)
             seq.compile()
             return seq
 
         pulse_lists = gss.serialization.deserialize(json_dict["pulse_lists_jp"])
         state = gss.serialization.deserialize(json_dict["state_jp"])
@@ -152,66 +223,61 @@
                     readout_seq, readout_qubits, n_readouts=len(compiled_circuits)
                 )
 
             state["_readout"] = readout_seq
 
         seq = _sequencer_from_state(state)
 
-    if num_eca_circuits:
+    if num_eca_circuits is not None:
         compiled_circuits = [
             compiled_circuits[i : i + num_eca_circuits]
             for i in range(0, len(compiled_circuits), num_eca_circuits)
         ]
-
+        final_logical_to_physicals = [
+            final_logical_to_physicals_list[i : i + num_eca_circuits]
+            for i in range(0, len(final_logical_to_physicals_list), num_eca_circuits)
+        ]
         pulse_lists = pulse_lists and [
             pulse_lists[i : i + num_eca_circuits]
             for i in range(0, len(pulse_lists), num_eca_circuits)
         ]
 
     if circuits_is_list:
-        return CompilerOutput(circuits=compiled_circuits, seq=seq, pulse_lists=pulse_lists)
+        return CompilerOutput(
+            compiled_circuits, final_logical_to_physicals, seq=seq, pulse_lists=pulse_lists
+        )
 
     pulse_lists = pulse_lists[0] if pulse_lists is not None else None
-    return CompilerOutput(circuits=compiled_circuits[0], seq=seq, pulse_lists=pulse_lists)
+    return CompilerOutput(
+        compiled_circuits[0], final_logical_to_physicals[0], seq=seq, pulse_lists=pulse_lists
+    )
 
 
 def read_json_qscout(json_dict: Dict[str, Any], circuits_is_list: bool) -> CompilerOutput:
-    """Reads out returned JSON from SuperstaQ API's QSCOUT compilation endpoint.
+    """Reads out returned JSON from Superstaq API's QSCOUT compilation endpoint.
 
     Args:
         json_dict: a JSON dictionary matching the format returned by /qscout_compile endpoint
         circuits_is_list: bool flag that controls whether the returned object has a .circuits
             attribute (if True) or a .circuit attribute (False)
     Returns:
         a CompilerOutput object with the compiled circuit(s) and a list jaqal programs
         represented as strings
     """
 
     compiled_circuits = css.serialization.deserialize_circuits(json_dict["cirq_circuits"])
+    final_logical_to_physicals: List[Dict[cirq.Qid, cirq.Qid]] = list(
+        map(dict, cirq.read_json(json_text=json_dict["final_logical_to_physicals"]))
+    )
 
     if circuits_is_list:
         return CompilerOutput(
-            circuits=compiled_circuits, jaqal_programs=json_dict["jaqal_programs"]
+            circuits=compiled_circuits,
+            final_logical_to_physicals=final_logical_to_physicals,
+            jaqal_programs=json_dict["jaqal_programs"],
         )
 
     return CompilerOutput(
-        circuits=compiled_circuits[0], jaqal_programs=json_dict["jaqal_programs"][0]
+        circuits=compiled_circuits[0],
+        final_logical_to_physicals=final_logical_to_physicals[0],
+        jaqal_programs=json_dict["jaqal_programs"][0],
     )
-
-
-def read_json_only_circuits(json_dict: Dict[str, Any], circuits_is_list: bool) -> CompilerOutput:
-    """Reads out returned JSON from SuperstaQ API's CQ compilation endpoint.
-
-    Args:
-        json_dict: a JSON dictionary matching the format returned by /cq_compile endpoint
-        circuits_is_list: bool flag that controls whether the returned object has a .circuits
-            attribute (if True) or a .circuit attribute (False)
-    Returns:
-        a CompilerOutput object with the compiled circuit(s)
-    """
-
-    compiled_circuits = css.serialization.deserialize_circuits(json_dict["cirq_circuits"])
-
-    if circuits_is_list:
-        return CompilerOutput(circuits=compiled_circuits)
-
-    return CompilerOutput(circuits=compiled_circuits[0])
```

## cirq_superstaq/compiler_output_test.py

```diff
@@ -1,10 +1,12 @@
+# pylint: disable=missing-function-docstring
 import importlib
 import pickle
 import textwrap
+from typing import Dict
 from unittest import mock
 
 import cirq
 import general_superstaq as gss
 import pytest
 
 import cirq_superstaq as css
@@ -22,110 +24,221 @@
 
     assert css.active_qubit_indices(circuit) == [1, 3, 5]
 
     with pytest.raises(ValueError, match="line qubits"):
         _ = css.active_qubit_indices(cirq.Circuit(cirq.X(cirq.GridQubit(1, 2))))
 
 
+def test_measured_qubit_indices() -> None:
+
+    # Create qubits with indices [0, 1, 2, 3, 5, 6]. No q4 to ensure that indices refer to
+    # LineQubit arguments regardless of the number of qubits in the circuit
+    q0, q1, q2, q3, _, q5, q6 = cirq.LineQubit.range(7)
+
+    circuit = cirq.Circuit(
+        cirq.X(q0),
+        cirq.measure(q1),
+        cirq.CX(q1, q2),
+        cirq.measure(q6, q5),
+        cirq.measure(q1, q3),  # (q1 was already measured)
+        cirq.measure(q5, q1),  # (both were already measured)
+    )
+    assert css.measured_qubit_indices(circuit) == [1, 3, 5, 6]
+
+
+def test_measured_qubit_indices_with_circuit_operations() -> None:
+    """Check that measurements in CircuitOperations are mapped correctly."""
+
+    # Create qubits with indices [0, 1, 2, 3, 5, 6]. No q4 to ensure that indices refer to
+    # LineQubit arguments regardless of the number of qubits in the circuit
+    q0, q1, q2, q3, _, q5, q6 = cirq.LineQubit.range(7)
+
+    subcircuit = cirq.FrozenCircuit(cirq.X(q0), cirq.measure(q2, q3))
+    assert css.measured_qubit_indices(subcircuit) == [2, 3]
+
+    # Create a CircuitOperation with no qubit mapping (measurements don't move)
+    subcircuit_op_no_map = cirq.CircuitOperation(subcircuit)
+    assert css.measured_qubit_indices(subcircuit_op_no_map.mapped_circuit()) == [2, 3]
+
+    # Create a CircuitOperation with a nontrivial map. Measurements (q2, q3) should land on (q5, q3)
+    subcircuit_op_mapped = cirq.CircuitOperation(subcircuit).with_qubit_mapping({q1: q6, q2: q5})
+    assert css.measured_qubit_indices(subcircuit_op_mapped.mapped_circuit()) == [3, 5]
+
+    # Check that measured_qubit_indices() respects the qubit mapping
+    circuit = cirq.Circuit(cirq.measure(q1))
+    assert css.measured_qubit_indices(circuit) == [1]
+    assert css.measured_qubit_indices(circuit + subcircuit_op_no_map) == [1, 2, 3]  # no mapping
+    assert css.measured_qubit_indices(circuit + subcircuit_op_mapped) == [1, 3, 5]  # with mapping
+
+    # Double-check that measurement indices are the same after unrolling subcircuit's qubit mapping
+    unrolled_circuit = cirq.unroll_circuit_op(circuit + subcircuit_op_mapped, tags_to_check=None)
+    assert css.measured_qubit_indices(unrolled_circuit) == [1, 3, 5]
+
+    with pytest.raises(ValueError, match="line qubits"):
+        _ = css.measured_qubit_indices(cirq.Circuit(cirq.measure(cirq.GridQubit(1, 2))))
+
+
 def test_compiler_output_repr() -> None:
     circuit = cirq.Circuit()
+    qubit_map: Dict[cirq.Qid, cirq.Qid] = {}
     assert (
-        repr(css.compiler_output.CompilerOutput(circuit))
-        == f"CompilerOutput({circuit!r}, None, None, None, None)"
+        repr(css.compiler_output.CompilerOutput(circuit, qubit_map))
+        == f"CompilerOutput({circuit!r}, {{}}, None, None, None, None)"
     )
 
     circuits = [circuit, circuit]
     assert (
-        repr(css.compiler_output.CompilerOutput(circuits))
-        == f"CompilerOutput({circuits!r}, None, None, None, None)"
+        repr(css.compiler_output.CompilerOutput(circuits, [qubit_map]))
+        == f"CompilerOutput({circuits!r}, [{{}}], None, None, None, None)"
     )
 
 
+def test_read_json() -> None:
+    q0 = cirq.LineQubit(0)
+    circuit = cirq.Circuit(cirq.H(q0), cirq.measure(q0))
+    final_logical_to_physical = {cirq.q(0): cirq.q(13)}
+
+    json_dict = {
+        "cirq_circuits": css.serialization.serialize_circuits(circuit),
+        "final_logical_to_physicals": cirq.to_json([list(final_logical_to_physical.items())]),
+    }
+
+    out = css.compiler_output.read_json(json_dict, circuits_is_list=False)
+    assert out.circuit == circuit
+    assert out.final_logical_to_physical == final_logical_to_physical
+    assert not hasattr(out, "circuits")
+    assert not hasattr(out, "final_logical_to_physicals")
+
+    out = css.compiler_output.read_json(json_dict, circuits_is_list=True)
+    assert out.circuits == [circuit]
+    assert out.final_logical_to_physicals == [final_logical_to_physical]
+    assert not hasattr(out, "circuit")
+    assert not hasattr(out, "final_logical_to_physical")
+
+
 def test_read_json_ibmq() -> None:
     q0 = cirq.LineQubit(0)
     circuit = cirq.Circuit(cirq.H(q0), cirq.measure(q0))
+    final_logical_to_physical = {cirq.q(0): cirq.q(13)}
 
     json_dict = {
         "cirq_circuits": css.serialization.serialize_circuits(circuit),
         "pulses": gss.serialization.serialize([mock.DEFAULT]),
+        "final_logical_to_physicals": cirq.to_json([list(final_logical_to_physical.items())]),
     }
 
-    out = css.compiler_output.read_json_ibmq(json_dict, circuits_is_list=False)
+    out = css.compiler_output.read_json(json_dict, circuits_is_list=False)
     assert out.circuit == circuit
     assert out.pulse_sequence == mock.DEFAULT
+    assert out.final_logical_to_physical == final_logical_to_physical
     assert not hasattr(out, "circuits")
     assert not hasattr(out, "pulse_sequences")
+    assert not hasattr(out, "final_logical_to_physicals")
 
-    out = css.compiler_output.read_json_ibmq(json_dict, circuits_is_list=True)
+    out = css.compiler_output.read_json(json_dict, circuits_is_list=True)
     assert out.circuits == [circuit]
     assert out.pulse_sequences == [mock.DEFAULT]
+    assert out.final_logical_to_physicals == [final_logical_to_physical]
     assert not hasattr(out, "circuit")
     assert not hasattr(out, "pulse_sequence")
+    assert not hasattr(out, "final_logical_to_physical")
 
     with mock.patch.dict("sys.modules", {"qiskit": None}), pytest.warns(
         UserWarning, match="requires Qiskit Terra"
     ):
-        out = css.compiler_output.read_json_ibmq(json_dict, circuits_is_list=False)
+        out = css.compiler_output.read_json(json_dict, circuits_is_list=False)
         assert out.circuit == circuit
         assert out.pulse_sequence is None
 
     with mock.patch("qiskit.__version__", "0.17.2"), pytest.warns(
         UserWarning, match="you have 0.17.2"
     ):
-        out = css.compiler_output.read_json_ibmq(json_dict, circuits_is_list=True)
+        out = css.compiler_output.read_json(json_dict, circuits_is_list=True)
         assert out.circuits == [circuit]
         assert out.pulse_sequences is None
 
 
 @mock.patch.dict("sys.modules", {"qtrl": None})
 def test_read_json_aqt() -> None:
     importlib.reload(css.compiler_output)
 
     qubits = cirq.LineQubit.range(4)
     circuit = cirq.Circuit(cirq.H.on_each(*qubits), cirq.measure(*qubits))
     state_str = gss.serialization.serialize({})
     pulse_lists_str = gss.serialization.serialize([[[]]])
+    final_logical_to_physical = {cirq.q(0): cirq.q(4)}
 
     json_dict = {
         "cirq_circuits": css.serialization.serialize_circuits(circuit),
         "state_jp": state_str,
         "pulse_lists_jp": pulse_lists_str,
+        "final_logical_to_physicals": cirq.to_json([list(final_logical_to_physical.items())]),
     }
 
-    out = css.compiler_output.read_json_aqt(json_dict, circuits_is_list=False)
+    with pytest.warns(UserWarning, match="deserialize compiled pulse sequences"):
+        out = css.compiler_output.read_json_aqt(json_dict, circuits_is_list=False)
+
     assert out.circuit == circuit
+    assert out.final_logical_to_physical == final_logical_to_physical
     assert not hasattr(out, "circuits")
+    assert not hasattr(out, "final_logical_to_physicals")
+
+    with pytest.warns(UserWarning, match="deserialize compiled pulse sequences"):
+        out = css.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
 
-    out = css.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
     assert out.circuits == [circuit]
+    assert out.final_logical_to_physicals == [final_logical_to_physical]
     assert not hasattr(out, "circuit")
+    assert not hasattr(out, "final_logical_to_physical")
+
+    with pytest.warns(UserWarning, match="deserialize compiled pulse sequences"):
+        out = css.compiler_output.read_json_aqt(json_dict, circuits_is_list=False)
+
+    assert out.circuit == circuit
+    assert out.seq is None
 
     # multiple circuits
     pulse_lists_str = gss.serialization.serialize([[[]], [[]]])
     json_dict = {
         "cirq_circuits": css.serialization.serialize_circuits([circuit, circuit]),
         "state_jp": state_str,
         "pulse_lists_jp": pulse_lists_str,
+        "final_logical_to_physicals": cirq.to_json(2 * [list(final_logical_to_physical.items())]),
     }
-    out = css.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
+
+    with pytest.warns(UserWarning, match="deserialize compiled pulse sequences"):
+        out = css.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
+
     assert out.circuits == [circuit, circuit]
+    assert out.final_logical_to_physicals == [final_logical_to_physical, final_logical_to_physical]
     assert not hasattr(out, "circuit")
+    assert not hasattr(out, "final_logical_to_physical")
+
+    # no sequence returned
+    json_dict.pop("state_jp")
+
+    with pytest.warns(UserWarning, match="aqt_upload_configs"):
+        out = css.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
+
+    assert out.seq is None
 
 
 def test_read_json_with_qtrl() -> None:  # pragma: no cover, b/c test requires qtrl installation
     qtrl = pytest.importorskip("qtrl", reason="qtrl not installed")
     seq = qtrl.sequencer.Sequence(n_elements=1)
+    final_logical_to_physical = {cirq.q(0): cirq.q(4)}
 
     circuit = cirq.Circuit(cirq.H(cirq.LineQubit(4)))
     state_str = gss.serialization.serialize(seq.__getstate__())
     pulse_lists_str = gss.serialization.serialize([[[]]])
     json_dict = {
         "cirq_circuits": css.serialization.serialize_circuits(circuit),
         "state_jp": state_str,
         "pulse_lists_jp": pulse_lists_str,
+        "final_logical_to_physicals": cirq.to_json([list(final_logical_to_physical.items())]),
     }
 
     out = css.compiler_output.read_json_aqt(json_dict, circuits_is_list=False)
     assert out.circuit == circuit
     assert isinstance(out.seq, qtrl.sequencer.Sequence)
     assert pickle.dumps(out.seq) == pickle.dumps(seq)
     assert out.pulse_list == [[]]
@@ -157,14 +270,15 @@
     pulse_lists_str = gss.serialization.serialize([[[]], [[]]])
     json_dict = {
         "cirq_circuits": css.serialization.serialize_circuits([circuit, circuit]),
         "state_jp": state_str,
         "pulse_lists_jp": pulse_lists_str,
         "readout_jp": state_str,
         "readout_qubits": "[4, 5, 6, 7]",
+        "final_logical_to_physicals": cirq.to_json(2 * [list(final_logical_to_physical.items())]),
     }
     out = css.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
     assert out.circuits == [circuit, circuit]
     assert pickle.dumps(out.seq) == pickle.dumps(seq)
     assert out.pulse_lists == [[[]], [[]]]
     assert isinstance(out.seq, qtrl.sequencer.Sequence)
     assert isinstance(out.seq._readout, qtrl.sequencer.Sequence)
@@ -174,54 +288,43 @@
     assert out.seq._readout._readout.n_readouts == 2
     assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
 
 
 def test_read_json_qscout() -> None:
     q0 = cirq.LineQubit(0)
     circuit = cirq.Circuit(cirq.H(q0), cirq.measure(q0))
+    final_logical_to_physical = {cirq.q(0): cirq.q(13)}
 
     jaqal_program = textwrap.dedent(
         """\
         register allqubits[1]
         prepare_all
         R allqubits[0] -1.5707963267948966 1.5707963267948966
         Rz allqubits[0] -3.141592653589793
         measure_all
         """
     )
 
     json_dict = {
         "cirq_circuits": css.serialization.serialize_circuits(circuit),
+        "final_logical_to_physicals": cirq.to_json([list(final_logical_to_physical.items())]),
         "jaqal_programs": [jaqal_program],
     }
 
     out = css.compiler_output.read_json_qscout(json_dict, circuits_is_list=False)
     assert out.circuit == circuit
+    assert out.final_logical_to_physical == final_logical_to_physical
     assert out.jaqal_program == jaqal_program
+    assert not hasattr(out, "final_logical_to_physicals")
     assert not hasattr(out, "jaqal_programs")
 
     json_dict = {
         "cirq_circuits": css.serialization.serialize_circuits([circuit, circuit]),
+        "final_logical_to_physicals": cirq.to_json([list(final_logical_to_physical.items())]),
         "jaqal_programs": [jaqal_program, jaqal_program],
     }
     out = css.compiler_output.read_json_qscout(json_dict, circuits_is_list=True)
     assert out.circuits == [circuit, circuit]
+    assert out.final_logical_to_physicals == [final_logical_to_physical]
     assert out.jaqal_programs == json_dict["jaqal_programs"]
+    assert not hasattr(out, "final_logical_to_physical")
     assert not hasattr(out, "jaqal_program")
-
-
-def test_read_json_only_circuits() -> None:
-    q0 = cirq.LineQubit(0)
-    circuit = cirq.Circuit(cirq.H(q0), cirq.measure(q0))
-
-    json_dict = {
-        "cirq_circuits": css.serialization.serialize_circuits(circuit),
-    }
-
-    out = css.compiler_output.read_json_only_circuits(json_dict, circuits_is_list=False)
-    assert out.circuit == circuit
-
-    json_dict = {
-        "cirq_circuits": css.serialization.serialize_circuits([circuit, circuit]),
-    }
-    out = css.compiler_output.read_json_only_circuits(json_dict, circuits_is_list=True)
-    assert out.circuits == [circuit, circuit]
```

## cirq_superstaq/daily_integration_test.py

```diff
@@ -1,34 +1,30 @@
 """Integration checks that run daily (via Github action) between client and prod server."""
+# pylint: disable=missing-function-docstring
 
 import os
 
 import cirq
 import pytest
-from general_superstaq import ResourceEstimate, SuperstaQException
+from general_superstaq import ResourceEstimate, SuperstaqException
 
 import cirq_superstaq as css
 
 
 @pytest.fixture
 def service() -> css.Service:
-    token = os.getenv("TEST_USER_TOKEN")
-    service = css.Service(token)
-    return service
+    return css.Service()
 
 
 def test_ibmq_compile(service: css.Service) -> None:
     qubits = cirq.LineQubit.range(2)
     circuit = cirq.Circuit(css.AceCRPlusMinus(qubits[0], qubits[1]))
     out = service.ibmq_compile(circuit, target="ibmq_jakarta_qpu")
     assert isinstance(out.circuit, cirq.Circuit)
     assert out.pulse_sequence is not None
-    assert 800 <= out.pulse_sequence.duration <= 1000  # 896 as of 12/27/2021
-    assert out.pulse_sequence.start_time == 0
-    assert len(out.pulse_sequence) == 5
 
 
 def test_acecr_ibmq_compile(service: css.Service) -> None:
     """Tests ibmq_compile method running without error.
 
     This test was originally written to make sure compilation to ibmq_casablanca would not fail, but
     IBM has since taken casablanca down.
@@ -39,28 +35,22 @@
         css.AceCRMinusPlus(qubits[1], qubits[2]),
         css.AceCRMinusPlus(qubits[2], qubits[3]),
     )
 
     out = service.ibmq_compile(circuit, target="ibmq_jakarta_qpu")
     assert isinstance(out.circuit, cirq.Circuit)
     assert out.pulse_sequence is not None
-    assert out.pulse_sequence.start_time == 0
-    assert len(out.pulse_sequence) == 51
 
     out = service.ibmq_compile(circuit, target="ibmq_perth_qpu")
     assert isinstance(out.circuit, cirq.Circuit)
     assert out.pulse_sequence is not None
-    assert out.pulse_sequence.start_time == 0
-    assert len(out.pulse_sequence) == 54
 
     out = service.ibmq_compile(circuit, target="ibmq_lagos_qpu")
     assert isinstance(out.circuit, cirq.Circuit)
     assert out.pulse_sequence is not None
-    assert out.pulse_sequence.start_time == 0
-    assert len(out.pulse_sequence) == 61
 
 
 def test_aqt_compile(service: css.Service) -> None:
     qubits = cirq.LineQubit.range(8)
     circuit = cirq.Circuit(cirq.H(qubits[4]))
 
     cirq.testing.assert_circuits_with_terminal_measurements_are_equivalent(
@@ -81,69 +71,86 @@
         assert isinstance(compiled_circuit, cirq.Circuit)
         cirq.testing.assert_circuits_with_terminal_measurements_are_equivalent(
             compiled_circuit, circuit, atol=1e-08
         )
 
 
 def test_aqt_compile_eca(service: css.Service) -> None:
-    circuit = cirq.Circuit(cirq.H(cirq.LineQubit(4)))
+    circuit = cirq.Circuit(
+        cirq.H(cirq.LineQubit(4)),
+        cirq.CX(cirq.LineQubit(4), cirq.LineQubit(5)) ** 0.7,
+    )
 
-    eca_circuits = service.aqt_compile_eca(circuit, num_equivalent_circuits=3).circuits
+    eca_circuits = service.aqt_compile(circuit, num_eca_circuits=3, random_seed=123).circuits
     assert len(eca_circuits) == 3
     assert all(isinstance(circuit, cirq.Circuit) for circuit in eca_circuits)
 
-    eca_circuits = service.aqt_compile_eca([circuit, circuit], num_equivalent_circuits=3).circuits
+    # multiple circuits:
+    eca_circuits = service.aqt_compile([circuit, circuit], num_eca_circuits=3).circuits
     assert len(eca_circuits) == 2
     for circuits in eca_circuits:
         assert len(circuits) == 3
         assert all(isinstance(circuit, cirq.Circuit) for circuit in circuits)
 
 
+@pytest.mark.skip(reason="Won't pass until server issue related to this is fixed")
+def test_aqt_compile_eca_regression(service: css.Service) -> None:
+    circuit = cirq.Circuit(
+        cirq.H(cirq.LineQubit(4)),
+        cirq.CX(cirq.LineQubit(4), cirq.LineQubit(5)) ** 0.7,
+    )
+    eca_circuits = service.aqt_compile(circuit, num_eca_circuits=3, random_seed=123).circuits
+    # test with same and different seed
+    assert (
+        eca_circuits == service.aqt_compile(circuit, num_eca_circuits=3, random_seed=123).circuits
+    )
+    assert (
+        eca_circuits != service.aqt_compile(circuit, num_eca_circuits=3, random_seed=456).circuits
+    )
+
+
 def test_get_balance(service: css.Service) -> None:
     balance_str = service.get_balance()
     assert isinstance(balance_str, str)
     assert balance_str.startswith("$")
 
     assert isinstance(service.get_balance(pretty_output=False), float)
 
 
 def test_get_resource_estimate(service: css.Service) -> None:
     q0 = cirq.LineQubit(0)
     q1 = cirq.LineQubit(1)
 
     circuit1 = cirq.Circuit(cirq.CNOT(q0, q1), cirq.H(q0), cirq.measure(q0))
 
-    resource_estimate = service.resource_estimate(circuit1, "neutral_atom_qpu")
+    resource_estimate = service.resource_estimate(circuit1, "ss_unconstrained_simulator")
 
     assert resource_estimate == ResourceEstimate(2, 1, 3)
 
     circuit2 = cirq.Circuit(cirq.H(q1), cirq.CNOT(q0, q1), cirq.CZ(q0, q1), cirq.measure(q1))
 
     circuits = [circuit1, circuit2]
 
-    resource_estimates = service.resource_estimate(circuits, "neutral_atom_qpu")
+    resource_estimates = service.resource_estimate(circuits, "ss_unconstrained_simulator")
 
     assert resource_estimates == [ResourceEstimate(2, 1, 3), ResourceEstimate(2, 2, 4)]
 
 
 def test_ibmq_set_token(service: css.Service) -> None:
-    ibmq_token = os.environ["TEST_USER_IBMQ_TOKEN"]
+    try:
+        ibmq_token = os.environ["TEST_USER_IBMQ_TOKEN"]
+    except KeyError as key:
+        raise KeyError(f"To run the integration tests, please export to {key} a valid IBMQ token")
+
     assert service.ibmq_set_token(ibmq_token) == "Your IBMQ account token has been updated"
 
-    with pytest.raises(SuperstaQException, match="IBMQ token is invalid."):
+    with pytest.raises(SuperstaqException, match="IBMQ token is invalid."):
         assert service.ibmq_set_token("INVALID_TOKEN")
 
 
-def test_tsp(service: css.Service) -> None:
-    cities = ["Chicago", "San Francisco", "New York City", "New Orleans"]
-    out = service.tsp(cities)
-    for city in cities:
-        assert city.replace(" ", "+") in out.map_link[0]
-
-
 def test_get_targets(service: css.Service) -> None:
     result = service.get_targets()
     assert "ibmq_qasm_simulator" in result["compile-and-run"]
     assert "aqt_keysight_qpu" in result["compile-only"]
 
 
 def test_qscout_compile(service: css.Service) -> None:
@@ -225,7 +232,39 @@
     # fmt: on
 
     num_qubits = 3
     depth = 1
     circuits, fidelities = service.supercheq(files, num_qubits, depth)
     assert len(circuits) == 32
     assert fidelities.shape == (32, 32)
+
+
+def test_job(service: css.Service) -> None:
+    circuit = cirq.Circuit(cirq.measure(cirq.q(0)))
+    job = service.create_job(circuit, target="ibmq_qasm_simulator", repetitions=10)
+
+    job_id = job.job_id()  # To test for https://github.com/Infleqtion/client-superstaq/issues/452
+
+    assert job.counts() == {"0": 10}
+    assert job.status() == "Done"
+    assert job.job_id() == job_id
+
+    # Force job to refresh when queried:
+    job._job.clear()
+    job._job["status"] = "Running"
+
+    # State retrieved from the server should be the same:
+    assert job.counts() == {"0": 10}
+    assert job.status() == "Done"
+    assert job.job_id() == job_id
+
+
+def test_submit_to_provider_simulators(service: css.Service) -> None:
+    q0 = cirq.LineQubit(0)
+    q1 = cirq.LineQubit(1)
+    circuit = cirq.Circuit(cirq.X(q0), cirq.CNOT(q0, q1), cirq.measure(q0, q1))
+
+    targets = ["cq_hilbert_simulator", "aws_sv1_simulator", "ibmq_qasm_simulator"]
+
+    for target in targets:
+        job = service.create_job(circuit=circuit, repetitions=1, target=target)
+        assert job.counts() == {"11": 1}
```

## cirq_superstaq/job.py

```diff
@@ -7,170 +7,177 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-"""Represents a job created via the SuperstaQ API."""
+"""Represents a job created via the Superstaq API."""
 import time
-from typing import Any, Dict
+from typing import Any, Dict, Tuple
 
 import cirq
 import general_superstaq as gss
 from cirq._doc import document
-from general_superstaq import superstaq_client
 
 
 @cirq.value_equality(unhashable=True)
 class Job:
-    """A job created on the SuperstaQ API.
+    """A job created on the Superstaq API.
 
-    Note that this is mutable, when calls to get status or results are made
-    the job updates itself to the results returned from the API.
+    Note that this is mutable, when calls to get status or results are made the job updates itself
+    to the results returned from the API.
 
-    If a job is canceled or deleted, only the job id and the status remain
-    valid.
+    If a job is canceled or deleted, only the job id and the status remain valid.
     """
 
     TERMINAL_STATES = ("Done", "Canceled", "Failed", "Deleted")
     document(
         TERMINAL_STATES,
-        "States of the SuperstaQ API job from which the job cannot transition. "
+        "States of the Superstaq API job from which the job cannot transition. "
         "Note that deleted can only exist in a return call from a delete "
         "(subsequent calls will return not found).",
     )
 
     NON_TERMINAL_STATES = ("Ready", "Submitted", "Running")
     document(
-        NON_TERMINAL_STATES, "States of the SuperstaQ API job which can transition to other states."
+        NON_TERMINAL_STATES, "States of the Superstaq API job which can transition to other states."
     )
 
     ALL_STATES = TERMINAL_STATES + NON_TERMINAL_STATES
-    document(ALL_STATES, "All states that an SuperstaQ API job can exist in.")
+    document(ALL_STATES, "All states that an Superstaq API job can exist in.")
 
     UNSUCCESSFUL_STATES = ("Canceled", "Failed", "Deleted")
     document(
         UNSUCCESSFUL_STATES,
-        "States of the SuperstaQ API job when it was not successful and so does not have any "
+        "States of the Superstaq API job when it was not successful and so does not have any "
         "data associated with it beyond an id and a status.",
     )
 
-    def __init__(self, client: superstaq_client._SuperstaQClient, job_id: str) -> None:
+    def __init__(self, client: gss.superstaq_client._SuperstaqClient, job_id: str) -> None:
         """Construct a Job.
 
         Users should not call this themselves. If you only know the `job_id`, use `get_job`
         on `css.Service`.
 
         Args:
             client: The client used for calling the API.
-            job_id: unique identifier for the job.
+            job_id: Unique identifier for the job.
         """
         self._client = client
-        self._job: Dict[str, Any] = {"job_id": job_id, "status": "Submitted"}
+        self._job: Dict[str, Any] = {"status": "Submitted"}
+        self._job_id = job_id
 
     def _refresh_job(self) -> None:
         """If the last fetched job is not terminal, gets the job from the API."""
         if self._job["status"] not in self.TERMINAL_STATES:
             self._job = self._client.get_job(self.job_id())
 
     def _check_if_unsuccessful(self) -> None:
-        if self.status() in self.UNSUCCESSFUL_STATES:
-            raise gss.superstaq_exceptions.SuperstaQUnsuccessfulJobException(
-                self.job_id(), self.status()
-            )
+        status = self.status()
+        if status in self.UNSUCCESSFUL_STATES:
+            if "failure" in self._job and "error" in self._job["failure"]:
+                # if possible append a message to the failure status, e.g. "Failed (<message>)"
+                error = self._job["failure"]["error"]
+                status += f" ({error})"
+            raise gss.SuperstaqUnsuccessfulJobException(self._job_id, status)
 
     def job_id(self) -> str:
-        """Returns the job id (UID) for the job.
+        """Gets the job id of this job.
+
+        This is the unique identifier used for identifying the job by the API.
 
-        This is the id used for identifying the job by the API.
+        Returns:
+            This job's id (a string).
         """
-        return self._job["job_id"]
+        return self._job_id
 
     def status(self) -> str:
         """Gets the current status of the job.
 
-        If the current job is in a non-terminal state,
-        this will update the job and return the current status.
-        A full list of states is given in
-        `cirq_superstaq.Job.ALL_STATES`.
+        If the current job is in a non-terminal state, this will update the job and return the
+        current status. A full list of states is given in `cirq_superstaq.Job.ALL_STATES`.
 
         Raises:
-            SuperstaQException: If the API is not able to get the status of the job.
+            SuperstaqException: If the API is not able to get the status of the job.
 
         Returns:
             The job status.
         """
         self._refresh_job()
         return self._job["status"]
 
     def target(self) -> str:
-        """Returns the target where the job is to be run, or was run.
+        """Gets the Superstaq target associated with this job.
 
         Returns:
-            'qpu' or 'simulator' depending on where the job was run or is running.
+            The target to which this job was submitted.
 
         Raises:
-            SuperstaQUnsuccessfulJob: If the job has failed, been canceled, or deleted.
-            SuperstaQException: If unable to get the status of the job from the API.
+            SuperstaqUnsuccessfulJobException: If the job failed or has been canceled or deleted.
+            SuperstaqException: If unable to get the status of the job from the API.
         """
         self._check_if_unsuccessful()
         return self._job["target"]
 
     def num_qubits(self) -> int:
-        """Returns the number of qubits for the job.
+        """Gets the number of qubits required for this job.
+
+        Returns:
+            The number of qubits used in this job.
 
         Raises:
-            SuperstaQUnsuccessfulJob: If the job has failed, been canceled, or deleted.
-            SuperstaQException: If unable to get the status of the job from the API.
+            SuperstaqUnsuccessfulJobException: If the job failed or has been canceled or deleted.
+            SuperstaqException: If unable to get the status of the job from the API.
         """
         self._check_if_unsuccessful()
         return self._job["num_qubits"]
 
     def repetitions(self) -> int:
-        """Returns the number of repetitions for the job.
+        """Gets the number of repetitions requested for this job.
+
+        Returns:
+            The number of repetitions for this job.
 
         Raises:
-            SuperstaQUnsuccessfulJob: If the job has failed, been canceled, or deleted.
-            SuperstaQException: If unable to get the status of the job from the API.
+            SuperstaqUnsuccessfulJobException: If the job failed or has been canceled or deleted.
+            SuperstaqException: If unable to get the status of the job from the API.
         """
         self._check_if_unsuccessful()
         return self._job["shots"]
 
     def counts(self, timeout_seconds: int = 7200, polling_seconds: float = 1.0) -> Dict[str, int]:
-        """Polls the SuperstaQ API for results.
+        """Polls the Superstaq API for counts results (frequency of each measurement outcome).
 
         Args:
             timeout_seconds: The total number of seconds to poll for.
             polling_seconds: The interval with which to poll.
 
         Returns:
-            collections.Counter that represents the results of the measurements
+            A dictionary containing the frequency counts of the measurements.
 
         Raises:
-            SuperstaQUnsuccessfulJob: If the job has failed, been canceled, or deleted.
-            SuperstaQException: If unable to get the results from the API.
+            SuperstaqUnsuccessfulJobException: If the job failed or has been canceled or deleted.
+            SuperstaqException: If unable to get the results from the API.
+            TimeoutError: If no results are available in the provided timeout interval.
         """
         time_waited_seconds: float = 0.0
-        while time_waited_seconds < timeout_seconds:
+        while self.status() not in self.TERMINAL_STATES:
             # Status does a refresh.
-            if self.status() in self.TERMINAL_STATES:
-                break
+            if time_waited_seconds > timeout_seconds:
+                raise TimeoutError(
+                    f"Timed out while waiting for results. Final status was {self.status()}"
+                )
             time.sleep(polling_seconds)
             time_waited_seconds += polling_seconds
-        if self.status() != "Done":
-            if "failure" in self._job and "error" in self._job["failure"]:
-                error = self._job["failure"]["error"]
-                raise RuntimeError(f"Job failed. Error message: {error}")
-            raise RuntimeError(
-                f"Job was not completed successfully. Instead had status: {self.status()}"
-            )
+
+        self._check_if_unsuccessful()
         return self._job["samples"]
 
     def __str__(self) -> str:
         return f"Job with job_id={self.job_id()}"
 
     def __repr__(self) -> str:
         return f"css.Job(client={self._client!r}, job_id={self.job_id()!r})"
 
-    def _value_equality_values_(self) -> Dict[str, Any]:
-        return self._job
+    def _value_equality_values_(self) -> Tuple[str, Dict[str, Any]]:
+        return self._job_id, self._job
```

## cirq_superstaq/job_test.py

```diff
@@ -7,87 +7,88 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
+# pylint: disable=missing-function-docstring
+from __future__ import annotations
 
 from typing import Any, Dict
 from unittest import mock
 
 import cirq
 import general_superstaq as gss
 import pytest
 
 import cirq_superstaq as css
 
 
 @pytest.fixture
 def job() -> css.Job:
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="cirq-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
     return css.Job(client, "job_id")
 
 
 def new_job() -> css.Job:
-    client = gss.superstaq_client._SuperstaQClient(
+    client = gss.superstaq_client._SuperstaqClient(
         client_name="cirq-superstaq",
         remote_host="http://example.com",
         api_key="to_my_heart",
     )
     return css.Job(client, "new_job_id")
 
 
-def mocked_get_job_requests(*job_dicts: Dict[str, Any]) -> "mock._patch[mock.Mock]":
+def mocked_get_job_requests(*job_dicts: Dict[str, Any]) -> mock._patch[mock.Mock]:
     """Mocks the server's response to `get_job` requests using the given sequence of job_dicts.
     Return type is wrapped in a string because "'type' object is not subscriptable"
     is thrown at runtime
     """
     return mock.patch(
-        "general_superstaq.superstaq_client._SuperstaQClient.get_job", side_effect=job_dicts
+        "general_superstaq.superstaq_client._SuperstaqClient.get_job", side_effect=job_dicts
     )
 
 
 def test_job_fields(job: css.job.Job) -> None:
     job_dict = {
         "data": {"histogram": {"11": 1}},
         "num_qubits": 2,
-        "job_id": "job_id",
         "samples": {"11": 1},
         "shots": 1,
         "status": "Done",
         "target": "ss_unconstrained_simulator",
     }
 
     with mocked_get_job_requests(job_dict):
         assert job.job_id() == "job_id"
         assert job.target() == "ss_unconstrained_simulator"
         assert job.num_qubits() == 2
         assert job.repetitions() == 1
 
 
 def test_job_status_refresh() -> None:
-    completed_job_dict = {"job_id": "new_job_id", "status": "completed"}
+    completed_job_dict = {"status": "Done"}
 
     for status in css.Job.NON_TERMINAL_STATES:
-        job_dict = {"job_id": "new_job_id", "status": status}
+        job_dict = {"status": status}
 
         with mocked_get_job_requests(job_dict, completed_job_dict) as mocked_request:
             job = new_job()
             assert job.status() == status
-            assert job.status() == "completed"
+            assert job.status() == "Done"
             assert mocked_request.call_count == 2
             mocked_request.assert_called_with("new_job_id")
 
     for status in css.Job.TERMINAL_STATES:
-        job_dict = {"job_id": "new_job_id", "status": status}
+        job_dict = {"status": status}
 
         with mocked_get_job_requests(job_dict, completed_job_dict) as mocked_request:
             job = new_job()
             assert job.status() == status
             assert job.status() == status
             mocked_request.assert_called_once_with("new_job_id")
 
@@ -107,101 +108,99 @@
     assert not job == 1
 
 
 def test_job_counts(job: css.job.Job) -> None:
     job_dict = {
         "data": {"histogram": {"11": 1}},
         "num_qubits": 2,
-        "job_id": "job_id",
         "samples": {"11": 1},
         "shots": 1,
         "status": "Done",
         "target": "ss_unconstrained_simulator",
     }
     with mocked_get_job_requests(job_dict):
         assert job.counts() == {"11": 1}
 
 
 def test_job_counts_failed(job: css.job.Job) -> None:
     job_dict = {
         "data": {"histogram": {"11": 1}},
         "num_qubits": 2,
-        "job_id": "job_id",
         "samples": {"11": 1},
         "shots": 1,
         "status": "Failed",
         "failure": {"error": "too many qubits"},
         "target": "ss_unconstrained_simulator",
     }
     with mocked_get_job_requests(job_dict):
-        with pytest.raises(RuntimeError, match="too many qubits"):
+        with pytest.raises(gss.SuperstaqUnsuccessfulJobException, match="too many qubits"):
             _ = job.counts()
         assert job.status() == "Failed"
 
 
 @mock.patch("time.sleep", return_value=None)
 def test_job_counts_poll(mock_sleep: mock.MagicMock, job: css.job.Job) -> None:
     ready_job = {
-        "job_id": "job_id",
-        "status": "ready",
+        "status": "Ready",
     }
     completed_job = {
         "data": {"histogram": {"11": 1}},
         "num_qubits": 2,
-        "job_id": "job_id",
         "samples": {"11": 1},
         "shots": 1,
         "status": "Done",
         "target": "ss_unconstrained_simulator",
     }
 
     with mocked_get_job_requests(ready_job, completed_job) as mocked_requests:
         results = job.counts(polling_seconds=0)
         assert results == {"11": 1}
         assert mocked_requests.call_count == 2
         mock_sleep.assert_called_once()
 
 
 @mock.patch("time.sleep", return_value=None)
-def test_job_counts_poll_timeout(mock_sleep: mock.MagicMock, job: css.job.Job) -> None:
+@mock.patch("time.time", side_effect=range(20))
+def test_job_counts_poll_timeout(
+    mock_time: mock.MagicMock, mock_sleep: mock.MagicMock, job: css.job.Job
+) -> None:
     ready_job = {
-        "job_id": "job_id",
-        "status": "ready",
+        "status": "Ready",
     }
     with mocked_get_job_requests(*[ready_job] * 20):
-        with pytest.raises(RuntimeError, match="ready"):
+        with pytest.raises(TimeoutError, match="Ready"):
             _ = job.counts(timeout_seconds=1, polling_seconds=0.1)
     assert mock_sleep.call_count == 11
 
 
 @mock.patch("time.sleep", return_value=None)
-def test_job_results_poll_timeout_with_error_message(
-    mock_sleep: mock.MagicMock, job: css.job.Job
-) -> None:
-    ready_job = {
-        "job_id": "job_id",
-        "status": "failure",
+def test_job_results_poll_failure(mock_sleep: mock.MagicMock, job: css.job.Job) -> None:
+    running_job = {
+        "status": "Running",
+    }
+    failed_job = {
+        "status": "Failed",
         "failure": {"error": "too many qubits"},
     }
-    with mocked_get_job_requests(*[ready_job] * 20):
-        with pytest.raises(RuntimeError, match="too many qubits"):
+
+    with mocked_get_job_requests(*[running_job] * 5, failed_job):
+        with pytest.raises(gss.SuperstaqUnsuccessfulJobException, match="too many qubits"):
             _ = job.counts(timeout_seconds=1, polling_seconds=0.1)
-    assert mock_sleep.call_count == 11
+    assert mock_sleep.call_count == 5
 
 
 def test_job_fields_unsuccessful(job: css.job.Job) -> None:
     job_dict = {
         "data": {"histogram": {"11": 1}},
-        "job_id": "job_id",
         "num_qubits": 2,
         "samples": {"11": 1},
         "shots": 1,
         "status": "Deleted",
         "target": "ss_unconstrained_simulator",
     }
     with mocked_get_job_requests(job_dict):
-        with pytest.raises(gss.SuperstaQUnsuccessfulJobException, match="Deleted"):
+        with pytest.raises(gss.SuperstaqUnsuccessfulJobException, match="Deleted"):
             _ = job.target()
-        with pytest.raises(gss.SuperstaQUnsuccessfulJobException, match="Deleted"):
+        with pytest.raises(gss.SuperstaqUnsuccessfulJobException, match="Deleted"):
             _ = job.num_qubits()
-        with pytest.raises(gss.SuperstaQUnsuccessfulJobException, match="Deleted"):
+        with pytest.raises(gss.SuperstaqUnsuccessfulJobException, match="Deleted"):
             _ = job.repetitions()
```

## cirq_superstaq/sampler.py

```diff
@@ -6,25 +6,26 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-"""A `cirq.Sampler` implementation for the SuperstaQ API."""
+"""A `cirq.Sampler` implementation for the Superstaq API."""
+from __future__ import annotations
 
 from typing import List
 
 import cirq
 
 import cirq_superstaq as css
 
 
 class Sampler(cirq.Sampler):
-    """A sampler that works against the SuperstaQ API. Users should get a sampler from the `sampler`
+    """A sampler that works against the Superstaq API. Users should get a sampler from the `sampler`
     method on `css.Service`.
 
     Example:
 
     .. code-block:: python
 
         service = css.Service(
@@ -42,15 +43,15 @@
         3   1
         4   1
 
     """
 
     def __init__(
         self,
-        service: "css.service.Service",
+        service: css.service.Service,
         target: str,
     ) -> None:
         """Constructs the sampler. Uers should get a sampler from the `sampler` method on
         `css.Service`.
 
         Args:
             service: The service used to create this sample.
```

## cirq_superstaq/serialization.py

```diff
@@ -1,14 +1,19 @@
 import json
 from typing import List, Sequence, Union
 
 import cirq
 
 import cirq_superstaq as css
 
+SUPERSTAQ_RESOLVERS = [
+    css.ops.qudit_gates.custom_resolver,
+    css.ops.qubit_gates.custom_resolver,
+]
+
 
 def serialize_circuits(
     circuits: Union[cirq.AbstractCircuit, Sequence[cirq.AbstractCircuit]]
 ) -> str:
     """Serialize Circuit(s) into a json string
 
     Args:
@@ -34,12 +39,12 @@
 
     Args:
         serialized_circuits: json str generated via serialization.serialize_circuit()
 
     Returns:
         the Circuit or list of Circuits that was serialized
     """
-    resolvers = [css.custom_gates.custom_resolver, *cirq.DEFAULT_RESOLVERS]
+    resolvers = [*SUPERSTAQ_RESOLVERS, *cirq.DEFAULT_RESOLVERS]
     circuits = cirq.read_json(json_text=serialized_circuits, resolvers=resolvers)
     if isinstance(circuits, cirq.Circuit):
         return [circuits]
     return circuits
```

## cirq_superstaq/serialization_test.py

```diff
@@ -1,7 +1,8 @@
+# pylint: disable=missing-function-docstring
 from unittest import mock
 
 import cirq
 
 import cirq_superstaq as css
```

## cirq_superstaq/service.py

```diff
@@ -6,29 +6,55 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-"""Service to access SuperstaQs API."""
+"""Service to access Superstaqs API."""
 
-import json
-import os
-from typing import Any, Dict, List, Optional, Sequence, Tuple, Union
+import warnings
+from typing import Any, Dict, List, Mapping, Optional, Sequence, Tuple, Union
 
 import cirq
 import general_superstaq as gss
 import numpy as np
 import numpy.typing as npt
-from general_superstaq import ResourceEstimate, finance, logistics, superstaq_client, user_config
+from general_superstaq import ResourceEstimate, superstaq_client, user_config
 
 import cirq_superstaq as css
 
 
+def _to_matrix_gate(matrix: npt.ArrayLike) -> cirq.MatrixGate:
+    """Convert a unitary matrix into a cirq.MatrixGate acting either on qubits or on qutrits.
+
+    Args:
+        matrix: The (unitary) matrix to be converted.
+
+    Returns:
+        A cirq.MatrixGate with the given unitary.
+
+    Raises:
+        ValueError: If `matrix` could not be interpreted as a unitary gate acting on either qubits
+            or qutrits.
+    """
+
+    matrix = np.asarray(matrix, dtype=complex)
+
+    for dimension in (2, 3):
+        num_qids = int(round(np.log(matrix.size) / np.log(dimension**2)))
+        if matrix.shape == (dimension**num_qids, dimension**num_qids):
+            qid_shape = (dimension,) * num_qids
+            return cirq.MatrixGate(matrix, qid_shape=qid_shape)
+
+    raise ValueError(
+        "Could not determine qid_shape from array shape, consider using a cirq.MatrixGate instead."
+    )
+
+
 def counts_to_results(
     counter: Dict[str, int], circuit: cirq.AbstractCircuit, param_resolver: cirq.ParamResolver
 ) -> cirq.ResultDict:
     """Converts a collections.Counter to a cirq.ResultDict.
 
     Args:
             counter: The collections.Counter of counts for the run.
@@ -68,214 +94,242 @@
             combine_key_names: np.array(samples),
         },
     )
 
     return result
 
 
-class Service(finance.Finance, logistics.Logistics, user_config.UserConfig):
-    """A class to access SuperstaQ's API.
+def _validate_cirq_circuits(circuits: object) -> None:
+    """Validates that the input is either a single `cirq.Circuit` or a list of `cirq.Circuit`
+    instances.
+
+    Args:
+        circuits: The circuit(s) to run.
+
+    Raises:
+        ValueError: If the input is not a `cirq.Circuit` or a list of `cirq.Circuit` instances.
+    """
+
+    if not (
+        isinstance(circuits, cirq.Circuit)
+        or (
+            isinstance(circuits, Sequence)
+            and all(isinstance(circuit, cirq.Circuit) for circuit in circuits)
+        )
+    ):
+        raise ValueError(
+            "Invalid 'circuits' input. Must be a `cirq.Circuit` or a "
+            "sequence of `cirq.Circuit` instances."
+        )
+
+
+class Service(user_config.UserConfig):
+    """A class to access Superstaq's API.
 
     To access the API, this class requires a remote host url and an API key. These can be
     specified in the constructor via the parameters `remote_host` and `api_key`. Alternatively
     these can be specified by setting the environment variables `SUPERSTAQ_REMOTE_HOST` and
-    `SUPERSTAQ_API_KEY`.
+    `SUPERSTAQ_API_KEY`, or setting an API key in a configuration file.
     """
 
     def __init__(
         self,
         api_key: Optional[str] = None,
         remote_host: Optional[str] = None,
         default_target: Optional[str] = None,
         api_version: str = gss.API_VERSION,
         max_retry_seconds: int = 3600,
         verbose: bool = False,
     ) -> None:
-        """Creates the Service to access SuperstaQ's API.
+        """Creates the Service to access Superstaq's API.
 
         Args:
+            api_key: A string that allows access to the Superstaq API. If no key is provided, then
+                this instance tries to use the environment variable `SUPERSTAQ_API_KEY`. If
+                furthermore that environment variable is not set, then this instance checks for the
+                following files:
+                - `$XDG_DATA_HOME/super.tech/superstaq_api_key`
+                - `$XDG_DATA_HOME/coldquanta/superstaq_api_key`
+                - `~/.super.tech/superstaq_api_key`
+                - `~/.coldquanta/superstaq_api_key`
+                If one of those files exists, the it is treated as a plain text file, and the first
+                line of this file is interpreted as an API key.  Failure to find an API key raises
+                an `EnvironmentError`.
             remote_host: The location of the api in the form of an url. If this is None,
                 then this instance will use the environment variable `SUPERSTAQ_REMOTE_HOST`.
                 If that variable is not set, then this uses
                 `flask-service.cgvd1267imk10.us-east-1.cs.amazonlightsail.com/{api_version}`,
                 where `{api_version}` is the `api_version` specified below.
-            api_key: A string key which allows access to the api. If this is None,
-                then this instance will use the environment variable  `SUPERSTAQ_API_KEY`. If that
-                variable is not set, then this will raise an `EnvironmentError`.
             default_target: Which target to default to using. If set to None, no default is set
                 and target must always be specified in calls. If set, then this default is used,
                 unless a target is specified for a given call
             api_version: Version of the api.
             max_retry_seconds: The number of seconds to retry calls for. Defaults to one hour.
             verbose: Whether to print to stdio and stderr on retriable errors.
 
         Raises:
-            EnvironmentError: if the `api_key` is None and has no corresponding environment
-                variable set.
+            EnvironmentError: If an API key was not provided and could not be found.
         """
-        self.api_key = api_key or os.getenv("SUPERSTAQ_API_KEY")
-        self.remote_host = remote_host or os.getenv("SUPERSTAQ_REMOTE_HOST") or gss.API_URL
         self.default_target = default_target
 
-        if not self.api_key:
-            raise EnvironmentError(
-                "Parameter api_key was not specified and the environment variable "
-                "SUPERSTAQ_API_KEY was also not set."
-            )
-
-        self._client = superstaq_client._SuperstaQClient(
+        self._client = superstaq_client._SuperstaqClient(
             client_name="cirq-superstaq",
-            remote_host=self.remote_host,
-            api_key=self.api_key,
+            remote_host=remote_host,
+            api_key=api_key,
             api_version=api_version,
             max_retry_seconds=max_retry_seconds,
             verbose=verbose,
         )
 
     def _resolve_target(self, target: Union[str, None]) -> str:
         target = target or self.default_target
         if not target:
             raise ValueError(
                 "This call requires a target, but none was provided and default_target is not set."
             )
 
+        gss.validation.validate_target(target)
         return target
 
     def get_counts(
         self,
         circuit: cirq.Circuit,
         repetitions: int,
         target: Optional[str] = None,
         param_resolver: cirq.ParamResolverOrSimilarType = cirq.ParamResolver({}),
         method: Optional[str] = None,
-        options: Optional[Dict[str, Any]] = None,
+        **kwargs: Any,
     ) -> Dict[str, int]:
-        """Runs the given circuit on the SuperstaQ API and returns the result
+        """Runs the given circuit on the Superstaq API and returns the result
         of the ran circuit as a collections.Counter
 
         Args:
             circuit: The circuit to run.
             repetitions: The number of times to run the circuit.
             target: Where to run the job.
             param_resolver: A `cirq.ParamResolver` to resolve parameters in  `circuit`.
             method: Optional execution method.
-            options: Optional dictionary of optimization and execution parameters
+            kwargs: Other optimization and execution parameters.
 
         Returns:
             A `collection.Counter` for running the circuit.
         """
         resolved_circuit = cirq.protocols.resolve_parameters(circuit, param_resolver)
-        job = self.create_job(resolved_circuit, repetitions, target, method, options)
+        job = self.create_job(resolved_circuit, int(repetitions), target, method, **kwargs)
         counts = job.counts()
 
         return counts
 
     def run(
         self,
         circuit: cirq.Circuit,
         repetitions: int,
         target: Optional[str] = None,
         param_resolver: cirq.ParamResolver = cirq.ParamResolver({}),
         method: Optional[str] = None,
-        options: Optional[Dict[str, Any]] = None,
+        **kwargs: Any,
     ) -> cirq.ResultDict:
-        """Run the given circuit on the SuperstaQ API and returns the result
+        """Run the given circuit on the Superstaq API and returns the result
         of the ran circut as a cirq.ResultDict.
 
         Args:
             circuit: The circuit to run.
             repetitions: The number of times to run the circuit.
             target: Where to run the job.
-            method: Execution method.
-            options: Optional dictionary of optimization and execution parameters
             param_resolver: A `cirq.ParamResolver` to resolve parameters in  `circuit`.
+            method: Execution method.
+            kwargs: Other optimization and execution parameters.
 
         Returns:
             A `cirq.ResultDict` for running the circuit.
         """
-        counts = self.get_counts(circuit, repetitions, target, param_resolver, method, options)
+        counts = self.get_counts(circuit, repetitions, target, param_resolver, method, **kwargs)
         return counts_to_results(counts, circuit, param_resolver)
 
     def sampler(self, target: Optional[str] = None) -> cirq.Sampler:
         """Returns a `cirq.Sampler` object for accessing sampler interface.
 
         Args:
-            target: target to sample against.
+            target: Target to sample against.
 
         Returns:
-            A `cirq.Sampler` for the SuperstaQ API.
+            A `cirq.Sampler` for the Superstaq API.
         """
         target = self._resolve_target(target)
         return css.sampler.Sampler(service=self, target=target)
 
     def create_job(
         self,
         circuit: cirq.AbstractCircuit,
         repetitions: int = 1000,
         target: Optional[str] = None,
         method: Optional[str] = None,
-        options: Optional[Dict[str, Any]] = None,
+        **kwargs: Any,
     ) -> css.job.Job:
         """Create a new job to run the given circuit.
 
         Args:
             circuit: The circuit to run.
             repetitions: The number of times to repeat the circuit. Defaults to 1000.
             target: Where to run the job.
             method: Execution method.
-            options: Optional dictionary of optimization and execution parameters
+            kwargs: Other optimization and execution parameters.
 
         Returns:
             A `css.Job` which can be queried for status or results.
 
         Raises:
-            ValueError: If the circuit has no measurements to sample.
-            SuperstaQException: If there was an error accessing the API.
+            ValueError: If `circuit` is not a valid `cirq.Circuit` or has no measurements to sample.
+            SuperstaqException: If there was an error accessing the API.
         """
+        _validate_cirq_circuits(circuit)
+        if not isinstance(circuit, cirq.Circuit):
+            raise ValueError("This endpoint does not support the submission of multiple circuits.")
+
         if not circuit.has_measurements():
             # TODO: only raise if the run method actually requires samples (and not for e.g. a
             # statevector simulation)
             raise ValueError("Circuit has no measurements to sample.")
 
         serialized_circuits = css.serialization.serialize_circuits(circuit)
 
         target = self._resolve_target(target)
 
         result = self._client.create_job(
             serialized_circuits={"cirq_circuits": serialized_circuits},
             repetitions=repetitions,
             target=target,
             method=method,
-            options=options,
+            **kwargs,
         )
         # The returned job does not have fully populated fields; they will be filled out by
         # when the new job's status is first queried
         return self.get_job(result["job_ids"][0])
 
     def get_job(self, job_id: str) -> css.job.Job:
-        """Gets a job that has been created on the SuperstaQ API.
+        """Gets a job that has been created on the Superstaq API.
 
         Args:
             job_id: The UUID of the job. Jobs are assigned these numbers by the server during the
             creation of the job.
 
         Returns:
             A `css.Job` which can be queried for status or results.
 
         Raises:
-            SuperstaQNotFoundException: If there was no job with the given `job_id`.
-            SuperstaQException: If there was an error accessing the API.
+            SuperstaqNotFoundException: If there was no job with the given `job_id`.
+            SuperstaqException: If there was an error accessing the API.
         """
         return css.job.Job(client=self._client, job_id=job_id)
 
     def get_balance(self, pretty_output: bool = True) -> Union[str, float]:
         """Get the querying user's account balance in USD.
 
         Args:
-            pretty_output: whether to return a pretty string or a float of the balance.
+            pretty_output: Whether to return a pretty string or a float of the balance.
 
         Returns:
             If pretty_output is True, returns the balance as a nicely formatted string ($-prefix,
                 commas on LHS every three digits, and two digits after period). Otherwise, simply
                 returns a float of the balance.
         """
         balance = self._client.get_balance()["balance"]
@@ -284,25 +338,26 @@
         return balance
 
     def get_targets(self) -> Dict[str, List[str]]:
         """Get list of available targets."""
         return self._client.get_targets()["superstaq_targets"]
 
     def resource_estimate(
-        self, circuits: Union[cirq.Circuit, List[cirq.Circuit]], target: Optional[str] = None
+        self, circuits: Union[cirq.Circuit, Sequence[cirq.Circuit]], target: Optional[str] = None
     ) -> Union[ResourceEstimate, List[ResourceEstimate]]:
         """Generates resource estimates for circuit(s).
 
         Args:
-            circuits: cirq Circuit(s).
-            target: string of target representing target device
+            circuits: Cirq Circuit(s).
+            target: String of target representing target device
         Returns:
             ResourceEstimate(s) containing resource costs (after compilation)
         """
-        circuit_is_list = isinstance(circuits, List)
+        _validate_cirq_circuits(circuits)
+        circuit_is_list = not isinstance(circuits, cirq.Circuit)
         serialized_circuit = css.serialization.serialize_circuits(circuits)
 
         target = self._resolve_target(target)
 
         request_json = {
             "cirq_circuits": serialized_circuit,
             "target": target,
@@ -315,172 +370,319 @@
             for resource_estimate in json_dict["resource_estimates"]
         ]
 
         if circuit_is_list:
             return resource_estimates
         return resource_estimates[0]
 
-    def aqt_compile(
-        self, circuits: Union[cirq.Circuit, List[cirq.Circuit]], target: str = "aqt_keysight_qpu"
+    def aqt_compile_eca(
+        self,
+        circuits: Union[cirq.Circuit, Sequence[cirq.Circuit]],
+        num_equivalent_circuits: int,
+        random_seed: Optional[int] = None,
+        target: str = "aqt_keysight_qpu",
+        atol: Optional[float] = None,
+        gate_defs: Optional[
+            Mapping[str, Union[npt.NDArray[np.complex_], cirq.Gate, cirq.Operation, None]]
+        ] = None,
+        **kwargs: Any,
     ) -> css.compiler_output.CompilerOutput:
-        """Compiles the given circuit(s) to target AQT device, optimized to its native gate set.
+        """Compiles and optimizes the given circuit(s) for the Advanced Quantum Testbed (AQT) at
+        Lawrence Berkeley National Laboratory using Equivalent Circuit Averaging (ECA).
+
+        See arxiv.org/pdf/2111.04572.pdf for a description of ECA.
+
+        Note:
+            This method has been deprecated. Instead, use the `num_eca_circuits` argument of
+            `aqt_compile()`.
 
         Args:
-            circuits: cirq Circuit(s) to compile.
-            target: string of target target AQT device.
-        Returns:
-            object whose .circuit(s) attribute is an optimized cirq Circuit(s)
-            If qtrl is installed, the object's .seq attribute is a qtrl Sequence object of the
-            pulse sequence corresponding to the optimized cirq.Circuit(s) and the
-            .pulse_list(s) attribute is the list(s) of cycles.
+            circuits: The circuit(s) to compile.
+            num_equivalent_circuits: Number of logically equivalent random circuits to generate for
+                each input circuit.
+            random_seed: Optional seed for circuit randomizer.
+            target: String of target AQT device.
+            atol: An optional tolerance to use for approximate gate synthesis.
+            gate_defs: An optional dictionary mapping names in qtrl configs to operations, where
+                each operation can be a unitary matrix, `cirq.Gate`, `cirq.Operation`, or None. More
+                specific associations take precedence, for example `{"SWAP": cirq.SQRT_ISWAP,
+                "SWAP/C5C4": cirq.SQRT_ISWAP_INV}` implies `SQRT_ISWAP` for all "SWAP" calibrations
+                except "SWAP/C5C4" (which will instead be mapped to a `SQRT_ISWAP_INV` gate on
+                qubits 4 and 5). Setting any calibration to None will disable that calibration.
+            kwargs: Other desired aqt_compile_eca options.
+
+        Returns:
+            Object whose .circuits attribute is a list (or list of lists) of logically equivalent
+            circuits. If qtrl is installed, the object's .seq attribute is a qtrl Sequence object
+            containing pulse sequences for each compiled circuit, and its .pulse_list(s) attribute
+            contains the corresponding list(s) of cycles.
+
+        Raises:
+            ValueError: If `target` is not a valid AQT target.
         """
-        serialized_circuits = css.serialization.serialize_circuits(circuits)
-        circuits_is_list = not isinstance(circuits, cirq.Circuit)
+        warnings.warn(
+            "The `aqt_compile_eca()` method has been deprecated, and will be removed in a future "
+            "version of cirq-superstaq. Instead, use the `num_eca_circuits` argument of "
+            "`aqt_compile()` to compile circuits for ECA.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
 
-        json_dict = self._client.aqt_compile(
-            {"cirq_circuits": serialized_circuits, "target": target}
+        return self.aqt_compile(
+            circuits,
+            target=target,
+            num_eca_circuits=num_equivalent_circuits,
+            random_seed=random_seed,
+            atol=atol,
+            gate_defs=gate_defs,
+            **kwargs,
         )
-        return css.compiler_output.read_json_aqt(json_dict, circuits_is_list)
 
-    def aqt_compile_eca(
+    def aqt_compile(
         self,
         circuits: Union[cirq.Circuit, Sequence[cirq.Circuit]],
-        num_equivalent_circuits: int,
-        random_seed: Optional[int] = None,
         target: str = "aqt_keysight_qpu",
+        *,
+        num_eca_circuits: Optional[int] = None,
+        random_seed: Optional[int] = None,
+        atol: Optional[float] = None,
+        gate_defs: Optional[
+            Mapping[str, Union[npt.NDArray[np.complex_], cirq.Gate, cirq.Operation, None]]
+        ] = None,
+        **kwargs: Any,
     ) -> css.compiler_output.CompilerOutput:
-        """Compiles the given circuit to target AQT device with Equivalent Circuit Averaging (ECA).
+        """Compiles and optimizes the given circuit(s) for the Advanced Quantum Testbed (AQT).
 
-        See arxiv.org/pdf/2111.04572.pdf for a description of ECA.
+        AQT is a superconducting transmon quantum computing testbed at Lawrence Berkeley National
+        Laboratory. More information can be found at https://aqt.lbl.gov.
+
+        Specifying a nonzero value for `num_eca_circuits` enables compilation with Equivalent
+        Circuit Averaging (ECA). See https://arxiv.org/abs/2111.04572 for a description of ECA.
 
         Args:
-            circuits: cirq Circuit(s) to compile.
-            num_equivalent_circuits: number of logically equivalent random circuits to generate for
-                each input circuit.
-            random_seed: optional seed for circuit randomizer.
-            target: string of target target AQT device.
-        Returns:
-            object whose .circuits attribute is a list (or list of lists) of logically equivalent
-                cirq Circuit(s).
-            If qtrl is installed, the object's .seq attribute is a qtrl Sequence object of the
-                pulse sequence corresponding to the cirq.Circuits and the .pulse_lists attribute is
-                the list(s) of cycles.
+            circuits: The circuit(s) to compile.
+            target: String of target AQT device.
+            num_eca_circuits: Optional number of logically equivalent random circuits to generate
+                from each input circuit for Equivalent Circuit Averaging (ECA).
+            random_seed: Optional seed used for approximate synthesis and ECA.
+            atol: An optional tolerance to use for approximate gate synthesis.
+            gate_defs: An optional dictionary mapping names in qtrl configs to operations, where
+                each operation can be a unitary matrix, `cirq.Gate`, `cirq.Operation`, or None. More
+                specific associations take precedence, for example `{"SWAP": cirq.SQRT_ISWAP,
+                "SWAP/C5C4": cirq.SQRT_ISWAP_INV}` implies `SQRT_ISWAP` for all "SWAP" calibrations
+                except "SWAP/C5C4" (which will instead be mapped to a `SQRT_ISWAP_INV` gate on
+                qubits 4 and 5). Setting any calibration to None will disable that calibration.
+            kwargs: Other desired compile options.
+
+        Returns:
+            Object whose .circuit(s) attribute contains the optimized circuits(s). Alternatively for
+            ECA, an object whose .circuits attribute is a list (or list of lists) of logically
+            equivalent circuits. If qtrl is installed, the object's .seq attribute is a qtrl
+            Sequence object containing pulse sequences for each compiled circuit, and its
+            .pulse_list(s) attribute contains the corresponding list(s) of cycles.
+
+        Raises:
+            ValueError: If `target` is not a valid AQT target.
         """
+        target = self._resolve_target(target)
+        if not target.startswith("aqt_"):
+            raise ValueError(f"{target!r} is not a valid AQT target.")
+
+        _validate_cirq_circuits(circuits)
         serialized_circuits = css.serialization.serialize_circuits(circuits)
         circuits_is_list = not isinstance(circuits, cirq.Circuit)
 
-        options_dict = {"num_eca_circuits": num_equivalent_circuits}
-        if random_seed is not None:
-            options_dict["random_seed"] = random_seed
-
         request_json = {
             "cirq_circuits": serialized_circuits,
             "target": target,
-            "options": json.dumps(options_dict),
         }
 
+        options_dict: Dict[str, object]
+        options_dict = {**kwargs}
+
+        if num_eca_circuits is not None:
+            gss.validation.validate_integer_param(num_eca_circuits)
+            options_dict["num_eca_circuits"] = int(num_eca_circuits)
+        if random_seed is not None:
+            gss.validation.validate_integer_param(random_seed)
+            options_dict["random_seed"] = int(random_seed)
+        if atol is not None:
+            options_dict["atol"] = float(atol)
+        if gate_defs is not None:
+            gate_defs_cirq = {}
+            for key, val in gate_defs.items():
+                if val is not None and not isinstance(val, (cirq.Gate, cirq.Operation)):
+                    val = _to_matrix_gate(val).with_name(key)
+                gate_defs_cirq[key] = val
+            options_dict["gate_defs"] = gate_defs_cirq
+
+        if options_dict:
+            request_json["options"] = cirq.to_json(options_dict)
+
         json_dict = self._client.post_request("/aqt_compile", request_json)
-        return css.compiler_output.read_json_aqt(
-            json_dict, circuits_is_list, num_equivalent_circuits
-        )
+        return css.compiler_output.read_json_aqt(json_dict, circuits_is_list, num_eca_circuits)
 
     def qscout_compile(
         self,
-        circuits: Union[cirq.Circuit, List[cirq.Circuit]],
-        mirror_swaps: bool = True,
+        circuits: Union[cirq.Circuit, Sequence[cirq.Circuit]],
+        mirror_swaps: bool = False,
+        base_entangling_gate: str = "xx",
         target: str = "sandia_qscout_qpu",
+        **kwargs: Any,
     ) -> css.compiler_output.CompilerOutput:
-        """Compiles the given circuit(s) to target QSCOUT device, optimized to its native gate set.
+        """Compiles and optimizes the given circuit(s) for the QSCOUT trapped-ion testbed at
+        Sandia National Laboratories [1].
+
+        Compiled circuits are returned as both `cirq.Circuit` objects and corresponding Jaqal [2]
+        programs (strings).
+
+        References:
+            [1] S. M. Clark et al., *Engineering the Quantum Scientific Computing Open User
+                Testbed*, IEEE Transactions on Quantum Engineering Vol. 2, 3102832 (2021).
+                https://doi.org/10.1109/TQE.2021.3096480.
+            [2] B. Morrison, et al., *Just Another Quantum Assembly Language (Jaqal)*, 2020 IEEE
+                International Conference on Quantum Computing and Engineering (QCE), 402-408 (2020).
+                https://arxiv.org/abs/2008.08042.
+
+        Args:
+            circuits: The circuit(s) to compile.
+            target: String of target representing target device
+            mirror_swaps: Whether to use mirror swapping to reduce two-qubit gate overhead.
+            base_entangling_gate: The base entangling gate to use (either "xx" or "zz").
+            kwargs: Other desired qscout_compile options.
 
-        Args:
-            circuits: cirq Circuit(s) with operations on qubits 0 and 1.
-            target: string of target target QSCOUT device.
         Returns:
-            object whose .circuit(s) attribute is an optimized cirq Circuit(s)
-            and a list of jaqal programs represented as strings
+            Object whose .circuit(s) attribute contains optimized `cirq.Circuit`(s), and
+            `.jaqal_program(s)` attribute contains the corresponding Jaqal program(s).
+
+        Raises:
+            ValueError: If `base_entangling_gate` is not a valid gate option.
+            ValueError: If `target` is not a valid Sandia target.
         """
+        target = self._resolve_target(target)
+        if not target.startswith("sandia_"):
+            raise ValueError(f"{target!r} is not a valid Sandia target.")
+
+        if base_entangling_gate not in ("xx", "zz"):
+            raise ValueError("base_entangling_gate must be either 'xx' or 'zz'")
+
+        _validate_cirq_circuits(circuits)
         serialized_circuits = css.serialization.serialize_circuits(circuits)
         circuits_is_list = not isinstance(circuits, cirq.Circuit)
 
-        options_dict = {"mirror_swaps": mirror_swaps}
+        options_dict = {
+            "mirror_swaps": mirror_swaps,
+            "base_entangling_gate": base_entangling_gate,
+            **kwargs,
+        }
+
         json_dict = self._client.qscout_compile(
             {
                 "cirq_circuits": serialized_circuits,
-                "options": json.dumps(options_dict),
+                "options": cirq.to_json(options_dict),
                 "target": target,
             }
         )
 
         return css.compiler_output.read_json_qscout(json_dict, circuits_is_list)
 
     def cq_compile(
-        self, circuits: Union[cirq.Circuit, List[cirq.Circuit]], target: str = "cq_hilbert_qpu"
+        self,
+        circuits: Union[cirq.Circuit, Sequence[cirq.Circuit]],
+        target: str = "cq_hilbert_qpu",
+        **kwargs: Any,
     ) -> css.compiler_output.CompilerOutput:
-        """Compiles the given circuit(s) to given target CQ device, optimized to its native gate
-        set.
+        """Compiles and optimizes the given circuit(s) to the target CQ device.
 
         Args:
-            circuits: cirq Circuit(s) with operations on qubits 0 and 1.
-            target: string of target target CQ device.
+            circuits: The circuit(s) to compile.
+            target: String of target CQ device.
+            kwargs: Other desired cq_compile options.
+
         Returns:
-            object whose .circuit(s) attribute is an optimized cirq Circuit(s)
-        """
-        serialized_circuits = css.serialization.serialize_circuits(circuits)
-        circuits_is_list = not isinstance(circuits, cirq.Circuit)
+            Object whose .circuit(s) attribute contains the compiled `cirq.Circuit`(s).
 
-        json_dict = self._client.cq_compile(
-            {"cirq_circuits": serialized_circuits, "target": target}
-        )
+        Raises:
+            ValueError: If `target` is not a valid IBMQ target.
+        """
+        target = self._resolve_target(target)
+        if not target.startswith("cq_"):
+            raise ValueError(f"{target!r} is not a valid CQ target.")
 
-        return css.compiler_output.read_json_only_circuits(json_dict, circuits_is_list)
+        return self.compile(circuits, target=target, **kwargs)
 
     def ibmq_compile(
-        self, circuits: Union[cirq.Circuit, List[cirq.Circuit]], target: str = "ibmq_qasm_simulator"
+        self,
+        circuits: Union[cirq.Circuit, Sequence[cirq.Circuit]],
+        target: str = "ibmq_qasm_simulator",
+        **kwargs: Any,
     ) -> css.compiler_output.CompilerOutput:
-        """Returns pulse schedule for the given circuit and target.
+        """Compiles and optimizes the given circuit(s) to the target IBMQ device.
 
-        Qiskit Terra must be installed to correctly deserialize the returned pulse schedule.
-        """
-        serialized_circuits = css.serialization.serialize_circuits(circuits)
-        circuits_is_list = not isinstance(circuits, cirq.Circuit)
+        Qiskit Terra must be installed to correctly deserialize pulse schedules for pulse-enabled
+        targets.
+
+        Args:
+            circuits: The circuit(s) to compile.
+            target: String of target IBMQ device.
+            kwargs: Other desired ibmq_compile options.
+
+        Returns:
+            Object whose .circuit(s) attribute contains the compiled `cirq.Circuit`(s), and whose
+            .pulse_sequence(s) attribute contains the corresponding pulse schedule(s) (when
+            available).
 
+        Raises:
+            ValueError: If `target` is not a valid IBMQ target.
+        """
         target = self._resolve_target(target)
         if not target.startswith("ibmq_"):
-            raise ValueError(f"{target} is not an IBMQ target")
+            raise ValueError(f"{target!r} is not a valid IBMQ target.")
 
-        json_dict = self._client.ibmq_compile(
-            {"cirq_circuits": serialized_circuits, "target": target}
-        )
+        return self.compile(circuits, target=target, **kwargs)
 
-        return css.compiler_output.read_json_ibmq(json_dict, circuits_is_list)
+    def compile(
+        self,
+        circuits: Union[cirq.Circuit, Sequence[cirq.Circuit]],
+        target: str,
+        **kwargs: Any,
+    ) -> css.compiler_output.CompilerOutput:
+        """Compiles the given circuit(s) to the target device.
 
-    def neutral_atom_compile(
-        self, circuits: Union[cirq.Circuit, List[cirq.Circuit]], target: str = "neutral_atom_qpu"
-    ) -> Any:
-        """Returns pulse schedule for the given circuit and target.
+        Args:
+            circuits: The circuit(s) to compile.
+            target: String of target device.
+            kwargs: Other desired compilation options.
 
-        Pulse must be installed for returned object to correctly deserialize to a pulse schedule.
+        Returns:
+            Object whose .circuit(s) attribute contains the compiled `cirq.Circuit`(s).
         """
+        _validate_cirq_circuits(circuits)
         serialized_circuits = css.serialization.serialize_circuits(circuits)
+        circuits_is_list = not isinstance(circuits, cirq.Circuit)
 
-        json_dict = self._client.neutral_atom_compile(
-            {"cirq_circuits": serialized_circuits, "target": target}
-        )
-        try:
-            pulses = gss.serialization.deserialize(json_dict["pulses"])
-        except ModuleNotFoundError as e:
-            raise gss.SuperstaQModuleNotFoundException(
-                name=str(e.name), context="neutral_atom_compile"
-            )
+        target = self._resolve_target(target)
+
+        request_json = {
+            "cirq_circuits": serialized_circuits,
+            "target": target,
+            "options": cirq.to_json(kwargs),
+        }
+
+        json_dict = self._client.compile(request_json)
 
-        if isinstance(circuits, cirq.Circuit):
-            return pulses[0]
-        return pulses
+        return css.compiler_output.read_json(json_dict, circuits_is_list)
 
     def supercheq(
         self, files: List[List[int]], num_qubits: int, depth: int
     ) -> Tuple[List[cirq.Circuit], npt.NDArray[np.float_]]:
-        """Returns the randomly generated circuits and the fidelity matrix for inputted files"""
+        """Returns the randomly generated circuits and the fidelity matrix for inputted files."""
+
         json_dict = self._client.supercheq(files, num_qubits, depth, "cirq_circuits")
         circuits = css.serialization.deserialize_circuits(json_dict["cirq_circuits"])
         fidelities = gss.serialization.deserialize(json_dict["fidelities"])
         return circuits, fidelities
+
+    def target_info(self, target: str) -> Dict[str, Any]:
+        """Returns information about device specified by `target`."""
+        target = self._resolve_target(target)
+        return self._client.target_info(target)["target_info"]
```

## cirq_superstaq/service_test.py

```diff
@@ -6,14 +6,15 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
+# pylint: disable=missing-function-docstring
 
 import collections
 import json
 import os
 import textwrap
 from unittest import mock
 
@@ -24,14 +25,27 @@
 import pytest
 import sympy
 from general_superstaq import ResourceEstimate
 
 import cirq_superstaq as css
 
 
+@pytest.mark.parametrize("gate", [cirq.Y, cirq.CX, cirq.CCZ, css.QutritZ0, css.BSWAP])
+def test_to_matrix_gate(gate: cirq.Gate) -> None:
+    matrix = cirq.unitary(gate)
+    qid_shape = cirq.qid_shape(gate)
+    assert css.service._to_matrix_gate(matrix) == cirq.MatrixGate(matrix, qid_shape=qid_shape)
+
+
+def test_to_matrix_gate_error() -> None:
+    matrix = np.eye(5)
+    with pytest.raises(ValueError, match="Could not determine qid_shape"):
+        _ = css.service._to_matrix_gate(matrix)
+
+
 def test_counts_to_results() -> None:
     qubits = cirq.LineQubit.range(3)
 
     circuit = cirq.Circuit(
         cirq.H(qubits[1]),
         cirq.CNOT(qubits[0], qubits[1]),
         cirq.measure(qubits[0]),
@@ -46,14 +60,33 @@
         cirq.measure(qubits[0], key="0"),
         cirq.measure(qubits[1], key="1"),
     )
     result = css.service.counts_to_results({"00": 50, "11": 50}, circuit, cirq.ParamResolver({}))
     assert result.histogram(key="01") == collections.Counter({0: 50, 3: 50})
 
 
+def test_validate_cirq_circuits() -> None:
+    qubits = [cirq.LineQubit(i) for i in range(2)]
+    circuit = cirq.Circuit(cirq.H(qubits[0]), cirq.CNOT(qubits[0], qubits[1]))
+
+    with pytest.raises(
+        ValueError,
+        match="Invalid 'circuits' input. Must be a `cirq.Circuit` or a "
+        "sequence of `cirq.Circuit` instances.",
+    ):
+        css.service._validate_cirq_circuits("circuit_invalid")
+
+    with pytest.raises(
+        ValueError,
+        match="Invalid 'circuits' input. Must be a `cirq.Circuit` or a "
+        "sequence of `cirq.Circuit` instances.",
+    ):
+        css.service._validate_cirq_circuits([circuit, "circuit_invalid"])
+
+
 def test_service_resolve_target() -> None:
     service = css.Service(api_key="key", default_target="ss_bar_qpu")
     assert service._resolve_target("ss_foo_qpu") == "ss_foo_qpu"
     assert service._resolve_target(None) == "ss_bar_qpu"
 
     service = css.Service(api_key="key")
     assert service._resolve_target("ss_foo_qpu") == "ss_foo_qpu"
@@ -66,15 +99,14 @@
     mock_client = mock.MagicMock()
     mock_client.create_job.return_value = {
         "job_ids": ["job_id"],
         "status": "ready",
     }
     mock_client.get_job.return_value = {
         "data": {"histogram": {"11": 1}},
-        "job_id": "my_id",
         "samples": {"11": 1},
         "shots": [
             {
                 "data": {"counts": {"0x3": 1}},
                 "meas_level": 2,
                 "seed_simulator": 775709958,
                 "shots": 1,
@@ -115,15 +147,14 @@
     mock_client.create_job.return_value = {
         "job_ids": ["job_id"],
         "status": "ready",
     }
     mock_client.get_job.return_value = {
         "data": {"histogram": {"0": 3, "1": 1}},
         "num_qubits": 1,
-        "job_id": "my_id",
         "samples": {"0": 3, "1": 1},
         "shots": [
             {
                 "shots": 1,
                 "status": "DONE",
             }
         ],
@@ -140,15 +171,15 @@
     )
     mock_client.create_job.assert_called_once()
 
 
 def test_service_get_job() -> None:
     service = css.Service(api_key="key", remote_host="http://example.com")
     mock_client = mock.MagicMock()
-    job_dict = {"job_id": "job_id", "status": "ready"}
+    job_dict = {"status": "ready"}
     mock_client.get_job.return_value = job_dict
     service._client = mock_client
 
     job = service.get_job("job_id")
 
     # get_job() should not be called upon construction
     assert job.job_id() == "job_id"
@@ -159,36 +190,39 @@
     mock_client.get_job.assert_called_once_with("job_id")
 
 
 def test_service_create_job() -> None:
     service = css.Service(api_key="key", remote_host="http://example.com")
     mock_client = mock.MagicMock()
     mock_client.create_job.return_value = {"job_ids": ["job_id"], "status": "ready"}
-    mock_client.get_job.return_value = {"job_id": "job_id", "status": "completed"}
+    mock_client.get_job.return_value = {"status": "completed"}
     service._client = mock_client
 
     circuit = cirq.Circuit(cirq.X(cirq.LineQubit(0)), cirq.measure(cirq.LineQubit(0)))
     job = service.create_job(
         circuit=circuit,
         repetitions=100,
         target="ss_fake_qpu",
         method="fake_method",
-        options={"fake_data": ""},
+        fake_data="",
     )
     assert job.status() == "completed"
     create_job_kwargs = mock_client.create_job.call_args[1]
     # Serialization induces a float, so we don't validate full circuit.
     assert create_job_kwargs["repetitions"] == 100
     assert create_job_kwargs["target"] == "ss_fake_qpu"
     assert create_job_kwargs["method"] == "fake_method"
-    assert create_job_kwargs["options"] == {"fake_data": ""}
+    assert create_job_kwargs["fake_data"] == ""
 
     with pytest.raises(ValueError, match="Circuit has no measurements to sample"):
         service.create_job(cirq.Circuit())
 
+    with pytest.raises(ValueError, match="does not support the submission of multiple circuits"):
+        service.create_job([cirq.Circuit()])  # type: ignore
+
 
 def test_service_get_balance() -> None:
     service = css.Service(api_key="key", remote_host="http://example.com")
     mock_client = mock.MagicMock()
     mock_client.get_balance.return_value = {"balance": 12345.6789}
     service._client = mock_client
 
@@ -229,229 +263,342 @@
     mock_client.get_targets.return_value = targets
     service._client = mock_client
 
     assert service.get_targets() == targets["superstaq_targets"]
 
 
 @mock.patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.aqt_compile",
+    "general_superstaq.superstaq_client._SuperstaqClient.post_request",
     return_value={
         "cirq_circuits": css.serialization.serialize_circuits(cirq.Circuit()),
         "state_jp": gss.serialization.serialize({}),
         "pulse_lists_jp": gss.serialization.serialize([[[]]]),
+        "final_logical_to_physicals": cirq.to_json([[]]),
     },
 )
-def test_service_aqt_compile_single(mock_aqt_compile: mock.MagicMock) -> None:
+def test_service_aqt_compile_single(mock_post_request: mock.MagicMock) -> None:
     service = css.Service(api_key="key", remote_host="http://example.com")
-    out = service.aqt_compile(cirq.Circuit())
+    out = service.aqt_compile(cirq.Circuit(), test_options="yes")
+    mock_post_request.assert_called_once_with(
+        "/aqt_compile",
+        {
+            "cirq_circuits": css.serialization.serialize_circuits(cirq.Circuit()),
+            "target": "aqt_keysight_qpu",
+            "options": '{\n  "test_options": "yes"\n}',
+        },
+    )
+    assert out.circuit == cirq.Circuit()
+    assert out.final_logical_to_physical == {}
+    assert not hasattr(out, "circuits") and not hasattr(out, "pulse_lists")
+    assert not hasattr(out, "final_logical_to_physicals")
+
+    gate_defs = {
+        "CZ3": css.CZ3,
+        "CZ3/T5C4": None,
+        "CS/simul": css.ParallelGates(cirq.CZ, cirq.CZ).on(*cirq.LineQubit.range(4, 8)),
+        "CS2": cirq.unitary(cirq.CZ**0.49),
+        "CS3": cirq.unitary(css.CZ3**0.5),
+    }
+    out = service.aqt_compile(cirq.Circuit(), gate_defs=gate_defs, atol=1e-3)
+
+    expected_options = {
+        "atol": 1e-3,
+        "gate_defs": {
+            "CZ3": css.CZ3,
+            "CZ3/T5C4": None,
+            "CS/simul": css.ParallelGates(cirq.CZ, cirq.CZ).on(*cirq.LineQubit.range(4, 8)),
+            "CS2": cirq.MatrixGate(cirq.unitary(cirq.CZ**0.49), name="CS2"),
+            "CS3": cirq.MatrixGate(cirq.unitary(css.CZ3**0.5), qid_shape=(3, 3), name="CS3"),
+        },
+    }
+    mock_post_request.assert_called_with(
+        "/aqt_compile",
+        {
+            "cirq_circuits": css.serialization.serialize_circuits(cirq.Circuit()),
+            "target": "aqt_keysight_qpu",
+            "options": cirq.to_json(expected_options),
+        },
+    )
     assert out.circuit == cirq.Circuit()
     assert not hasattr(out, "circuits") and not hasattr(out, "pulse_lists")
 
+    with pytest.raises(ValueError, match="'ss_example_qpu' is not a valid AQT target."):
+        service.aqt_compile(cirq.Circuit(), target="ss_example_qpu")
+
 
 @mock.patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.aqt_compile",
+    "general_superstaq.superstaq_client._SuperstaqClient.post_request",
     return_value={
         "cirq_circuits": css.serialization.serialize_circuits([cirq.Circuit(), cirq.Circuit()]),
         "state_jp": gss.serialization.serialize({}),
         "pulse_lists_jp": gss.serialization.serialize([[[]], [[]]]),
+        "final_logical_to_physicals": cirq.to_json([[], []]),
     },
 )
-def test_service_aqt_compile_multiple(mock_aqt_compile: mock.MagicMock) -> None:
+def test_service_aqt_compile_multiple(mock_post_request: mock.MagicMock) -> None:
     service = css.Service(api_key="key", remote_host="http://example.com")
-    out = service.aqt_compile([cirq.Circuit(), cirq.Circuit()])
+    out = service.aqt_compile([cirq.Circuit(), cirq.Circuit()], atol=1e-2)
+    mock_post_request.assert_called_once()
     assert out.circuits == [cirq.Circuit(), cirq.Circuit()]
+    assert out.final_logical_to_physicals == [{}, {}]
     assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
+    assert not hasattr(out, "final_logical_to_physical")
 
 
 @mock.patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.post_request",
+    "general_superstaq.superstaq_client._SuperstaqClient.post_request",
     return_value={
         "cirq_circuits": css.serialization.serialize_circuits([cirq.Circuit()]),
         "state_jp": gss.serialization.serialize({}),
         "pulse_lists_jp": gss.serialization.serialize([[[]]]),
+        "final_logical_to_physicals": cirq.to_json([[]]),
     },
 )
-def test_service_aqt_compile_eca(mock_aqt_compile: mock.MagicMock) -> None:
+def test_service_aqt_compile_eca(mock_post_request: mock.MagicMock) -> None:
     service = css.Service(api_key="key", remote_host="http://example.com")
-    out = service.aqt_compile_eca(cirq.Circuit(), num_equivalent_circuits=1, random_seed=1234)
+    out = service.aqt_compile(cirq.Circuit(), num_eca_circuits=1, random_seed=1234, atol=1e-2)
+    mock_post_request.assert_called_once()
     assert out.circuits == [cirq.Circuit()]
-    assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
+    assert out.final_logical_to_physicals == [{}]
+    assert not hasattr(out, "circuit")
+    assert not hasattr(out, "pulse_list")
+    assert not hasattr(out, "final_logical_to_physical")
+
+    out = service.aqt_compile([cirq.Circuit()], num_eca_circuits=1, random_seed=1234, atol=1e-2)
+    assert out.circuits == [[cirq.Circuit()]]
+    assert out.final_logical_to_physicals == [[{}]]
+
+    with pytest.warns(DeprecationWarning, match="has been deprecated"):
+        deprecated_out = service.aqt_compile_eca(
+            [cirq.Circuit()], num_equivalent_circuits=1, random_seed=1234, atol=1e-2
+        )
+        assert deprecated_out.circuits == out.circuits
+        assert deprecated_out.final_logical_to_physicals == out.final_logical_to_physicals
 
 
 @mock.patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.resource_estimate",
+    "general_superstaq.superstaq_client._SuperstaqClient.resource_estimate",
 )
 def test_service_resource_estimate(mock_resource_estimate: mock.MagicMock) -> None:
     service = css.Service(remote_host="http://example.com", api_key="key")
 
     resource_estimate = ResourceEstimate(0, 1, 2)
 
     mock_resource_estimate.return_value = {
         "resource_estimates": [{"num_single_qubit_gates": 0, "num_two_qubit_gates": 1, "depth": 2}]
     }
 
-    assert service.resource_estimate(cirq.Circuit(), "qasm_simulator") == resource_estimate
+    assert service.resource_estimate(cirq.Circuit(), "ibmq_qasm_simulator") == resource_estimate
 
 
 @mock.patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.resource_estimate",
+    "general_superstaq.superstaq_client._SuperstaqClient.resource_estimate",
 )
 def test_service_resource_estimate_list(mock_resource_estimate: mock.MagicMock) -> None:
     service = css.Service(remote_host="http://example.com", api_key="key")
 
     resource_estimates = [ResourceEstimate(0, 1, 2), ResourceEstimate(3, 4, 5)]
 
     mock_resource_estimate.return_value = {
         "resource_estimates": [
             {"num_single_qubit_gates": 0, "num_two_qubit_gates": 1, "depth": 2},
             {"num_single_qubit_gates": 3, "num_two_qubit_gates": 4, "depth": 5},
         ]
     }
 
-    assert service.resource_estimate([cirq.Circuit()], "qasm_simulator") == resource_estimates
+    assert service.resource_estimate([cirq.Circuit()], "ibmq_qasm_simulator") == resource_estimates
 
 
-@mock.patch("general_superstaq.superstaq_client._SuperstaQClient.qscout_compile")
+@mock.patch("general_superstaq.superstaq_client._SuperstaqClient.qscout_compile")
 def test_service_qscout_compile_single(mock_qscout_compile: mock.MagicMock) -> None:
 
     q0 = cirq.LineQubit(0)
     circuit = cirq.Circuit(cirq.H(q0), cirq.measure(q0))
+    final_logical_to_physical = {q0: q0}
 
     jaqal_program = textwrap.dedent(
         """\
         register allqubits[1]
         prepare_all
         R allqubits[0] -1.5707963267948966 1.5707963267948966
         Rz allqubits[0] -3.141592653589793
         measure_all
         """
     )
 
     mock_qscout_compile.return_value = {
         "cirq_circuits": css.serialization.serialize_circuits(circuit),
+        "final_logical_to_physicals": cirq.to_json([list(final_logical_to_physical.items())]),
         "jaqal_programs": [jaqal_program],
     }
 
     service = css.Service(api_key="key", remote_host="http://example.com")
-    out = service.qscout_compile(circuit)
+    out = service.qscout_compile(circuit, test_options="yes")
     assert out.circuit == circuit
+    assert out.final_logical_to_physical == final_logical_to_physical
     assert out.jaqal_program == jaqal_program
 
+    with pytest.raises(ValueError, match="'ss_example_qpu' is not a valid Sandia target."):
+        service.qscout_compile(cirq.Circuit(), target="ss_example_qpu")
+
 
-@mock.patch("general_superstaq.superstaq_client._SuperstaQClient.qscout_compile")
+@mock.patch("general_superstaq.superstaq_client._SuperstaqClient.qscout_compile")
 @pytest.mark.parametrize("mirror_swaps", (True, False))
 def test_qscout_compile_swap_mirror(
     mock_qscout_compile: mock.MagicMock, mirror_swaps: bool
 ) -> None:
     q0 = cirq.LineQubit(0)
     circuit = cirq.Circuit(cirq.measure(q0))
+    final_logical_to_physical = {q0: q0}
 
     jaqal_program = ""
 
     mock_qscout_compile.return_value = {
         "cirq_circuits": css.serialization.serialize_circuits(circuit),
+        "final_logical_to_physicals": cirq.to_json([list(final_logical_to_physical.items())]),
         "jaqal_programs": [jaqal_program],
     }
 
     service = css.Service(api_key="key", remote_host="http://example.com")
     out = service.qscout_compile(circuit, mirror_swaps=mirror_swaps)
     assert out.circuit == circuit
+    assert out.final_logical_to_physical == final_logical_to_physical
+    assert out.jaqal_program == jaqal_program
+    mock_qscout_compile.assert_called_once()
+    assert json.loads(mock_qscout_compile.call_args[0][0]["options"]) == {
+        "mirror_swaps": mirror_swaps,
+        "base_entangling_gate": "xx",
+    }
+
+
+@mock.patch("general_superstaq.superstaq_client._SuperstaqClient.qscout_compile")
+@pytest.mark.parametrize("base_entangling_gate", ("xx", "zz"))
+def test_qscout_compile_base_entangling_gate(
+    mock_qscout_compile: mock.MagicMock, base_entangling_gate: str
+) -> None:
+    q0 = cirq.LineQubit(0)
+    circuit = cirq.Circuit(cirq.measure(q0))
+    final_logical_to_physical = {q0: q0}
+
+    jaqal_program = ""
+
+    mock_qscout_compile.return_value = {
+        "cirq_circuits": css.serialization.serialize_circuits(circuit),
+        "final_logical_to_physicals": cirq.to_json([list(final_logical_to_physical.items())]),
+        "jaqal_programs": [jaqal_program],
+    }
+
+    service = css.Service(api_key="key", remote_host="http://example.com")
+    out = service.qscout_compile(circuit, base_entangling_gate=base_entangling_gate)
+    assert out.circuit == circuit
+    assert out.final_logical_to_physical == final_logical_to_physical
     assert out.jaqal_program == jaqal_program
     mock_qscout_compile.assert_called_once()
     assert json.loads(mock_qscout_compile.call_args[0][0]["options"]) == {
-        "mirror_swaps": mirror_swaps
+        "mirror_swaps": False,
+        "base_entangling_gate": base_entangling_gate,
     }
 
 
-@mock.patch("general_superstaq.superstaq_client._SuperstaQClient.cq_compile")
-def test_service_cq_compile_single(mock_cq_compile: mock.MagicMock) -> None:
+def test_qscout_compile_wrong_base_entangling_gate() -> None:
+    q0 = cirq.LineQubit(0)
+    circuit = cirq.Circuit(cirq.measure(q0))
+
+    service = css.Service(api_key="key", remote_host="http://example.com")
+    with pytest.raises(ValueError):
+        _ = service.qscout_compile(circuit, base_entangling_gate="yy")
+
+
+@mock.patch("requests.post")
+def test_service_cq_compile_single(mock_post: mock.MagicMock) -> None:
 
     q0 = cirq.LineQubit(0)
     circuit = cirq.Circuit(cirq.H(q0), cirq.measure(q0))
+    final_logical_to_physical = {cirq.q(10): cirq.q(0)}
 
-    mock_cq_compile.return_value = {
+    mock_post.return_value.json = lambda: {
         "cirq_circuits": css.serialization.serialize_circuits(circuit),
+        "final_logical_to_physicals": cirq.to_json([list(final_logical_to_physical.items())]),
     }
 
     service = css.Service(api_key="key", remote_host="http://example.com")
-    out = service.cq_compile(circuit)
+    out = service.cq_compile(circuit, test_options="yes")
     assert out.circuit == circuit
+    assert out.final_logical_to_physical == final_logical_to_physical
 
+    with pytest.raises(ValueError, match="'ss_example_qpu' is not a valid CQ target."):
+        service.cq_compile(cirq.Circuit(), target="ss_example_qpu")
 
-@mock.patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.ibmq_compile",
-)
-def test_service_ibmq_compile(mock_ibmq_compile: mock.MagicMock) -> None:
+
+@mock.patch("requests.post")
+def test_service_ibmq_compile(mock_post: mock.MagicMock) -> None:
     service = css.Service(api_key="key", remote_host="http://example.com")
 
     q0 = cirq.LineQubit(0)
     circuit = cirq.Circuit(cirq.H(q0), cirq.measure(q0))
+    final_logical_to_physical = {cirq.q(4): cirq.q(0)}
 
-    mock_ibmq_compile.return_value = {
+    mock_post.return_value.json = lambda: {
         "cirq_circuits": css.serialization.serialize_circuits(circuit),
         "pulses": gss.serialization.serialize([mock.DEFAULT]),
+        "final_logical_to_physicals": cirq.to_json([list(final_logical_to_physical.items())]),
     }
 
-    assert service.ibmq_compile(circuit).circuit == circuit
+    assert service.ibmq_compile(circuit, test_options="yes").circuit == circuit
     assert service.ibmq_compile([circuit]).circuits == [circuit]
     assert service.ibmq_compile(circuit).pulse_sequence == mock.DEFAULT
     assert service.ibmq_compile([circuit]).pulse_sequences == [mock.DEFAULT]
+    assert service.ibmq_compile(circuit).final_logical_to_physical == final_logical_to_physical
+    assert service.ibmq_compile([circuit]).final_logical_to_physicals == [final_logical_to_physical]
 
     with mock.patch.dict("sys.modules", {"qiskit": None}):
         assert service.ibmq_compile(cirq.Circuit()).pulse_sequence is None
         assert service.ibmq_compile([cirq.Circuit()]).pulse_sequences is None
 
-    with pytest.raises(ValueError, match="not an IBMQ target"):
-        _ = service.ibmq_compile(cirq.Circuit(), target="aqt_keysight_qpu")
-
-
-@mock.patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.neutral_atom_compile",
-    return_value={"pulses": gss.serialization.serialize([mock.DEFAULT])},
-)
-def test_service_neutral_atom_compile(mock_neutral_atom_compile: mock.MagicMock) -> None:
-    service = css.Service(api_key="key", remote_host="http://example.com")
-    assert service.neutral_atom_compile(cirq.Circuit()) == mock.DEFAULT
-    assert service.neutral_atom_compile([cirq.Circuit()]) == [mock.DEFAULT]
-
-    with mock.patch.dict("sys.modules", {"unittest": None}), pytest.raises(
-        gss.SuperstaQModuleNotFoundException,
-        match="'neutral_atom_compile' requires module 'unittest'",
-    ):
-        _ = service.neutral_atom_compile(cirq.Circuit())
+    with pytest.raises(ValueError, match="'ss_example_qpu' is not a valid IBMQ target."):
+        service.ibmq_compile(cirq.Circuit(), target="ss_example_qpu")
 
 
 @mock.patch(
-    "general_superstaq.superstaq_client._SuperstaQClient.supercheq",
+    "general_superstaq.superstaq_client._SuperstaqClient.supercheq",
 )
 def test_service_supercheq(mock_supercheq: mock.MagicMock) -> None:
     service = css.Service(api_key="key", remote_host="http://example.com")
     circuits = [cirq.Circuit()]
     fidelities = np.array([1])
     mock_supercheq.return_value = {
         "cirq_circuits": css.serialization.serialize_circuits(circuits),
         "fidelities": gss.serialization.serialize(fidelities),
     }
     assert service.supercheq([[0]], 1, 1) == (circuits, fidelities)
 
 
+@mock.patch("requests.post")
+def test_service_target_info(mock_post: mock.MagicMock) -> None:
+    fake_data = {"target_info": {"backend_name": "ss_example_qpu", "max_experiments": 1234}}
+    mock_post.return_value.json = lambda: fake_data
+    service = css.Service(api_key="key", remote_host="http://example.com")
+    assert service.target_info("ss_example_qpu") == fake_data["target_info"]
+
+
 @mock.patch.dict(os.environ, {"SUPERSTAQ_API_KEY": "tomyheart"})
 def test_service_api_key_via_env() -> None:
     service = css.Service(remote_host="http://example.com")
-    assert service.api_key == "tomyheart"
+    assert service._client.api_key == "tomyheart"
 
 
 @mock.patch.dict(os.environ, {"SUPERSTAQ_REMOTE_HOST": "http://example.com"})
 def test_service_remote_host_via_env() -> None:
     service = css.Service("tomyheart")
-    assert service.remote_host == "http://example.com"
+    assert service._client.remote_host == "http://example.com"
 
 
 @mock.patch.dict(os.environ, {"SUPERSTAQ_API_KEY": ""})
 def test_service_no_param_or_env_variable() -> None:
     with pytest.raises(EnvironmentError):
         _ = css.Service(remote_host="http://example.com")
 
 
+@mock.patch.dict(os.environ, clear=True)
 def test_service_no_url_default() -> None:
     service = css.Service("tomyheart")
-    assert service.remote_host == gss.API_URL
+    assert service._client.remote_host == gss.API_URL
```

## Comparing `cirq_superstaq/custom_gates.py` & `cirq_superstaq/ops/qubit_gates.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,18 +1,28 @@
 """Miscellaneous custom gates that we encounter and want to explicitly define."""
 
-from typing import AbstractSet, Any, Dict, Iterator, List, Optional, Sequence, Tuple, Type, Union
+from typing import AbstractSet, Any, Dict, Iterator, List, Optional, Set, Tuple, Type, Union
 
 import cirq
 import numpy as np
 import numpy.typing as npt
+from cirq.ops.common_gates import _pi
 
 import cirq_superstaq as css
 
 
+def approx_eq_mod(a: cirq.TParamVal, b: cirq.TParamVal, period: float, atol: float = 1e-8) -> bool:
+    """Check if a ~= b (mod period). If either input is an unresolved parameter, returns a == b."""
+
+    if cirq.is_parameterized(a) or cirq.is_parameterized(b):
+        return a == b
+
+    return cirq.all_near_zero_mod(a - b, period, atol=atol)
+
+
 @cirq.value_equality(approximate=True)
 class ZZSwapGate(cirq.Gate, cirq.ops.gate_features.InterchangeableQubitsGate):
     r"""The ZZ-SWAP gate, which performs the ZZ-interaction followed by a SWAP.
 
     ZZ-SWAPs are useful for applications like QAOA or Hamiltonian Simulation,
     particularly on linear- or low- connectivity devices. See https://arxiv.org/pdf/2004.14970.pdf
     for an application of ZZ SWAP networks.
@@ -29,19 +39,18 @@
         \end{bmatrix}
 
     where '.' means '0'.
     For :math:`\theta = 0`, the ZZ-SWAP gate is just an ordinary SWAP.
     """
 
     def __init__(self, theta: cirq.TParamVal) -> None:
+        """Args:
+        theta: ZZ-interaction angle in radians
         """
-        Args:
-            theta: ZZ-interaction angle in radians
-        """
-        self.theta = np.pi * cirq.chosen_angle_to_canonical_half_turns(rads=theta)
+        self.theta = theta
 
     def _num_qubits_(self) -> int:
         return 2
 
     def _unitary_(self) -> Optional[npt.NDArray[np.complex_]]:
         if self._is_parameterized_():
             return None
@@ -51,90 +60,98 @@
                 [0, 0, np.exp(1j * self.theta), 0],
                 [0, np.exp(1j * self.theta), 0, 0],
                 [0, 0, 0, 1],
             ]
         )
 
     def _value_equality_values_(self) -> cirq.TParamVal:
-        return self.theta
+        if cirq.is_parameterized(self.theta):
+            return self.theta
+
+        return self.theta % (2 * np.pi)
+
+    def _value_equality_approximate_values_(self) -> cirq.PeriodicValue:
+        return cirq.PeriodicValue(self.theta, 2 * np.pi)
 
     def __pow__(
-        self, exponent: float
-    ) -> Union["ZZSwapGate", cirq.type_workarounds.NotImplementedType]:
-        if exponent in (-1, 0, 1):
+        self, exponent: cirq.TParamVal
+    ) -> Union["ZZSwapGate", cirq.ZZPowGate, cirq.type_workarounds.NotImplementedType]:
+        if exponent % 2 == 1:
             return ZZSwapGate(exponent * self.theta)
+        if exponent % 2 == 0:
+            return cirq.ZZPowGate(exponent=exponent * self.theta / _pi(self.theta))
         return NotImplemented
 
     def __str__(self) -> str:
         return f"ZZSwapGate({self.theta})"
 
     def __repr__(self) -> str:
         return f"css.ZZSwapGate({self.theta})"
 
     def _decompose_(self, qubits: Tuple[cirq.Qid, cirq.Qid]) -> Iterator[cirq.Operation]:
         yield cirq.CX(qubits[0], qubits[1])
         yield cirq.CX(qubits[1], qubits[0])
-        yield cirq.Z(qubits[1]) ** (self.theta / np.pi)
+        yield cirq.Z(qubits[1]) ** (self.theta / _pi(self.theta))
         yield cirq.CX(qubits[0], qubits[1])
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
         t = args.format_radians(self.theta)
         return cirq.CircuitDiagramInfo(wire_symbols=(f"ZZSwap({t})", f"ZZSwap({t})"))
 
     def _is_parameterized_(self) -> bool:
         return cirq.is_parameterized(self.theta)
 
     def _parameter_names_(self) -> AbstractSet[str]:
         return cirq.parameter_names(self.theta)
 
     def _resolve_parameters_(self, resolver: cirq.ParamResolver, recursive: bool) -> "ZZSwapGate":
         return ZZSwapGate(
-            cirq.protocols.resolve_parameters(self.theta, resolver, recursive),
+            cirq.resolve_parameters(self.theta, resolver, recursive),
         )
 
     def _has_unitary_(self) -> bool:
         return not self._is_parameterized_()
 
-    def _apply_unitary_(self, args: cirq.protocols.ApplyUnitaryArgs) -> npt.NDArray[np.complex_]:
+    def _apply_unitary_(self, args: cirq.ApplyUnitaryArgs) -> npt.NDArray[np.complex_]:
         zo = args.subspace_index(0b01)
         oz = args.subspace_index(0b10)
         args.available_buffer[zo] = args.target_tensor[zo]
         args.target_tensor[zo] = args.target_tensor[oz]
         args.target_tensor[oz] = args.available_buffer[zo]
         args.target_tensor[zo] *= np.exp(1j * self.theta)
         args.target_tensor[oz] *= np.exp(1j * self.theta)
         return args.target_tensor
 
     def _pauli_expansion_(
         self,
     ) -> Union[cirq.value.LinearDict[str], cirq.type_workarounds.NotImplementedType]:
-        if cirq.protocols.is_parameterized(self):
+        if cirq.is_parameterized(self):
             return NotImplemented
         return cirq.value.LinearDict(
             {
                 "II": 0.5,
                 "XX": 0.5 * np.exp(1j * self.theta),
                 "YY": 0.5 * np.exp(1j * self.theta),
                 "ZZ": 0.5,
             }
         )
 
     def _qasm_(self, args: cirq.QasmArgs, qubits: Tuple[cirq.Qid, cirq.Qid]) -> Optional[str]:
-        if np.isclose(self.theta, 0.0):
+        if approx_eq_mod(self.theta, 0.0, 2 * np.pi):
             return cirq.SWAP._qasm_(args, qubits)
 
         return args.format(
             "zzswap({0:half_turns}) {1},{2};\n",
             self.theta / np.pi,
             qubits[0],
             qubits[1],
         )
 
     def _json_dict_(self) -> Dict[str, Any]:
-        return cirq.protocols.obj_to_dict_helper(self, ["theta"])
+        return cirq.obj_to_dict_helper(self, ["theta"])
 
 
 class ZXPowGate(cirq.EigenGate, cirq.Gate):
     r"""The ZX-parity gate, possibly raised to a power.
 
     Per arxiv.org/pdf/1904.06560v3 eq. 135, the ZX**t gate implements the following unitary:
 
@@ -170,18 +187,16 @@
 
     def _eigen_shifts(self) -> List[float]:
         return [0, 1]
 
     def _num_qubits_(self) -> int:
         return 2
 
-    def _circuit_diagram_info_(
-        self, args: cirq.CircuitDiagramInfoArgs
-    ) -> cirq.protocols.CircuitDiagramInfo:
-        return cirq.protocols.CircuitDiagramInfo(
+    def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
+        return cirq.CircuitDiagramInfo(
             wire_symbols=("Z", "X"), exponent=self._diagram_exponent(args)
         )
 
     def _qasm_(self, args: cirq.QasmArgs, qubits: Tuple[cirq.Qid, ...]) -> Optional[str]:
         return args.format(
             "rzx({0:half_turns}) {1},{2};\n",
             self.exponent,
@@ -203,105 +218,157 @@
             f"css.ZXPowGate(exponent={cirq._compat.proper_repr(self._exponent)},"
             f" global_shift={self._global_shift!r})"
         )
 
 
 @cirq.value_equality(approximate=True)
 class AceCR(cirq.Gate):
-    """Active Cancellation Echoed Cross Resonance gate, supporting polarity switches and sandwiches.
+    """Active Cancellation Echoed Cross Resonance (AceCR) gate, parametrized (e.g., supporting
+    polarity switches) and supporting sandwiches.
 
     The typical AceCR in literature is a positive half-CR, then X on "Z side", then negative
     half-CR ("Z side" and "X side" refer to the two sides of the underlying ZX interactions).
 
     Args:
-        polarity: Should be either "+-" or "-+". Specifies if positive or negative half-CR is first
+        rads: Angle of rotation for CR gate (i.e., twice the angle for each echoed half-CR).
         sandwich_rx_rads: Angle of rotation for an rx gate applied to the "X side" simultaneously
             with the X gate on the "Z side".
     """
 
-    def __init__(self, polarity: str, sandwich_rx_rads: float = 0) -> None:
-        if polarity not in ("+-", "-+"):
+    def __init__(
+        self, rads: Union[str, cirq.TParamVal] = np.pi / 2, sandwich_rx_rads: cirq.TParamVal = 0
+    ) -> None:
+        # Polarity should be "+-" or "-+", specifying if positive or negative half-CR is first.
+        if rads == "+-":
+            rads = np.pi / 2
+        elif rads == "-+":
+            rads = -np.pi / 2
+        elif isinstance(rads, str):
             raise ValueError("Polarity must be either '+-' or '-+'")
-        self.polarity = polarity
+        self.rads = rads
         self.sandwich_rx_rads = sandwich_rx_rads
 
     def _num_qubits_(self) -> int:
         return 2
 
     def _decompose_(
         self, qubits: Tuple[cirq.LineQubit, cirq.LineQubit]
     ) -> Iterator[cirq.Operation]:
-        yield css.CR(*qubits) ** 0.25 if self.polarity == "+-" else css.CR(*qubits) ** -0.25
+        frac = self.rads / (2 * _pi(self.rads))
+        yield css.CR(*qubits) ** frac
         yield cirq.X(qubits[0])
         if self.sandwich_rx_rads:
             yield cirq.rx(self.sandwich_rx_rads)(qubits[1])
-        yield css.CR(*qubits) ** -0.25 if self.polarity == "+-" else css.CR(*qubits) ** 0.25
+        yield css.CR(*qubits) ** -frac
 
-    def _circuit_diagram_info_(
-        self, args: cirq.CircuitDiagramInfoArgs
-    ) -> cirq.protocols.CircuitDiagramInfo:
-        top, bottom = f"AceCR{self.polarity}(Z side)", f"AceCR{self.polarity}(X side)"
+    def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
+        if self.rads == np.pi / 2:
+            rads_str = "+-"
+        elif self.rads == -np.pi / 2:
+            rads_str = "-+"
+        else:
+            rads_str = f"({args.format_radians(self.rads)})"
+        top, bottom = (f"AceCR{rads_str}(Z side)", f"AceCR{rads_str}(X side)")
         if self.sandwich_rx_rads:
             bottom += f"|Rx({args.format_radians(self.sandwich_rx_rads)})|"
-        return cirq.protocols.CircuitDiagramInfo(wire_symbols=(top, bottom))
+        return cirq.CircuitDiagramInfo(wire_symbols=(top, bottom))
 
     def _qasm_(self, args: cirq.QasmArgs, qubits: Tuple[cirq.Qid, cirq.Qid]) -> Optional[str]:
-        """QASM symbol for AceCR("+-") (AceCR("-+")) is acecr_pm (acecr_mp)
+        """QASM symbol for AceCR, "acecr(rads)".
 
-        If there is a sandwich, it comes last. For example, AceCR("-+", np.pi / 2) has qasm
-        acecr_mp_rx(pi*0.5).
+        If there is a sandwich, it comes last. For example, AceCR(sandwich_rx_rads=np.pi / 2) has
+        qasm acecr_rx(pi*0.5,pi*0.5), and AceCR(rads=np.pi, sandwich_rx_rads=np.pi / 2) has qasm
+        acecr_rx(pi, pi*0.5).
         """
-        polarity_str = self.polarity.replace("+", "p").replace("-", "m")
-        if not self.sandwich_rx_rads:
-            return args.format("acecr_{} {},{};\n", polarity_str, *qubits)
-        exponent = self.sandwich_rx_rads / np.pi
-        return args.format("acecr_{}_rx({:half_turns}) {},{};\n", polarity_str, exponent, *qubits)
+        if self.sandwich_rx_rads != 0:
+            rads_exp = self.rads / np.pi
+            sandwich_exp = self.sandwich_rx_rads / np.pi
+            return args.format(
+                "acecr_rx({:half_turns},{:half_turns}) {},{};\n",
+                rads_exp,
+                sandwich_exp,
+                *qubits,
+            )
+        else:
+            exponent = self.rads / np.pi
+            return args.format("acecr({:half_turns}) {},{};\n", exponent, *qubits)
 
-    def _value_equality_values_(self) -> Tuple[str, float]:
-        return self.polarity, self.sandwich_rx_rads % (4 * np.pi)
+    def _is_parameterized_(self) -> bool:
+        return cirq.is_parameterized(self.sandwich_rx_rads) or cirq.is_parameterized(self.rads)
+
+    def _parameter_names_(self) -> AbstractSet[str]:
+        return cirq.parameter_names(self.sandwich_rx_rads) | cirq.parameter_names(self.rads)
+
+    def _resolve_parameters_(self, resolver: cirq.ParamResolver, recursive: bool) -> "AceCR":
+        return AceCR(
+            rads=cirq.resolve_parameters(self.rads, resolver, recursive),
+            sandwich_rx_rads=cirq.resolve_parameters(self.sandwich_rx_rads, resolver, recursive),
+        )
 
-    def _value_equality_approximate_values_(self) -> Tuple[str, cirq.PeriodicValue]:
-        return self.polarity, cirq.PeriodicValue(self.sandwich_rx_rads, 4 * np.pi)
+    def _value_equality_values_(self) -> Tuple[cirq.TParamVal, cirq.TParamVal]:
+        if cirq.is_parameterized(self.rads):
+            rads = self.rads
+        else:
+            rads = self.rads % (4 * np.pi)
+
+        if cirq.is_parameterized(self.sandwich_rx_rads):
+            sandwich_rx_rads = self.sandwich_rx_rads
+        else:
+            sandwich_rx_rads = self.sandwich_rx_rads % (4 * np.pi)
+
+        return rads, sandwich_rx_rads
+
+    def _value_equality_approximate_values_(self) -> Tuple[cirq.PeriodicValue, cirq.PeriodicValue]:
+        return (
+            cirq.PeriodicValue(self.rads, 4 * np.pi),
+            cirq.PeriodicValue(self.sandwich_rx_rads, 4 * np.pi),
+        )
 
     def _equal_up_to_global_phase_(self, other: Any, atol: float) -> Optional[bool]:
         if not isinstance(other, AceCR):
             return NotImplemented
 
-        if other.polarity != self.polarity:
-            return False
-
-        return cirq.all_near_zero_mod(
-            self.sandwich_rx_rads - other.sandwich_rx_rads, 2 * np.pi, atol=atol
+        return approx_eq_mod(self.rads, other.rads, 2 * np.pi, atol=atol) and approx_eq_mod(
+            self.sandwich_rx_rads, other.sandwich_rx_rads, 2 * np.pi, atol=atol
         )
 
     def __repr__(self) -> str:
-        if not self.sandwich_rx_rads:
-            return f"css.AceCR({self.polarity!r})"
-        return f"css.AceCR({self.polarity!r}, {self.sandwich_rx_rads!r})"
+        if not self.sandwich_rx_rads and self.rads == np.pi / 2:
+            return "css.AceCR()"
+        elif self.rads == np.pi / 2:
+            return f"css.AceCR(sandwich_rx_rads={self.sandwich_rx_rads!r})"
+        elif not self.sandwich_rx_rads:
+            return f"css.AceCR(rads={self.rads!r})"
+        return f"css.AceCR(rads={self.rads!r}, sandwich_rx_rads={self.sandwich_rx_rads!r})"
 
     def __str__(self) -> str:
-        if not self.sandwich_rx_rads:
-            return f"AceCR{self.polarity}"
-        return f"AceCR{self.polarity}|{cirq.rx(self.sandwich_rx_rads)}|"
+        if not self.sandwich_rx_rads and self.rads == np.pi / 2:
+            return "AceCR"
+        elif not self.sandwich_rx_rads:
+            return f"AceCR({self.rads})"
+        elif self.rads == np.pi / 2:
+            return f"AceCR|{cirq.rx(self.sandwich_rx_rads)}|"
+        return f"AceCR({self.rads})|{cirq.rx(self.sandwich_rx_rads)}|"
 
     def _json_dict_(self) -> Dict[str, Any]:
-        return cirq.protocols.obj_to_dict_helper(self, ["polarity", "sandwich_rx_rads"])
+        return cirq.obj_to_dict_helper(self, ["rads", "sandwich_rx_rads"])
 
 
 AceCRMinusPlus = AceCR("-+")
 
 AceCRPlusMinus = AceCR("+-")
 
 
+@cirq.value_equality
 class Barrier(cirq.ops.IdentityGate, cirq.InterchangeableQubitsGate):
     """Barrier: temporal boundary restricting circuit compilation and pulse scheduling.
     Otherwise equivalent to the identity gate.
     """
 
-    def _decompose_(self, qubits: Sequence["cirq.Qid"]) -> cirq.type_workarounds.NotImplementedType:
+    def _decompose_(self, qubits: Tuple[cirq.Qid, ...]) -> cirq.type_workarounds.NotImplementedType:
         return NotImplemented
 
     def _trace_distance_bound_(self) -> float:
         return 1.0
 
     def _qasm_(self, args: cirq.QasmArgs, qubits: Tuple[cirq.Qid, ...]) -> str:
         indices_str = ",".join([f"{{{i}}}" for i in range(len(qubits))])
@@ -318,44 +385,26 @@
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> Tuple[str, ...]:
         if args.use_unicode_characters:
             return ("",) * self.num_qubits()
         return ("|",) * self.num_qubits()
 
 
-def barrier(*qubits: cirq.Qid) -> cirq.Operation:
+def barrier(*qubits: cirq.Qid) -> cirq.Operation:  # pylint: disable=missing-function-docstring
     qid_shape = tuple(q.dimension for q in qubits)
     return css.Barrier(qid_shape=qid_shape).on(*qubits)
 
 
 @cirq.value_equality(approximate=True)
 class ParallelGates(cirq.Gate, cirq.InterchangeableQubitsGate):
-    """A single Gate combining a collection of concurrent Gate(s) acting on different qubits.
-
-    WARNING: for cirq versions 0.14.*, equality check will return False after permutations of
-        qubits between identical but nonadjacent gates, e.g.::
-
-            gate = ParallelGates(cirq.X, cirq.Y, cirq.X)
-            gate.on(q0, q1, q2) == gate.on(q2, q1, q0)  # True for cirq < 0.14.0
-                                                        # False for 0.14.0 <= cirq < 0.15.0
-                                                        # True for cirq >= 0.15.0
-
-        This does not affect permutations of qubits between adjacent gates, or those within the
-        same InterchangeableQubitsGate::
-
-            gate = ParallelGates(cirq.X, cirq.X, cirq.CZ)
-            gate.on(q0, q1, q2, q3) == gate.on(q1, q0, q3, q2)  # always True
-
-        See https://github.com/quantumlib/Cirq/issues/5148 for more information.
-    """
+    """A single Gate combining a collection of concurrent Gate(s) acting on different qubits."""
 
     def __init__(self, *component_gates: cirq.Gate) -> None:
-        """
-        Args:
-            component_gates: Gate(s) to be collected into single gate
+        """Args:
+        component_gates: Gate(s) to be collected into single gate
         """
 
         self.component_gates: Tuple[cirq.Gate, ...] = ()
 
         # unroll any ParallelGate(s) instances in component_gates
         for gate in component_gates:
             if not isinstance(gate, cirq.Gate):
@@ -365,15 +414,17 @@
             elif isinstance(gate, ParallelGates):
                 self.component_gates += gate.component_gates
             elif isinstance(gate, cirq.ParallelGate):
                 self.component_gates += gate.num_copies * (gate.sub_gate,)
             else:
                 self.component_gates += (gate,)
 
-    def qubit_index_to_gate_and_index(self, index: int) -> Tuple[cirq.Gate, int]:
+    def qubit_index_to_gate_and_index(  # pylint: disable=missing-function-docstring
+        self, index: int
+    ) -> Tuple[cirq.Gate, int]:
         for gate in self.component_gates:
             if gate.num_qubits() > index >= 0:
                 return gate, index
             index -= gate.num_qubits()
         raise ValueError("index out of range")
 
     def qubit_index_to_equivalence_group_key(self, index: int) -> int:
@@ -385,14 +436,28 @@
         if isinstance(indexed_gate, cirq.InterchangeableQubitsGate):
             gate_key = indexed_gate.qubit_index_to_equivalence_group_key(index_in_gate)
             for i in range(index_in_gate):
                 if gate_key == indexed_gate.qubit_index_to_equivalence_group_key(i):
                     return index - index_in_gate + i
         return index
 
+    def _is_parameterized_(self) -> bool:
+        return any(cirq.is_parameterized(gate) for gate in self.component_gates)
+
+    def _parameter_names_(self) -> Set[str]:
+        component_param_names = [set(cirq.parameter_names(gate)) for gate in self.component_gates]
+        return set.union(*component_param_names)
+
+    def _resolve_parameters_(
+        self, resolver: cirq.ParamResolver, recursive: bool
+    ) -> "ParallelGates":
+        return ParallelGates(
+            *(cirq.resolve_parameters(gate, resolver, recursive) for gate in self.component_gates)
+        )
+
     def _value_equality_values_(self) -> Tuple[cirq.Gate, ...]:
         return self.component_gates
 
     def _equal_up_to_global_phase_(self, other: Any, atol: float) -> Optional[bool]:
         if not isinstance(other, ParallelGates):
             return NotImplemented
 
@@ -458,34 +523,36 @@
                 wire_symbols_with_subscripts.append(
                     full_symbol.replace(base_symbol, base_symbol + index_str)
                 )
 
         return cirq.CircuitDiagramInfo(wire_symbols=wire_symbols_with_subscripts)
 
     def _json_dict_(self) -> Dict[str, Any]:
-        return cirq.protocols.obj_to_dict_helper(self, ["component_gates"])
+        return cirq.obj_to_dict_helper(self, ["component_gates"])
 
     @classmethod
     def _from_json_dict_(cls, component_gates: List[cirq.Gate], **kwargs: Any) -> "ParallelGates":
         return cls(*component_gates)
 
-    def __pow__(self, exponent: float) -> "ParallelGates":
+    def __pow__(self, exponent: cirq.TParamVal) -> "ParallelGates":
         exponentiated_gates = [gate**exponent for gate in self.component_gates]
         return ParallelGates(*exponentiated_gates)
 
     def __str__(self) -> str:
         component_gates_str = ", ".join(str(gate) for gate in self.component_gates)
         return f"ParallelGates({component_gates_str})"
 
     def __repr__(self) -> str:
         component_gates_repr = ", ".join(repr(gate) for gate in self.component_gates)
         return f"css.ParallelGates({component_gates_repr})"
 
 
-def parallel_gates_operation(*ops: cirq.Operation) -> cirq.Operation:
+def parallel_gates_operation(  # pylint: disable=missing-raises-doc
+    *ops: cirq.Operation,
+) -> cirq.Operation:
     """Given operations acting on disjoint qubits, constructs a single css.ParallelGates instance
     and applies it such that each operation's .gate is applied to its .qubits.
 
     Args:
         ops: operations to pack into a single ParallelGates operation
 
     Returns:
@@ -504,53 +571,49 @@
 
     return ParallelGates(*gates).on(*qubits)
 
 
 class RGate(cirq.PhasedXPowGate):
     """A single-qubit gate that rotates about an axis in the X-Y plane."""
 
-    def __init__(self, theta: float, phi: float) -> None:
-        """
-        Args:
-            phi (float): angle (in radians) defining the axis of rotation in the `X`-`Y` plane:
-            `cos(phi) X + sin(phi) Y` (i.e. `phi` radians from `X` to `Y`).
+    def __init__(self, theta: cirq.TParamVal, phi: cirq.TParamVal) -> None:
+        """Args:
+        phi: Angle (in radians) defining the axis of rotation in the `X`-`Y` plane:
+             `cos(phi) X + sin(phi) Y` (i.e. `phi` radians from `X` to `Y`).
 
-            theta (float): angle (in radians) by which to rotate.
+        theta: Angle (in radians) by which to rotate.
         """
-        super().__init__(exponent=theta / np.pi, phase_exponent=phi / np.pi, global_shift=-0.5)
+        super().__init__(
+            exponent=theta / _pi(theta), phase_exponent=phi / _pi(phi), global_shift=-0.5
+        )
 
     @property
-    def phi(self) -> float:
-        return self.phase_exponent * np.pi
+    def phi(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
+        return self.phase_exponent * _pi(self.phase_exponent)
 
     @property
-    def theta(self) -> float:
-        return self.exponent * np.pi
+    def theta(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
+        return self.exponent * _pi(self.exponent)
 
-    def __pow__(self, power: float) -> "RGate":
+    def __pow__(self, power: cirq.TParamVal) -> "RGate":
         return RGate(power * self.theta, self.phi)
 
     def _equal_up_to_global_phase_(self, other: Any, atol: float) -> Optional[bool]:
         """Implemented here because it isn't in cirq.PhasedXPowGate"""
         if not isinstance(other, cirq.PhasedXPowGate):
             return NotImplemented
 
-        # equal_up_to_global_phase(RGate(x, y), RGate(-x, y + pi)) should be True:
-        if cirq.all_near_zero_mod(
-            [self.exponent + other.exponent, self.phase_exponent - other.phase_exponent - 1],
-            period=2,
-            atol=atol,
-        ):
-            return True
-
-        return cirq.all_near_zero_mod(
-            [self.exponent - other.exponent, self.phase_exponent - other.phase_exponent],
-            period=2,
-            atol=atol,
-        )
+        if approx_eq_mod(self.exponent, other.exponent, 2, atol=atol):
+            return approx_eq_mod(self.phase_exponent, other.phase_exponent, 2, atol=atol)
+
+        # equal_up_to_global_phase(RGate(x, y), RGate(-x, y + pi)) is also True:
+        if approx_eq_mod(self.exponent, -other.exponent, 2, atol=atol):
+            return approx_eq_mod(self.phase_exponent, 1 + other.phase_exponent, 2, atol=atol)
+
+        return False
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
         theta_str = args.format_radians(self.theta)
         phi_str = args.format_radians(self.phi)
         gate_str = f"RGate({theta_str}, {phi_str})"
         return cirq.CircuitDiagramInfo(wire_symbols=(gate_str,))
 
@@ -565,46 +628,46 @@
     def __str__(self) -> str:
         return f"RGate({self.exponent}, {self.phase_exponent})"
 
     def __repr__(self) -> str:
         return f"css.RGate({self.theta}, {self.phi})"
 
     def _json_dict_(self) -> Dict[str, Any]:
-        return cirq.protocols.obj_to_dict_helper(self, ["theta", "phi"])
+        return cirq.obj_to_dict_helper(self, ["theta", "phi"])
 
 
 @cirq.value_equality(approximate=True)
 class ParallelRGate(cirq.ParallelGate, cirq.InterchangeableQubitsGate):
     """Wrapper class to define a ParallelGate of identical RGate gates."""
 
-    def __init__(self, theta: float, phi: float, num_copies: int) -> None:
+    def __init__(self, theta: cirq.TParamVal, phi: cirq.TParamVal, num_copies: int) -> None:
         super().__init__(css.RGate(theta, phi), num_copies)
         self._sub_gate: RGate
 
     @property
     def sub_gate(self) -> RGate:
         return self._sub_gate
 
     @property
-    def phase_exponent(self) -> float:
+    def phase_exponent(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
         return self.sub_gate.phase_exponent
 
     @property
-    def exponent(self) -> float:
+    def exponent(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
         return self.sub_gate.exponent
 
     @property
-    def phi(self) -> float:
+    def phi(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
         return self.sub_gate.phi
 
     @property
-    def theta(self) -> float:
+    def theta(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
         return self.sub_gate.theta
 
-    def __pow__(self, power: float) -> "ParallelRGate":
+    def __pow__(self, power: cirq.TParamVal) -> "ParallelRGate":
         return ParallelRGate(power * self.theta, self.phi, self.num_copies)
 
     def _equal_up_to_global_phase_(self, other: Any, atol: float) -> Optional[bool]:
         """Implemented here because it isn't in cirq.ParallelGate"""
         if not isinstance(other, cirq.ParallelGate):
             return NotImplemented
 
@@ -624,42 +687,42 @@
         gate_str = "gate_GR({0:half_turns},{1:half_turns})"
         qubits_str = ",".join([f"{{{idx + 2}}}" for idx in range(len(qubits))])
         return args.format(
             f"{gate_str} {qubits_str};\n", self.exponent, self.phase_exponent, *qubits
         )
 
     def __str__(self) -> str:
-        return f"RGate({self.phase_exponent}, {self.exponent}) x {self.num_copies}"
+        return f"RGate({self.exponent}, {self.phase_exponent}) x {self.num_copies}"
 
     def __repr__(self) -> str:
         return f"css.ParallelRGate({self.theta}, {self.phi}, {self.num_copies})"
 
     def _json_dict_(self) -> Dict[str, Any]:
-        return cirq.protocols.obj_to_dict_helper(self, ["theta", "phi", "num_copies"])
+        return cirq.obj_to_dict_helper(self, ["theta", "phi", "num_copies"])
 
 
 class IXGate(cirq.XPowGate):
     """Thin wrapper of Rx(-pi) to improve iToffoli circuit diagrams"""
 
     def __init__(self) -> None:
         super().__init__(exponent=1, global_shift=0.5)
 
     def _with_exponent(self, exponent: cirq.value.TParamVal) -> Union[cirq.Rx, "IXGate"]:
-        if np.isclose(exponent % 4, 1):
+        if approx_eq_mod(exponent, 1.0, 4):
             return IXGate()
-        return cirq.rx(-exponent * np.pi)
+        return cirq.rx(-exponent * _pi(exponent))
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
         return cirq.CircuitDiagramInfo(wire_symbols=("iX",))
 
     def __str__(self) -> str:
         return "IX"
 
     def __repr__(self) -> str:
-        return f"css.custom_gates.{str(self)}"
+        return f"css.ops.qubit_gates.{str(self)}"
 
     @classmethod
     def _from_json_dict_(cls, **kwargs: Any) -> "IXGate":
         return IXGate()
 
 
 CR = ZX = ZXPowGate()  # standard CR is a full turn of ZX, i.e. exponent = 1
@@ -669,28 +732,116 @@
 # iToffoli gate
 ICCX = IX.controlled(2, [1, 1])
 
 # Open-control iToffoli gate
 AQTICCX = AQTITOFFOLI = IX.controlled(2, [0, 0])
 
 
-def custom_resolver(cirq_type: str) -> Union[Type[cirq.Gate], None]:
-    if cirq_type == "ZZSwapGate":
-        return ZZSwapGate
-    if cirq_type == "Barrier":
-        return Barrier
-    if cirq_type == "ZXPowGate":
-        return ZXPowGate
-    if cirq_type == "AceCR":
-        return AceCR
-    if cirq_type == "ParallelGates":
-        return ParallelGates
-    if cirq_type == "MSGate":
-        return cirq.ops.MSGate
-    if cirq_type == "RGate":
-        return RGate
-    if cirq_type == "IXGate":
-        return IXGate
-    if cirq_type == "ParallelRGate":
-        return ParallelRGate
+@cirq.value_equality(approximate=True)
+class StrippedCZGate(cirq.Gate):
+    """The Stripped CZ Gate is the gate that is actually being performed by Hilbert,
+    which is just a regular CZ gate when the rz angle = 0, and is corrected into a CZ
+    gate by RZ gates afterwards if the rz angle is nonzero.
+    """
+
+    def __init__(self, rz_rads: cirq.TParamVal = 0) -> None:
+        """Args: rz_rads: RZ-rotation angle in radians"""
+        self._rz_rads = rz_rads
+
+    @property
+    def rz_rads(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
+        return self._rz_rads
+
+    def _num_qubits_(self) -> int:
+        return 2
+
+    def _unitary_(self) -> Optional[npt.NDArray[np.complex_]]:
+        if self._is_parameterized_():
+            return None
+        return np.diag(
+            [
+                1.0,
+                np.exp(1j * self.rz_rads),
+                np.exp(1j * self.rz_rads),
+                np.exp(1j * (2 * self.rz_rads - np.pi)),
+            ]
+        )
+
+    def _value_equality_values_(self) -> cirq.TParamVal:
+        if cirq.is_parameterized(self.rz_rads):
+            return self.rz_rads
+        return self.rz_rads % (2 * np.pi)
+
+    def _value_equality_approximate_values_(self) -> cirq.PeriodicValue:
+        return cirq.PeriodicValue(self.rz_rads, 2 * np.pi)
+
+    def __pow__(
+        self, exponent: cirq.TParamVal
+    ) -> Union["StrippedCZGate", cirq.IdentityGate, "ParallelGates", cirq.DiagonalGate]:
+        if exponent == 0:
+            return cirq.IdentityGate(2)
+
+        new_rz_rads = exponent * self.rz_rads
+        z_exp_gate = cirq.ZPowGate(exponent=new_rz_rads)
+        if exponent == int(exponent):
+            if exponent % 2 == 0:
+                return ParallelGates(z_exp_gate, z_exp_gate)
+            return StrippedCZGate(new_rz_rads)
+        phases = [
+            1,
+            np.exp(1j * new_rz_rads),
+            np.exp(1j * new_rz_rads),
+            np.exp(1j * (2 * new_rz_rads - exponent * np.pi)),
+        ]
+        return cirq.DiagonalGate(phases)
+
+    def __str__(self) -> str:
+        return f"StrippedCZGate({self.rz_rads})"
+
+    def __repr__(self) -> str:
+        return f"css.StrippedCZGate({self.rz_rads!r})"
+
+    def _decompose_(self, qubits: Tuple[cirq.Qid, cirq.Qid]) -> Iterator[cirq.Operation]:
+        yield cirq.rz(self.rz_rads).on(qubits[0])
+        yield cirq.rz(self.rz_rads).on(qubits[1])
+        yield cirq.CZ(*qubits)
+
+    def _resolve_parameters_(
+        self, resolver: cirq.ParamResolver, recursive: bool
+    ) -> "StrippedCZGate":
+        return StrippedCZGate(
+            cirq.resolve_parameters(self.rz_rads, resolver, recursive),
+        )
+
+    def _is_parameterized_(self) -> bool:
+        return cirq.is_parameterized(self.rz_rads)
+
+    def _parameter_names_(self) -> AbstractSet[str]:
+        return cirq.parameter_names(self.rz_rads)
+
+    def _has_unitary_(self) -> bool:
+        return not self._is_parameterized_()
+
+    def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
+        p = args.format_radians(self.rz_rads)
+        return cirq.CircuitDiagramInfo(wire_symbols=(f"@({p})", f"@({p})"))
+
+    def _json_dict_(self) -> Dict[str, Any]:
+        return cirq.obj_to_dict_helper(self, ["rz_rads"])
+
 
-    return None
+def custom_resolver(  # pylint: disable=missing-function-docstring
+    cirq_type: str,
+) -> Union[Type[cirq.Gate], None]:
+    type_to_gate_map: Dict[str, Type[cirq.Gate]] = {
+        "ZZSwapGate": ZZSwapGate,
+        "Barrier": Barrier,
+        "ZXPowGate": ZXPowGate,
+        "AceCR": AceCR,
+        "ParallelGates": ParallelGates,
+        "MSGate": cirq.ops.MSGate,
+        "RGate": RGate,
+        "IXGate": IXGate,
+        "ParallelRGate": ParallelRGate,
+        "StrippedCZGate": StrippedCZGate,
+    }
+    return type_to_gate_map.get(cirq_type)
```

## Comparing `cirq_superstaq-0.3.9.dist-info/METADATA` & `cirq_superstaq-0.4.0.dist-info/METADATA`

 * *Files 12% similar despite different names*

```diff
@@ -1,48 +1,48 @@
 Metadata-Version: 2.1
 Name: cirq-superstaq
-Version: 0.3.9
-Summary: The Cirq module that provides tools and access to SuperstaQ
-Home-page: https://github.com/SupertechLabs/cirq-superstaq
-Author: Super.tech
-Author-email: pranav@super.tech
+Version: 0.4.0
+Summary: The Cirq module that provides tools and access to Superstaq
+Home-page: https://github.com/Infleqtion/client-superstaq
+Author: Superstaq development team
+Author-email: superstaq@infleqtion.com
 License: Apache 2
 Platform: UNKNOWN
-Requires-Python: >=3.7.0
+Requires-Python: >=3.8.0
 Description-Content-Type: text/markdown
-Requires-Dist: cirq (>=0.14.0)
-Requires-Dist: general-superstaq (~=0.3.4)
+Requires-Dist: cirq (>=1.0.0)
+Requires-Dist: general-superstaq (~=0.4.0)
 Requires-Dist: qubovert (>=1.2.3)
-Requires-Dist: sympy (<1.10)
 Provides-Extra: dev
-Requires-Dist: general-superstaq[dev] (~=0.3.4) ; extra == 'dev'
-Requires-Dist: qiskit-terra (~=0.20.2) ; extra == 'dev'
+Requires-Dist: general-superstaq[dev] (~=0.4.0) ; extra == 'dev'
+Requires-Dist: qiskit-terra (~=0.24.0) ; extra == 'dev'
+Requires-Dist: symengine (<0.10.0) ; extra == 'dev'
 Provides-Extra: examples
 Requires-Dist: notebook (~=6.4.12) ; extra == 'examples'
-Requires-Dist: pulser (~=0.7.0) ; extra == 'examples'
-Requires-Dist: qiskit (<0.37.0,>=0.35.0) ; extra == 'examples'
+Requires-Dist: qiskit-terra (~=0.24.0) ; extra == 'examples'
+Requires-Dist: symengine (<0.10.0) ; extra == 'examples'
 
-This package is used to access SuperstaQ via a Web API through [Cirq](https://github.com/quantumlib/Cirq).
+![cirq-superstaq's default workflow](https://github.com/Infleqtion/client-superstaq/actions/workflows/ci.yml/badge.svg)
+
+This package is used to access Superstaq via a Web API through [Cirq](https://github.com/quantumlib/Cirq).
 Cirq programmers can take advantage of the applications, pulse level optimizations, and write-once-target-all
-features of SuperstaQ with this package.
+features of Superstaq with this package.
 
 
-Please note that Python version `3.7` or higher is required. cirq-superstaq and all of its
+Please note that Python version `3.8` or higher is required. `cirq-superstaq` and all of its
 dependencies can be installed via:
 
 ```
 python3 -m venv venv_cirq_superstaq
 source venv_cirq_superstaq/bin/activate
 pip install cirq-superstaq
 
 # Run the following to install dev requirements (required if you intend to run checks locally)
 pip install .[dev]
 
-# Run the following to install neutral atom device dependencies.
-pip install -r neutral-atom-requirements.txt
 ```
 
 ### Creating and submitting a circuit through cirq-superstaq
 ```python
 import cirq
 import cirq_superstaq as css
 
@@ -52,14 +52,14 @@
 circuit = cirq.Circuit(cirq.H(q0), cirq.CNOT(q0, q1), cirq.measure(q0))
 
 service = css.Service(
     api_key="""Insert superstaq token that you received from https://superstaq.super.tech""",
     verbose=True,
 )
 
-# Submitting a circuit to "ibmq_qasm_simulator". Providing the "dry-run" method parameter instructs SuperstaQ to simulate the circuit, and is available to free trial users.
+# Submitting a circuit to "ibmq_qasm_simulator". Providing the "dry-run" method parameter instructs Superstaq to simulate the circuit, and is available to free trial users.
 job = service.create_job(circuit=circuit, repetitions=1, target="ibmq_qasm_simulator", method="dry-run")
 print("This is the job that's created ", job.status())
 print(job.counts())
 ```
```

## Comparing `cirq_superstaq-0.3.9.dist-info/RECORD` & `cirq_superstaq-0.4.0.dist-info/RECORD`

 * *Files 19% similar despite different names*

```diff
@@ -1,21 +1,23 @@
-cirq_superstaq/__init__.py,sha256=l1RpiCU5oOEL0FYasHcPJ77GQgd_Lb7Uouta5MDi8QE,1563
-cirq_superstaq/_version.py,sha256=xmkmdvq15kb61xdtCoa1YARnvHBnUgI-0GWIJYvHNeA,22
-cirq_superstaq/_version_test.py,sha256=FakRHPogGzthAy84Q-pe6jDLmjnyJx00ZkJOajzhahg,243
-cirq_superstaq/compiler_output.py,sha256=Su1mCs_6u1-ZojR6-EQgQiVqq_-vSvI1cnO9PzYtuEM,8383
-cirq_superstaq/compiler_output_test.py,sha256=W-jbISUZoYpWucpxR5zd3d1_nA2UBT6NMooyaRjCxpc,8422
-cirq_superstaq/custom_gates.py,sha256=L0WSCP-osRoM3e8piWDSf11qCDs7aWOTtZc_tAnEZjQ,25883
-cirq_superstaq/custom_gates_test.py,sha256=M9nXejage8qfsEGzTnatF9flh0sD1ejti4O8tl3Qh08,27032
-cirq_superstaq/daily_integration_test.py,sha256=fVzGKwEikNNyu6RovlBrl0vuI2ZeXyIBIAdRRPIgtaU,8420
-cirq_superstaq/job.py,sha256=zTgAg1kA95-dxynhrKWWmcY04L27_wxcoXK_RvI6Ldk,6463
-cirq_superstaq/job_test.py,sha256=H_2OHI4HF4kMPw9lYlGhBTBYLhL3gRtk43GcBjiRuEk,6734
+cirq_superstaq/__init__.py,sha256=3k89ggq-UI0faFssu36Dy2uKUIgEYnOW7M9IKlPuGJ4,2495
+cirq_superstaq/_version.py,sha256=42STGor_9nKYXumfeV5tiyD_M8VdcddX7CEexmibPBk,22
+cirq_superstaq/_version_test.py,sha256=0cQRR-VB1raAtsIFR9JganIC2qJXbmSDQ-OAr5F8alg,288
+cirq_superstaq/compiler_output.py,sha256=9CqLbna8So1fopvRnZRiWDvyjtb0TXZmNszWvpVeP-k,11725
+cirq_superstaq/compiler_output_test.py,sha256=8N9m6h0m2hv9o_oLIf8nBuPJUmTaTLgzR-_XMDMkqaY,13819
+cirq_superstaq/daily_integration_test.py,sha256=DAWmO7sGPKmyDnOFiIFWk5er5J52qTd0AinvzZhSBt4,9741
+cirq_superstaq/job.py,sha256=XyTsLr9E-pNnkHQTFsLrxuD0INfLtulXPuc80lYP2Jk,6815
+cirq_superstaq/job_test.py,sha256=iDSdFLfw1iHWE7hDyUqNL9AA8g6r92G07xjhTRYHOzw,6680
 cirq_superstaq/py.typed,sha256=2DnKRKK8fmvD_m6TmNUqVJZBNb2xKGaCjcHkkVpRsMc,68
-cirq_superstaq/sampler.py,sha256=QqurJNRTR60m8okDZI98GBjdbAGcxSaJ-wsAIRJyhhc,3054
-cirq_superstaq/serialization.py,sha256=2fYeE7hzqI4ln6LtxwIqOrSQOB5W1DvjI0psV9OLa5s,1301
-cirq_superstaq/serialization_test.py,sha256=X7mul2pyjqhlRnIQ7FknZmj6MjEAeDl9sup_ZDzlVDo,1535
-cirq_superstaq/service.py,sha256=tXHbJO5q2tfiztEkRrjl3SIFF_mIH1-LFOCQcyOYa3c,19694
-cirq_superstaq/service_test.py,sha256=x1Kgm6-iE4uv2DQrwiT0QnQn94Fd2AUpWwXcP07USMo,16561
-cirq_superstaq-0.3.9.dist-info/LICENSE,sha256=tAkwu8-AdEyGxGoSvJ2gVmQdcicWw3j1ZZueVV74M-E,11357
-cirq_superstaq-0.3.9.dist-info/METADATA,sha256=v0uRUpxUBpUD5exXVWqGcg9pVvMLlAhm_YAm0S9vqTM,2271
-cirq_superstaq-0.3.9.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-cirq_superstaq-0.3.9.dist-info/top_level.txt,sha256=x5zxwcSj8lK-JlK4DsVnr_uEeiPoaZG2wokltTJQrJY,15
-cirq_superstaq-0.3.9.dist-info/RECORD,,
+cirq_superstaq/sampler.py,sha256=EsP6psotyN6t-QIQJwcPm5XQAIt1ZH5QRhRVulkmlHY,3087
+cirq_superstaq/serialization.py,sha256=rdd4cwqOGmvp7X8WKNUPpd8OD2Rr6rI_kAa2PX4lDW0,1398
+cirq_superstaq/serialization_test.py,sha256=SuJYOvuizF75nEi6PD6OdZhKwAc5T1K7u3fi15RFFts,1580
+cirq_superstaq/service.py,sha256=wTkw7mYM1jWN-ob1gCH2BpcBMFghBWkz19FDxzV5xyw,28103
+cirq_superstaq/service_test.py,sha256=gty5KctoGCj0c1S5GKryJ6NgcWR_6vx5lIaZZJb3nAQ,23104
+cirq_superstaq/ops/__init__.py,sha256=CsW8WwyPL4jSfiUG3CrukZW-6YR7uOJvTVxiO5e4uiU,1297
+cirq_superstaq/ops/qubit_gates.py,sha256=9rVqcBJg-9ZCMaQiQJpZe3ES--nsgLfVYdTdzNNMeZk,31937
+cirq_superstaq/ops/qubit_gates_test.py,sha256=_G_RQ_ImXnUxMZ47QTz1X-xhqsgVOb-Z9Ulr-GPrN60,38554
+cirq_superstaq/ops/qudit_gates.py,sha256=htPb2_MiVuDkvKgzp2isNMrhLScO0VgcK5SFmRZqMnc,19196
+cirq_superstaq/ops/qudit_gates_test.py,sha256=OaGNeEpAyBdKTJQTK9e-nNVvndNAB0Dwa9NewzbfDYU,16965
+cirq_superstaq-0.4.0.dist-info/METADATA,sha256=azvhia6AByjpb7DtAm64Sr-K1oJlo_6uVBPBuLSojEk,2329
+cirq_superstaq-0.4.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+cirq_superstaq-0.4.0.dist-info/top_level.txt,sha256=x5zxwcSj8lK-JlK4DsVnr_uEeiPoaZG2wokltTJQrJY,15
+cirq_superstaq-0.4.0.dist-info/RECORD,,
```

