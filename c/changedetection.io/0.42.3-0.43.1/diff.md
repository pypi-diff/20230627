# Comparing `tmp/changedetection.io-0.42.3-py3-none-any.whl.zip` & `tmp/changedetection.io-0.43.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,37 +1,43 @@
-Zip file size: 606859 bytes, number of entries: 182
--rwxrwxr-x  2.0 unx     1609 b- defN 23-Jun-12 13:31 changedetection.io-0.42.3.data/scripts/changedetection.py
--rw-rw-r--  2.0 unx    70346 b- defN 23-Jun-12 13:28 changedetectionio/__init__.py
+Zip file size: 618757 bytes, number of entries: 190
+-rwxrwxr-x  2.0 unx     1609 b- defN 23-Jun-27 16:30 changedetection.io-0.43.1.data/scripts/changedetection.py
+-rw-rw-r--  2.0 unx    71367 b- defN 23-Jun-27 16:28 changedetectionio/__init__.py
 -rw-rw-r--  2.0 unx      519 b- defN 23-Mar-23 07:51 changedetectionio/apprise_asset.py
 -rw-rw-r--  2.0 unx     5056 b- defN 23-Apr-14 07:50 changedetectionio/changedetection.py
--rw-rw-r--  2.0 unx    31711 b- defN 23-May-29 15:21 changedetectionio/content_fetcher.py
+-rw-rw-r--  2.0 unx    31711 b- defN 23-Jun-19 08:09 changedetectionio/content_fetcher.py
 -rw-rw-r--  2.0 unx     2890 b- defN 23-Mar-20 19:17 changedetectionio/diff.py
--rw-rw-r--  2.0 unx    22301 b- defN 23-Jun-12 13:28 changedetectionio/forms.py
--rw-rw-r--  2.0 unx    11235 b- defN 23-May-31 08:07 changedetectionio/html_tools.py
--rw-rw-r--  2.0 unx     4491 b- defN 23-Jun-12 13:28 changedetectionio/importer.py
--rw-rw-r--  2.0 unx     9741 b- defN 23-Jun-12 13:28 changedetectionio/notification.py
+-rw-rw-r--  2.0 unx    23129 b- defN 23-Jun-23 13:22 changedetectionio/forms.py
+-rw-rw-r--  2.0 unx    11235 b- defN 23-Jun-23 13:22 changedetectionio/html_tools.py
+-rw-rw-r--  2.0 unx     4544 b- defN 23-Jun-27 15:08 changedetectionio/importer.py
+-rw-rw-r--  2.0 unx     9919 b- defN 23-Jun-21 08:57 changedetectionio/notification.py
 -rw-rw-r--  2.0 unx      280 b- defN 23-Feb-03 22:08 changedetectionio/queuedWatchMetaData.py
--rw-rw-r--  2.0 unx    29091 b- defN 23-Jun-12 13:28 changedetectionio/store.py
--rw-rw-r--  2.0 unx    22972 b- defN 23-Jun-12 13:28 changedetectionio/update_worker.py
+-rw-rw-r--  2.0 unx    32711 b- defN 23-Jun-27 16:28 changedetectionio/store.py
+-rw-rw-r--  2.0 unx    24023 b- defN 23-Jun-27 16:28 changedetectionio/update_worker.py
 -rw-rw-r--  2.0 unx        0 b- defN 22-Dec-04 13:25 changedetectionio/api/__init__.py
 -rw-rw-r--  2.0 unx     3907 b- defN 23-Feb-03 22:08 changedetectionio/api/api_schema.py
--rw-rw-r--  2.0 unx    14662 b- defN 23-Jun-12 13:28 changedetectionio/api/api_v1.py
+-rw-rw-r--  2.0 unx    15052 b- defN 23-Jun-27 15:08 changedetectionio/api/api_v1.py
 -rw-rw-r--  2.0 unx      966 b- defN 23-Jan-10 13:32 changedetectionio/api/auth.py
 -rw-rw-r--  2.0 unx        0 b- defN 22-Dec-14 11:44 changedetectionio/blueprint/__init__.py
 -rw-rw-r--  2.0 unx     9313 b- defN 23-May-15 08:35 changedetectionio/blueprint/browser_steps/__init__.py
 -rw-rw-r--  2.0 unx    12037 b- defN 23-May-18 14:27 changedetectionio/blueprint/browser_steps/browser_steps.py
 -rw-rw-r--  2.0 unx      824 b- defN 22-Dec-14 11:44 changedetectionio/blueprint/browser_steps/nonContext.py
 -rw-rw-r--  2.0 unx     1229 b- defN 23-Mar-12 16:22 changedetectionio/blueprint/price_data_follower/__init__.py
--rw-rw-r--  2.0 unx     2856 b- defN 23-Jun-12 13:28 changedetectionio/model/App.py
--rw-rw-r--  2.0 unx    20125 b- defN 23-Jun-12 13:28 changedetectionio/model/Watch.py
+-rw-rw-r--  2.0 unx      265 b- defN 23-Jun-21 08:57 changedetectionio/blueprint/tags/README.md
+-rw-rw-r--  2.0 unx     5551 b- defN 23-Jun-27 15:08 changedetectionio/blueprint/tags/__init__.py
+-rw-rw-r--  2.0 unx      397 b- defN 23-Jun-21 08:57 changedetectionio/blueprint/tags/form.py
+-rw-rw-r--  2.0 unx     7541 b- defN 23-Jun-21 08:57 changedetectionio/blueprint/tags/templates/edit-tag.html
+-rw-rw-r--  2.0 unx     2930 b- defN 23-Jun-23 07:11 changedetectionio/blueprint/tags/templates/groups-overview.html
+-rw-rw-r--  2.0 unx     2921 b- defN 23-Jun-21 08:57 changedetectionio/model/App.py
+-rw-rw-r--  2.0 unx      406 b- defN 23-Jun-21 08:57 changedetectionio/model/Tag.py
+-rw-rw-r--  2.0 unx    18593 b- defN 23-Jun-21 08:57 changedetectionio/model/Watch.py
 -rw-rw-r--  2.0 unx        0 b- defN 22-Dec-04 13:25 changedetectionio/model/__init__.py
 -rw-rw-r--  2.0 unx      461 b- defN 23-Mar-18 19:35 changedetectionio/processors/README.md
 -rw-rw-r--  2.0 unx      773 b- defN 23-Apr-08 16:27 changedetectionio/processors/__init__.py
--rw-rw-r--  2.0 unx     5731 b- defN 23-Jun-12 13:28 changedetectionio/processors/restock_diff.py
--rw-rw-r--  2.0 unx    20285 b- defN 23-Jun-12 13:28 changedetectionio/processors/text_json_diff.py
+-rw-rw-r--  2.0 unx     5718 b- defN 23-Jun-21 08:57 changedetectionio/processors/restock_diff.py
+-rw-rw-r--  2.0 unx    20836 b- defN 23-Jun-21 08:57 changedetectionio/processors/text_json_diff.py
 -rw-rw-r--  2.0 unx     6602 b- defN 23-May-28 14:39 changedetectionio/res/puppeteer_fetch.js
 -rw-rw-r--  2.0 unx     3247 b- defN 23-May-27 11:31 changedetectionio/res/stock-not-in-stock.js
 -rw-rw-r--  2.0 unx     8772 b- defN 23-May-22 12:30 changedetectionio/res/xpath_element_scraper.js
 -rw-rw-r--  2.0 unx    33807 b- defN 22-Dec-14 11:44 changedetectionio/static/favicons/android-chrome-192x192.png
 -rw-rw-r--  2.0 unx    41104 b- defN 22-Dec-14 11:44 changedetectionio/static/favicons/android-chrome-256x256.png
 -rw-rw-r--  2.0 unx    31932 b- defN 22-Dec-14 11:44 changedetectionio/static/favicons/apple-touch-icon.png
 -rw-rw-r--  2.0 unx      254 b- defN 22-Dec-14 11:44 changedetectionio/static/favicons/browserconfig.xml
@@ -64,121 +70,123 @@
 -rw-rw-r--  2.0 unx    17458 b- defN 22-Dec-14 11:44 changedetectionio/static/js/diff.min.js
 -rw-rw-r--  2.0 unx     1061 b- defN 22-Dec-04 13:25 changedetectionio/static/js/global-settings.js
 -rw-rw-r--  2.0 unx    89501 b- defN 22-Dec-04 13:25 changedetectionio/static/js/jquery-3.6.0.min.js
 -rw-rw-r--  2.0 unx     1805 b- defN 22-Dec-04 13:25 changedetectionio/static/js/limit.js
 -rw-rw-r--  2.0 unx     1525 b- defN 23-Apr-29 14:32 changedetectionio/static/js/notifications.js
 -rw-rw-r--  2.0 unx      861 b- defN 22-Dec-14 11:44 changedetectionio/static/js/stepper.js
 -rw-rw-r--  2.0 unx     1424 b- defN 23-May-07 11:23 changedetectionio/static/js/tabs.js
--rw-rw-r--  2.0 unx     1420 b- defN 23-May-18 16:56 changedetectionio/static/js/toggle-theme.js
+-rw-rw-r--  2.0 unx     1280 b- defN 23-Jun-19 11:18 changedetectionio/static/js/toggle-theme.js
 -rw-rw-r--  2.0 unx     9649 b- defN 23-May-18 14:27 changedetectionio/static/js/visual-selector.js
--rw-rw-r--  2.0 unx     1205 b- defN 23-Apr-29 18:14 changedetectionio/static/js/watch-overview.js
+-rw-rw-r--  2.0 unx     1666 b- defN 23-Jun-21 12:03 changedetectionio/static/js/watch-overview.js
 -rw-rw-r--  2.0 unx     1711 b- defN 23-Feb-03 22:08 changedetectionio/static/js/watch-settings.js
 -rw-rw-r--  2.0 unx       32 b- defN 23-Feb-03 22:08 changedetectionio/static/styles/.dockerignore
 -rw-rw-r--  2.0 unx       32 b- defN 22-Dec-04 13:25 changedetectionio/static/styles/.gitignore
 -rw-rw-r--  2.0 unx     7543 b- defN 23-May-18 14:40 changedetectionio/static/styles/diff.css
 -rw-rw-r--  2.0 unx   167549 b- defN 23-May-18 14:40 changedetectionio/static/styles/package-lock.json
 -rw-rw-r--  2.0 unx      339 b- defN 22-Dec-14 11:44 changedetectionio/static/styles/package.json
 -rw-rw-r--  2.0 unx    16789 b- defN 22-Dec-04 13:25 changedetectionio/static/styles/pure-min.css
--rw-rw-r--  2.0 unx    32178 b- defN 23-May-18 16:56 changedetectionio/static/styles/styles.css
+-rw-rw-r--  2.0 unx    32222 b- defN 23-Jun-19 11:18 changedetectionio/static/styles/styles.css
 -rw-rw-r--  2.0 unx     1590 b- defN 22-Dec-14 11:44 changedetectionio/static/styles/scss/diff.scss
--rw-rw-r--  2.0 unx    20984 b- defN 23-May-18 16:56 changedetectionio/static/styles/scss/styles.scss
+-rw-rw-r--  2.0 unx    20984 b- defN 23-Jun-19 14:53 changedetectionio/static/styles/scss/styles.scss
 -rw-rw-r--  2.0 unx      464 b- defN 22-Dec-14 11:44 changedetectionio/static/styles/scss/parts/_arrows.scss
 -rw-rw-r--  2.0 unx     1462 b- defN 22-Dec-14 11:44 changedetectionio/static/styles/scss/parts/_browser-steps.scss
 -rw-rw-r--  2.0 unx      242 b- defN 23-Feb-03 22:08 changedetectionio/static/styles/scss/parts/_extra_proxies.scss
 -rw-rw-r--  2.0 unx      504 b- defN 23-Apr-29 17:42 changedetectionio/static/styles/scss/parts/_pagination.scss
 -rw-rw-r--  2.0 unx      966 b- defN 22-Dec-14 11:44 changedetectionio/static/styles/scss/parts/_spinners.scss
 -rw-rw-r--  2.0 unx     5845 b- defN 22-Dec-14 11:44 changedetectionio/static/styles/scss/parts/_variables.scss
 -rw-rw-r--  2.0 unx     9205 b- defN 23-May-18 14:27 changedetectionio/templates/_common_fields.jinja
 -rw-rw-r--  2.0 unx     1525 b- defN 22-Dec-04 13:25 changedetectionio/templates/_helpers.jinja
--rw-rw-r--  2.0 unx     7553 b- defN 23-Jun-12 13:28 changedetectionio/templates/base.html
+-rw-rw-r--  2.0 unx     7605 b- defN 23-Jun-21 08:57 changedetectionio/templates/base.html
 -rw-rw-r--  2.0 unx     1478 b- defN 23-Apr-30 08:02 changedetectionio/templates/clear_all_history.html
 -rw-rw-r--  2.0 unx     7322 b- defN 23-Apr-30 08:47 changedetectionio/templates/diff.html
--rw-rw-r--  2.0 unx    30025 b- defN 23-May-31 08:07 changedetectionio/templates/edit.html
+-rw-rw-r--  2.0 unx    30026 b- defN 23-Jun-21 08:57 changedetectionio/templates/edit.html
 -rw-rw-r--  2.0 unx     4270 b- defN 23-Jun-09 08:08 changedetectionio/templates/import.html
 -rw-rw-r--  2.0 unx      857 b- defN 23-Apr-30 08:02 changedetectionio/templates/login.html
 -rw-rw-r--  2.0 unx      482 b- defN 22-Dec-04 13:25 changedetectionio/templates/notification-log.html
 -rw-rw-r--  2.0 unx     2955 b- defN 23-Apr-30 08:47 changedetectionio/templates/preview.html
 -rw-rw-r--  2.0 unx    13385 b- defN 23-May-25 14:46 changedetectionio/templates/settings.html
--rw-rw-r--  2.0 unx    13764 b- defN 23-Jun-12 13:28 changedetectionio/templates/watch-overview.html
+-rw-rw-r--  2.0 unx    14103 b- defN 23-Jun-21 08:57 changedetectionio/templates/watch-overview.html
 -rw-rw-r--  2.0 unx     1602 b- defN 22-Dec-14 11:44 changedetectionio/templates/svgs/dark-mode-toggle-icon.svg
 -rw-rw-r--  2.0 unx      749 b- defN 22-Dec-14 11:44 changedetectionio/templates/svgs/github.svg
 -rw-rw-r--  2.0 unx     2806 b- defN 22-Dec-14 11:44 changedetectionio/templates/svgs/light-mode-toggle-icon.svg
 -rw-rw-r--  2.0 unx     1605 b- defN 23-May-18 16:56 changedetectionio/templates/svgs/search-icon.svg
 -rw-rw-r--  2.0 unx       26 b- defN 22-Dec-04 13:25 changedetectionio/tests/__init__.py
--rw-rw-r--  2.0 unx     1703 b- defN 23-May-25 13:03 changedetectionio/tests/conftest.py
+-rw-rw-r--  2.0 unx     1703 b- defN 23-Jun-27 14:05 changedetectionio/tests/conftest.py
 -rw-rw-r--  2.0 unx     7408 b- defN 23-Feb-03 22:08 changedetectionio/tests/test.pdf
--rw-rw-r--  2.0 unx     5455 b- defN 23-Jun-12 13:28 changedetectionio/tests/test_access_control.py
--rw-rw-r--  2.0 unx     6089 b- defN 23-Jun-12 13:28 changedetectionio/tests/test_add_replace_remove_filter.py
--rw-rw-r--  2.0 unx    10415 b- defN 23-Jun-12 13:28 changedetectionio/tests/test_api.py
--rw-rw-r--  2.0 unx     1005 b- defN 22-Dec-14 11:44 changedetectionio/tests/test_auth.py
--rw-rw-r--  2.0 unx     4737 b- defN 23-Mar-12 16:22 changedetectionio/tests/test_automatic_follow_ldjson_price.py
--rw-rw-r--  2.0 unx     4977 b- defN 23-Mar-12 16:22 changedetectionio/tests/test_backend.py
--rw-rw-r--  2.0 unx     1353 b- defN 22-Dec-23 09:45 changedetectionio/tests/test_backup.py
--rw-rw-r--  2.0 unx     4011 b- defN 23-Mar-20 19:17 changedetectionio/tests/test_block_while_text_present.py
+-rw-rw-r--  2.0 unx     5742 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_access_control.py
+-rw-rw-r--  2.0 unx     6011 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_add_replace_remove_filter.py
+-rw-rw-r--  2.0 unx    10628 b- defN 23-Jun-27 15:08 changedetectionio/tests/test_api.py
+-rw-rw-r--  2.0 unx     1006 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_auth.py
+-rw-rw-r--  2.0 unx     4737 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_automatic_follow_ldjson_price.py
+-rw-rw-r--  2.0 unx     4977 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_backend.py
+-rw-rw-r--  2.0 unx     1353 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_backup.py
+-rw-rw-r--  2.0 unx     3936 b- defN 23-Jun-21 08:57 changedetectionio/tests/test_block_while_text_present.py
 -rw-rw-r--  2.0 unx      605 b- defN 22-Dec-04 13:25 changedetectionio/tests/test_clone.py
--rw-rw-r--  2.0 unx     5236 b- defN 23-Mar-12 16:22 changedetectionio/tests/test_css_selector.py
--rw-rw-r--  2.0 unx     4037 b- defN 23-Mar-17 22:55 changedetectionio/tests/test_element_removal.py
--rw-rw-r--  2.0 unx     2220 b- defN 22-Dec-14 11:44 changedetectionio/tests/test_encoding.py
--rw-rw-r--  2.0 unx     4211 b- defN 23-Apr-06 14:11 changedetectionio/tests/test_errorhandling.py
--rw-rw-r--  2.0 unx     2152 b- defN 22-Dec-14 11:44 changedetectionio/tests/test_extract_csv.py
--rw-rw-r--  2.0 unx     5402 b- defN 23-Mar-12 16:22 changedetectionio/tests/test_extract_regex.py
--rw-rw-r--  2.0 unx     4259 b- defN 23-Mar-12 16:22 changedetectionio/tests/test_filter_exist_changes.py
--rw-rw-r--  2.0 unx     5428 b- defN 23-Jun-12 13:28 changedetectionio/tests/test_filter_failure_notification.py
+-rw-rw-r--  2.0 unx     5238 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_css_selector.py
+-rw-rw-r--  2.0 unx     4038 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_element_removal.py
+-rw-rw-r--  2.0 unx     2220 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_encoding.py
+-rw-rw-r--  2.0 unx     4211 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_errorhandling.py
+-rw-rw-r--  2.0 unx     2152 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_extract_csv.py
+-rw-rw-r--  2.0 unx     5404 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_extract_regex.py
+-rw-rw-r--  2.0 unx     4261 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_filter_exist_changes.py
+-rw-rw-r--  2.0 unx     6274 b- defN 23-Jun-21 08:57 changedetectionio/tests/test_filter_failure_notification.py
+-rw-rw-r--  2.0 unx    11163 b- defN 23-Jun-27 15:08 changedetectionio/tests/test_group.py
 -rw-rw-r--  2.0 unx     3290 b- defN 23-Feb-11 16:04 changedetectionio/tests/test_history_consistency.py
 -rw-rw-r--  2.0 unx     1276 b- defN 23-Mar-12 16:22 changedetectionio/tests/test_html_to_text.py
 -rw-rw-r--  2.0 unx      892 b- defN 23-Mar-18 19:35 changedetectionio/tests/test_ignore_regex_text.py
--rw-rw-r--  2.0 unx     7556 b- defN 23-Mar-19 19:20 changedetectionio/tests/test_ignore_text.py
--rw-rw-r--  2.0 unx     3735 b- defN 23-Mar-12 16:22 changedetectionio/tests/test_ignorehyperlinks.py
--rw-rw-r--  2.0 unx     3624 b- defN 23-Mar-12 16:22 changedetectionio/tests/test_ignorestatuscode.py
--rw-rw-r--  2.0 unx     2478 b- defN 23-Mar-12 16:22 changedetectionio/tests/test_ignorewhitespace.py
--rw-rw-r--  2.0 unx     3918 b- defN 22-Dec-14 12:29 changedetectionio/tests/test_import.py
--rw-rw-r--  2.0 unx     1076 b- defN 22-Dec-04 13:25 changedetectionio/tests/test_jinja2.py
--rw-rw-r--  2.0 unx    16495 b- defN 23-May-31 08:07 changedetectionio/tests/test_jsonpath_jq_selector.py
--rw-rw-r--  2.0 unx     2892 b- defN 22-Dec-04 13:25 changedetectionio/tests/test_nonrenderable_pages.py
--rw-rw-r--  2.0 unx    13120 b- defN 23-Jun-12 13:28 changedetectionio/tests/test_notification.py
--rw-rw-r--  2.0 unx     1954 b- defN 23-Feb-11 16:04 changedetectionio/tests/test_notification_errors.py
--rw-rw-r--  2.0 unx     1022 b- defN 22-Dec-04 13:25 changedetectionio/tests/test_obfuscations.py
--rw-rw-r--  2.0 unx     1233 b- defN 23-Feb-03 22:08 changedetectionio/tests/test_pdf.py
--rw-rw-r--  2.0 unx    10121 b- defN 23-Jun-09 22:17 changedetectionio/tests/test_request.py
--rw-rw-r--  2.0 unx     1121 b- defN 23-Feb-03 22:08 changedetectionio/tests/test_rss.py
--rw-rw-r--  2.0 unx     1951 b- defN 23-Feb-03 22:08 changedetectionio/tests/test_security.py
--rw-rw-r--  2.0 unx     2318 b- defN 22-Dec-14 11:44 changedetectionio/tests/test_share_watch.py
--rw-rw-r--  2.0 unx     2637 b- defN 23-Feb-03 22:08 changedetectionio/tests/test_source.py
--rw-rw-r--  2.0 unx     4115 b- defN 23-Mar-12 16:22 changedetectionio/tests/test_trigger.py
--rw-rw-r--  2.0 unx     2390 b- defN 23-Mar-12 16:22 changedetectionio/tests/test_trigger_regex.py
--rw-rw-r--  2.0 unx     2486 b- defN 23-Mar-12 16:22 changedetectionio/tests/test_trigger_regex_with_filter.py
--rw-rw-r--  2.0 unx     2852 b- defN 23-Mar-20 19:17 changedetectionio/tests/test_unique_lines.py
--rw-rw-r--  2.0 unx     4528 b- defN 22-Dec-14 11:44 changedetectionio/tests/test_watch_fields_storage.py
--rw-rw-r--  2.0 unx     9442 b- defN 23-Mar-12 16:22 changedetectionio/tests/test_xpath_selector.py
--rw-rw-r--  2.0 unx     6255 b- defN 23-May-29 15:21 changedetectionio/tests/util.py
+-rw-rw-r--  2.0 unx     7408 b- defN 23-Jun-21 08:57 changedetectionio/tests/test_ignore_text.py
+-rw-rw-r--  2.0 unx     3735 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_ignorehyperlinks.py
+-rw-rw-r--  2.0 unx     3550 b- defN 23-Jun-21 08:57 changedetectionio/tests/test_ignorestatuscode.py
+-rw-rw-r--  2.0 unx     2478 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_ignorewhitespace.py
+-rw-rw-r--  2.0 unx     3935 b- defN 23-Jun-27 15:08 changedetectionio/tests/test_import.py
+-rw-rw-r--  2.0 unx     1077 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_jinja2.py
+-rw-rw-r--  2.0 unx    16680 b- defN 23-Jun-21 08:57 changedetectionio/tests/test_jsonpath_jq_selector.py
+-rw-rw-r--  2.0 unx     2892 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_nonrenderable_pages.py
+-rw-rw-r--  2.0 unx    13236 b- defN 23-Jun-27 16:28 changedetectionio/tests/test_notification.py
+-rw-rw-r--  2.0 unx     1956 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_notification_errors.py
+-rw-rw-r--  2.0 unx     1022 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_obfuscations.py
+-rw-rw-r--  2.0 unx     1233 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_pdf.py
+-rw-rw-r--  2.0 unx    10254 b- defN 23-Jun-21 08:57 changedetectionio/tests/test_request.py
+-rw-rw-r--  2.0 unx     1121 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_rss.py
+-rw-rw-r--  2.0 unx     2406 b- defN 23-Jun-21 08:57 changedetectionio/tests/test_search.py
+-rw-rw-r--  2.0 unx     1956 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_security.py
+-rw-rw-r--  2.0 unx     2319 b- defN 23-Jun-21 08:57 changedetectionio/tests/test_share_watch.py
+-rw-rw-r--  2.0 unx     2661 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_source.py
+-rw-rw-r--  2.0 unx     4115 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_trigger.py
+-rw-rw-r--  2.0 unx     2390 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_trigger_regex.py
+-rw-rw-r--  2.0 unx     2486 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_trigger_regex_with_filter.py
+-rw-rw-r--  2.0 unx     2852 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_unique_lines.py
+-rw-rw-r--  2.0 unx     4529 b- defN 23-Jun-21 08:57 changedetectionio/tests/test_watch_fields_storage.py
+-rw-rw-r--  2.0 unx     9447 b- defN 23-Jun-23 15:38 changedetectionio/tests/test_xpath_selector.py
+-rw-rw-r--  2.0 unx     6578 b- defN 23-Jun-23 15:38 changedetectionio/tests/util.py
 -rw-rw-r--  2.0 unx       26 b- defN 22-Dec-04 13:25 changedetectionio/tests/fetchers/__init__.py
 -rw-rw-r--  2.0 unx       44 b- defN 22-Dec-04 13:25 changedetectionio/tests/fetchers/conftest.py
--rw-rw-r--  2.0 unx     1118 b- defN 23-May-05 19:35 changedetectionio/tests/fetchers/test_content.py
+-rw-rw-r--  2.0 unx     1118 b- defN 23-Jun-23 15:38 changedetectionio/tests/fetchers/test_content.py
 -rw-rw-r--  2.0 unx       26 b- defN 22-Dec-04 13:25 changedetectionio/tests/proxy_list/__init__.py
 -rw-rw-r--  2.0 unx      539 b- defN 22-Dec-04 13:25 changedetectionio/tests/proxy_list/conftest.py
 -rw-rw-r--  2.0 unx      169 b- defN 23-Feb-03 22:08 changedetectionio/tests/proxy_list/proxies.json-example
 -rw-rw-r--  2.0 unx     2068 b- defN 23-Feb-03 22:08 changedetectionio/tests/proxy_list/squid-auth.conf
 -rw-rw-r--  2.0 unx       43 b- defN 23-Feb-03 22:08 changedetectionio/tests/proxy_list/squid-passwords.txt
 -rw-rw-r--  2.0 unx     1884 b- defN 22-Dec-04 13:25 changedetectionio/tests/proxy_list/squid.conf
--rw-rw-r--  2.0 unx     1033 b- defN 22-Dec-14 11:44 changedetectionio/tests/proxy_list/test_multiple_proxy.py
--rw-rw-r--  2.0 unx      669 b- defN 22-Dec-04 13:25 changedetectionio/tests/proxy_list/test_proxy.py
+-rw-rw-r--  2.0 unx     1034 b- defN 23-Jun-23 15:38 changedetectionio/tests/proxy_list/test_multiple_proxy.py
+-rw-rw-r--  2.0 unx      669 b- defN 23-Jun-23 15:38 changedetectionio/tests/proxy_list/test_proxy.py
 -rw-rw-r--  2.0 unx     1665 b- defN 23-Feb-03 22:08 changedetectionio/tests/proxy_list/test_select_custom_proxy.py
 -rw-rw-r--  2.0 unx       26 b- defN 23-Mar-18 19:35 changedetectionio/tests/restock/__init__.py
 -rw-rw-r--  2.0 unx       44 b- defN 23-Mar-18 19:35 changedetectionio/tests/restock/conftest.py
--rw-rw-r--  2.0 unx     3697 b- defN 23-Mar-18 19:35 changedetectionio/tests/restock/test_restock.py
+-rw-rw-r--  2.0 unx     3698 b- defN 23-Jun-23 15:38 changedetectionio/tests/restock/test_restock.py
 -rw-rw-r--  2.0 unx       30 b- defN 22-Dec-04 13:25 changedetectionio/tests/unit/__init__.py
 -rwxrwxr-x  2.0 unx     2740 b- defN 23-Mar-20 19:17 changedetectionio/tests/unit/test_notification_diff.py
 -rw-rw-r--  2.0 unx      276 b- defN 22-Dec-04 13:25 changedetectionio/tests/unit/test-content/README.md
 -rw-rw-r--  2.0 unx       94 b- defN 22-Dec-04 13:25 changedetectionio/tests/unit/test-content/after-2.txt
 -rw-rw-r--  2.0 unx      198 b- defN 22-Dec-04 13:25 changedetectionio/tests/unit/test-content/after.txt
 -rw-rw-r--  2.0 unx      170 b- defN 22-Dec-04 13:25 changedetectionio/tests/unit/test-content/before.txt
 -rw-rw-r--  2.0 unx       26 b- defN 22-Dec-04 13:25 changedetectionio/tests/visualselector/__init__.py
 -rw-rw-r--  2.0 unx       44 b- defN 22-Dec-04 13:25 changedetectionio/tests/visualselector/conftest.py
--rw-rw-r--  2.0 unx     2346 b- defN 23-Feb-03 22:08 changedetectionio/tests/visualselector/test_fetch_data.py
--rw-rw-r--  2.0 unx    11357 b- defN 23-Jun-12 13:31 changedetection.io-0.42.3.dist-info/LICENSE
--rw-rw-r--  2.0 unx     5593 b- defN 23-Jun-12 13:31 changedetection.io-0.42.3.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-Jun-12 13:31 changedetection.io-0.42.3.dist-info/WHEEL
--rw-rw-r--  2.0 unx       78 b- defN 23-Jun-12 13:31 changedetection.io-0.42.3.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx       18 b- defN 23-Jun-12 13:31 changedetection.io-0.42.3.dist-info/top_level.txt
--rw-rw-r--  2.0 unx        1 b- defN 22-Sep-08 18:18 changedetection.io-0.42.3.dist-info/zip-safe
-?rw-rw-r--  2.0 unx    18459 b- defN 23-Jun-12 13:31 changedetection.io-0.42.3.dist-info/RECORD
-182 files, 1364846 bytes uncompressed, 576655 bytes compressed:  57.7%
+-rw-rw-r--  2.0 unx     2348 b- defN 23-Jun-21 08:57 changedetectionio/tests/visualselector/test_fetch_data.py
+-rw-rw-r--  2.0 unx    11357 b- defN 23-Jun-27 16:30 changedetection.io-0.43.1.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     5593 b- defN 23-Jun-27 16:30 changedetection.io-0.43.1.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-Jun-27 16:30 changedetection.io-0.43.1.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       78 b- defN 23-Jun-27 16:29 changedetection.io-0.43.1.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx       18 b- defN 23-Jun-27 16:29 changedetection.io-0.43.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx        1 b- defN 22-Sep-08 18:18 changedetection.io-0.43.1.dist-info/zip-safe
+?rw-rw-r--  2.0 unx    19263 b- defN 23-Jun-27 16:30 changedetection.io-0.43.1.dist-info/RECORD
+190 files, 1405074 bytes uncompressed, 587245 bytes compressed:  58.2%
```

## zipnote {}

```diff
@@ -1,8 +1,8 @@
-Filename: changedetection.io-0.42.3.data/scripts/changedetection.py
+Filename: changedetection.io-0.43.1.data/scripts/changedetection.py
 Comment: 
 
 Filename: changedetectionio/__init__.py
 Comment: 
 
 Filename: changedetectionio/apprise_asset.py
 Comment: 
@@ -60,17 +60,35 @@
 
 Filename: changedetectionio/blueprint/browser_steps/nonContext.py
 Comment: 
 
 Filename: changedetectionio/blueprint/price_data_follower/__init__.py
 Comment: 
 
+Filename: changedetectionio/blueprint/tags/README.md
+Comment: 
+
+Filename: changedetectionio/blueprint/tags/__init__.py
+Comment: 
+
+Filename: changedetectionio/blueprint/tags/form.py
+Comment: 
+
+Filename: changedetectionio/blueprint/tags/templates/edit-tag.html
+Comment: 
+
+Filename: changedetectionio/blueprint/tags/templates/groups-overview.html
+Comment: 
+
 Filename: changedetectionio/model/App.py
 Comment: 
 
+Filename: changedetectionio/model/Tag.py
+Comment: 
+
 Filename: changedetectionio/model/Watch.py
 Comment: 
 
 Filename: changedetectionio/model/__init__.py
 Comment: 
 
 Filename: changedetectionio/processors/README.md
@@ -366,14 +384,17 @@
 
 Filename: changedetectionio/tests/test_filter_exist_changes.py
 Comment: 
 
 Filename: changedetectionio/tests/test_filter_failure_notification.py
 Comment: 
 
+Filename: changedetectionio/tests/test_group.py
+Comment: 
+
 Filename: changedetectionio/tests/test_history_consistency.py
 Comment: 
 
 Filename: changedetectionio/tests/test_html_to_text.py
 Comment: 
 
 Filename: changedetectionio/tests/test_ignore_regex_text.py
@@ -417,14 +438,17 @@
 
 Filename: changedetectionio/tests/test_request.py
 Comment: 
 
 Filename: changedetectionio/tests/test_rss.py
 Comment: 
 
+Filename: changedetectionio/tests/test_search.py
+Comment: 
+
 Filename: changedetectionio/tests/test_security.py
 Comment: 
 
 Filename: changedetectionio/tests/test_share_watch.py
 Comment: 
 
 Filename: changedetectionio/tests/test_source.py
@@ -519,29 +543,29 @@
 
 Filename: changedetectionio/tests/visualselector/conftest.py
 Comment: 
 
 Filename: changedetectionio/tests/visualselector/test_fetch_data.py
 Comment: 
 
-Filename: changedetection.io-0.42.3.dist-info/LICENSE
+Filename: changedetection.io-0.43.1.dist-info/LICENSE
 Comment: 
 
-Filename: changedetection.io-0.42.3.dist-info/METADATA
+Filename: changedetection.io-0.43.1.dist-info/METADATA
 Comment: 
 
-Filename: changedetection.io-0.42.3.dist-info/WHEEL
+Filename: changedetection.io-0.43.1.dist-info/WHEEL
 Comment: 
 
-Filename: changedetection.io-0.42.3.dist-info/entry_points.txt
+Filename: changedetection.io-0.43.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: changedetection.io-0.42.3.dist-info/top_level.txt
+Filename: changedetection.io-0.43.1.dist-info/top_level.txt
 Comment: 
 
-Filename: changedetection.io-0.42.3.dist-info/zip-safe
+Filename: changedetection.io-0.43.1.dist-info/zip-safe
 Comment: 
 
-Filename: changedetection.io-0.42.3.dist-info/RECORD
+Filename: changedetection.io-0.43.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## changedetectionio/__init__.py

```diff
@@ -34,15 +34,15 @@
 )
 
 from flask_paginate import Pagination, get_page_parameter
 
 from changedetectionio import html_tools
 from changedetectionio.api import api_v1
 
-__version__ = '0.42.3'
+__version__ = '0.43.1'
 
 datastore = None
 
 # Local
 running_update_threads = []
 ticker_thread = None
 
@@ -313,33 +313,29 @@
         # Always requires token set
         app_rss_token = datastore.data['settings']['application'].get('rss_access_token')
         rss_url_token = request.args.get('token')
         if rss_url_token != app_rss_token:
             return "Access denied, bad token", 403
 
         from . import diff
-        limit_tag = request.args.get('tag')
+        limit_tag = request.args.get('tag', '').lower().strip()
+        # Be sure limit_tag is a uuid
+        for uuid, tag in datastore.data['settings']['application'].get('tags', {}).items():
+            if limit_tag == tag.get('title', '').lower().strip():
+                limit_tag = uuid
 
         # Sort by last_changed and add the uuid which is usually the key..
         sorted_watches = []
 
         # @todo needs a .itemsWithTag() or something - then we can use that in Jinaj2 and throw this away
         for uuid, watch in datastore.data['watching'].items():
-
-            if limit_tag != None:
-                # Support for comma separated list of tags.
-                for tag_in_watch in watch['tag'].split(','):
-                    tag_in_watch = tag_in_watch.strip()
-                    if tag_in_watch == limit_tag:
-                        watch['uuid'] = uuid
-                        sorted_watches.append(watch)
-
-            else:
-                watch['uuid'] = uuid
-                sorted_watches.append(watch)
+            if limit_tag and not limit_tag in watch['tags']:
+                    continue
+            watch['uuid'] = uuid
+            sorted_watches.append(watch)
 
         sorted_watches.sort(key=lambda x: x.last_changed, reverse=False)
 
         fg = FeedGenerator()
         fg.title('changedetection.io')
         fg.description('Feed description')
         fg.link(href='https://changedetection.io')
@@ -388,17 +384,25 @@
         response = make_response(fg.rss_str())
         response.headers.set('Content-Type', 'application/rss+xml;charset=utf-8')
         return response
 
     @app.route("/", methods=['GET'])
     @login_optionally_required
     def index():
+        global datastore
         from changedetectionio import forms
 
-        limit_tag = request.args.get('tag')
+        limit_tag = request.args.get('tag', '').lower().strip()
+
+        # Be sure limit_tag is a uuid
+        for uuid, tag in datastore.data['settings']['application'].get('tags', {}).items():
+            if limit_tag == tag.get('title', '').lower().strip():
+                limit_tag = uuid
+
+
         # Redirect for the old rss path which used the /?rss=true
         if request.args.get('rss'):
             return redirect(url_for('rss', tag=limit_tag))
 
         op = request.args.get('op')
         if op:
             uuid = request.args.get('uuid')
@@ -410,64 +414,50 @@
             datastore.needs_write = True
             return redirect(url_for('index', tag = limit_tag))
 
         # Sort by last_changed and add the uuid which is usually the key..
         sorted_watches = []
         search_q = request.args.get('q').strip().lower() if request.args.get('q') else False
         for uuid, watch in datastore.data['watching'].items():
-
-            if limit_tag:
-                # Support for comma separated list of tags.
-                if not watch.get('tag'):
+            if limit_tag and not limit_tag in watch['tags']:
                     continue
-                for tag_in_watch in watch.get('tag', '').split(','):
-                    tag_in_watch = tag_in_watch.strip()
-                    if tag_in_watch == limit_tag:
-                        watch['uuid'] = uuid
-                        if search_q:
-                            if (watch.get('title') and search_q in watch.get('title').lower()) or search_q in watch.get('url', '').lower():
-                                sorted_watches.append(watch)
-                        else:
-                            sorted_watches.append(watch)
 
-            else:
-                #watch['uuid'] = uuid
-                if search_q:
-                    if (watch.get('title') and search_q in watch.get('title').lower()) or search_q in watch.get('url', '').lower():
-                        sorted_watches.append(watch)
-                else:
+            if search_q:
+                if (watch.get('title') and search_q in watch.get('title').lower()) or search_q in watch.get('url', '').lower():
                     sorted_watches.append(watch)
+            else:
+                sorted_watches.append(watch)
 
-        existing_tags = datastore.get_all_tags()
         form = forms.quickWatchForm(request.form)
         page = request.args.get(get_page_parameter(), type=int, default=1)
         total_count = len(sorted_watches)
 
         pagination = Pagination(page=page,
                                 total=total_count,
                                 per_page=datastore.data['settings']['application'].get('pager_size', 50), css_framework="semantic")
 
 
         output = render_template(
             "watch-overview.html",
                                  # Don't link to hosting when we're on the hosting environment
                                  active_tag=limit_tag,
                                  app_rss_token=datastore.data['settings']['application']['rss_access_token'],
+                                 datastore=datastore,
                                  form=form,
                                  guid=datastore.data['app_guid'],
                                  has_proxies=datastore.proxy_list,
                                  has_unviewed=datastore.has_unviewed,
                                  hosted_sticky=os.getenv("SALTED_PASS", False) == False,
                                  pagination=pagination,
                                  queued_uuids=[q_uuid.item['uuid'] for q_uuid in update_q.queue],
                                  search_q=request.args.get('q','').strip(),
                                  sort_attribute=request.args.get('sort') if request.args.get('sort') else request.cookies.get('sort'),
                                  sort_order=request.args.get('order') if request.args.get('order') else request.cookies.get('order'),
                                  system_default_fetcher=datastore.data['settings']['application'].get('fetch_backend'),
-                                 tags=existing_tags,
+                                 tags=datastore.data['settings']['application'].get('tags'),
                                  watches=sorted_watches
                                  )
 
         if session.get('share-link'):
             del(session['share-link'])
 
         resp = make_response(output)
@@ -602,17 +592,21 @@
             # @todo
             # Radio needs '' not None, or incase that the chosen one no longer exists
             if default['proxy'] is None or not any(default['proxy'] in tup for tup in datastore.proxy_list):
                 default['proxy'] = ''
 
         # proxy_override set to the json/text list of the items
         form = forms.watchForm(formdata=request.form if request.method == 'POST' else None,
-                               data=default,
+                               data=default
                                )
 
+        # For the form widget tag uuid lookup
+        form.tags.datastore = datastore # in _value
+
+
         form.fetch_backend.choices.append(("system", 'System settings default'))
 
         # form.browser_steps[0] can be assumed that we 'goto url' first
 
         if datastore.proxy_list is None:
             # @todo - Couldn't get setattr() etc dynamic addition working, so remove it instead
             del form.proxy
@@ -655,14 +649,24 @@
             if 'filter_text_added' in form.data and not form.data.get('filter_text_added') \
                     and 'filter_text_replaced' in form.data and not form.data.get('filter_text_replaced') \
                     and 'filter_text_removed' in form.data and not form.data.get('filter_text_removed'):
                 extra_update_obj['filter_text_added'] = True
                 extra_update_obj['filter_text_replaced'] = True
                 extra_update_obj['filter_text_removed'] = True
 
+            # Because wtforms doesn't support accessing other data in process_ , but we convert the CSV list of tags back to a list of UUIDs
+            tag_uuids = []
+            if form.data.get('tags'):
+                # Sometimes in testing this can be list, dont know why
+                if type(form.data.get('tags')) == list:
+                    extra_update_obj['tags'] = form.data.get('tags')
+                else:
+                    for t in form.data.get('tags').split(','):
+                        tag_uuids.append(datastore.add_tag(name=t))
+                    extra_update_obj['tags'] = tag_uuids
 
             datastore.data['watching'][uuid].update(form.data)
             datastore.data['watching'][uuid].update(extra_update_obj)
 
             if request.args.get('unpause_on_save'):
                 flash("Updated watch - unpaused!.")
             else:
@@ -709,15 +713,15 @@
                                      available_processors=processors.available_processors(),
                                      browser_steps_config=browser_step_ui_config,
                                      current_base_url=datastore.data['settings']['application']['base_url'],
                                      emailprefix=os.getenv('NOTIFICATION_MAIL_BUTTON_PREFIX', False),
                                      form=form,
                                      has_default_notification_urls=True if len(datastore.data['settings']['application']['notification_urls']) else False,
                                      has_empty_checktime=using_default_check_time,
-                                     has_extra_headers_file=watch.has_extra_headers_file or datastore.has_extra_headers_file,
+                                     has_extra_headers_file=len(datastore.get_all_headers_in_textfile_for_watch(uuid=uuid)) > 0,
                                      is_html_webdriver=is_html_webdriver,
                                      jq_support=jq_support,
                                      playwright_enabled=os.getenv('PLAYWRIGHT_DRIVER_URL', False),
                                      settings_application=datastore.data['settings']['application'],
                                      using_global_webdriver_wait=default['webdriver_delay'] is None,
                                      uuid=uuid,
                                      visualselector_enabled=visualselector_enabled,
@@ -1106,16 +1110,16 @@
                     url = datastore.data["watching"][uuid]["url"]
                     f.write("{}\r\n".format(url))
             list_with_tags_file = "url-list-with-tags.txt"
             with open(
                 os.path.join(datastore_o.datastore_path, list_with_tags_file), "w"
             ) as f:
                 for uuid in datastore.data["watching"]:
-                    url = datastore.data["watching"][uuid]["url"]
-                    tag = datastore.data["watching"][uuid]["tag"]
+                    url = datastore.data["watching"][uuid].get('url')
+                    tag = datastore.data["watching"][uuid].get('tags', {})
                     f.write("{} {}\r\n".format(url, tag))
 
             # Add it to the Zip
             zipObj.write(
                 os.path.join(datastore_o.datastore_path, list_file),
                 arcname=list_file,
                 compress_type=zipfile.ZIP_DEFLATED,
@@ -1195,15 +1199,15 @@
         url = request.form.get('url').strip()
         if datastore.url_exists(url):
             flash('The URL {} already exists'.format(url), "error")
             return redirect(url_for('index'))
 
         add_paused = request.form.get('edit_and_watch_submit_button') != None
         processor = request.form.get('processor', 'text_json_diff')
-        new_uuid = datastore.add_watch(url=url, tag=request.form.get('tag').strip(), extras={'paused': add_paused, 'processor': processor})
+        new_uuid = datastore.add_watch(url=url, tag=request.form.get('tags').strip(), extras={'paused': add_paused, 'processor': processor})
 
         if new_uuid:
             if add_paused:
                 flash('Watch added in Paused state, saving will unpause.')
                 return redirect(url_for('edit_page', uuid=new_uuid, unpause_on_save=1))
             else:
                 # Straight into the queue.
@@ -1263,17 +1267,19 @@
             if uuid not in running_uuids:
                 update_q.put(queuedWatchMetaData.PrioritizedItem(priority=1, item={'uuid': uuid, 'skip_when_checksum_same': False}))
             i = 1
 
         elif tag != None:
             # Items that have this current tag
             for watch_uuid, watch in datastore.data['watching'].items():
-                if (tag != None and tag in watch['tag']):
+                if (tag != None and tag in watch.get('tags', {})):
                     if watch_uuid not in running_uuids and not datastore.data['watching'][watch_uuid]['paused']:
-                        update_q.put(queuedWatchMetaData.PrioritizedItem(priority=1, item={'uuid': watch_uuid, 'skip_when_checksum_same': False}))
+                        update_q.put(
+                            queuedWatchMetaData.PrioritizedItem(priority=1, item={'uuid': watch_uuid, 'skip_when_checksum_same': False})
+                        )
                         i += 1
 
         else:
             # No tag, no uuid, add everything.
             for watch_uuid, watch in datastore.data['watching'].items():
                 if watch_uuid not in running_uuids and not datastore.data['watching'][watch_uuid]['paused']:
                     update_q.put(queuedWatchMetaData.PrioritizedItem(priority=1, item={'uuid': watch_uuid, 'skip_when_checksum_same': False}))
@@ -1353,24 +1359,35 @@
                 if datastore.data['watching'].get(uuid):
                     datastore.data['watching'][uuid.strip()]['notification_title'] = None
                     datastore.data['watching'][uuid.strip()]['notification_body'] = None
                     datastore.data['watching'][uuid.strip()]['notification_urls'] = []
                     datastore.data['watching'][uuid.strip()]['notification_format'] = default_notification_format_for_watch
             flash("{} watches set to use default notification settings".format(len(uuids)))
 
+        elif (op == 'assign-tag'):
+            op_extradata = request.form.get('op_extradata', '').strip()
+            if op_extradata:
+                tag_uuid = datastore.add_tag(name=op_extradata)
+                if op_extradata and tag_uuid:
+                    for uuid in uuids:
+                        uuid = uuid.strip()
+                        if datastore.data['watching'].get(uuid):
+                            datastore.data['watching'][uuid]['tags'].append(tag_uuid)
+
+            flash("{} watches assigned tag".format(len(uuids)))
+
         return redirect(url_for('index'))
 
     @app.route("/api/share-url", methods=['GET'])
     @login_optionally_required
     def form_share_put_watch():
         """Given a watch UUID, upload the info and return a share-link
            the share-link can be imported/added"""
         import requests
         import json
-        tag = request.args.get('tag')
         uuid = request.args.get('uuid')
 
         # more for testing
         if uuid == 'first':
             uuid = list(datastore.data['watching'].keys()).pop()
 
         # copy it to memory as trim off what we dont need (history)
@@ -1415,14 +1432,16 @@
 
     import changedetectionio.blueprint.browser_steps as browser_steps
     app.register_blueprint(browser_steps.construct_blueprint(datastore), url_prefix='/browser-steps')
 
     import changedetectionio.blueprint.price_data_follower as price_data_follower
     app.register_blueprint(price_data_follower.construct_blueprint(datastore, update_q), url_prefix='/price_data_follower')
 
+    import changedetectionio.blueprint.tags as tags
+    app.register_blueprint(tags.construct_blueprint(datastore), url_prefix='/tags')
 
     # @todo handle ctrl break
     ticker_thread = threading.Thread(target=ticker_thread_check_time_launch_checks).start()
     threading.Thread(target=notification_runner).start()
 
     # Check for new release version, but not when running in test/build or pytest
     if not os.getenv("GITHUB_REF", False) and not config.get('disable_checkver') == True:
```

## changedetectionio/forms.py

```diff
@@ -24,14 +24,16 @@
 from changedetectionio import content_fetcher
 from changedetectionio.notification import (
     valid_notification_formats,
 )
 
 from wtforms.fields import FormField
 
+dictfilt = lambda x, y: dict([ (i,x[i]) for i in x if i in set(y) ])
+
 valid_method = {
     'GET',
     'POST',
     'PUT',
     'PATCH',
     'DELETE',
 }
@@ -86,14 +88,37 @@
             # Be really sure it's non-zero in length
             if len(valuelist[0].strip()) > 0:
                 self.encrypted_password = self.build_password(valuelist[0])
                 self.data = ""
         else:
             self.data = False
 
+class StringTagUUID(StringField):
+
+   # process_formdata(self, valuelist) handled manually in POST handler
+
+    # Is what is shown when field <input> is rendered
+    def _value(self):
+        # Tag UUID to name, on submit it will convert it back (in the submit handler of init.py)
+        if self.data and type(self.data) is list:
+            tag_titles = []
+            for i in self.data:
+                tag = self.datastore.data['settings']['application']['tags'].get(i)
+                if tag:
+                    tag_title = tag.get('title')
+                    if tag_title:
+                        tag_titles.append(tag_title)
+
+            return ', '.join(tag_titles)
+
+        if not self.data:
+            return ''
+
+        return 'error'
+
 class TimeBetweenCheckForm(Form):
     weeks = IntegerField('Weeks', validators=[validators.Optional(), validators.NumberRange(min=0, message="Should contain zero or more seconds")])
     days = IntegerField('Days', validators=[validators.Optional(), validators.NumberRange(min=0, message="Should contain zero or more seconds")])
     hours = IntegerField('Hours', validators=[validators.Optional(), validators.NumberRange(min=0, message="Should contain zero or more seconds")])
     minutes = IntegerField('Minutes', validators=[validators.Optional(), validators.NumberRange(min=0, message="Should contain zero or more seconds")])
     seconds = IntegerField('Seconds', validators=[validators.Optional(), validators.NumberRange(min=0, message="Should contain zero or more seconds")])
     # @todo add total seconds minimum validatior = minimum_seconds_recheck_time
@@ -343,22 +368,23 @@
                 except:
                     raise ValidationError("A system-error occurred when validating your jq expression")
 
 class quickWatchForm(Form):
     from . import processors
 
     url = fields.URLField('URL', validators=[validateURL()])
-    tag = StringField('Group tag', [validators.Optional()])
+    tags = StringTagUUID('Group tag', [validators.Optional()])
     watch_submit_button = SubmitField('Watch', render_kw={"class": "pure-button pure-button-primary"})
     processor = RadioField(u'Processor', choices=processors.available_processors(), default="text_json_diff")
     edit_and_watch_submit_button = SubmitField('Edit > Watch', render_kw={"class": "pure-button pure-button-primary"})
 
 
 # Common to a single watch and the global settings
 class commonSettingsForm(Form):
+
     notification_urls = StringListField('Notification URL List', validators=[validators.Optional(), ValidateAppRiseServers()])
     notification_title = StringField('Notification Title', default='ChangeDetection.io Notification - {{ watch_url }}', validators=[validators.Optional(), ValidateJinja2Template()])
     notification_body = TextAreaField('Notification Body', default='{{ watch_url }} had a change.', validators=[validators.Optional(), ValidateJinja2Template()])
     notification_format = SelectField('Notification format', choices=valid_notification_formats.keys())
     fetch_backend = RadioField(u'Fetch Method', choices=content_fetcher.available_fetchers(), validators=[ValidateContentFetcherIsReady()])
     extract_title_as_title = BooleanField('Extract <title> from document and use as watch title', default=False)
     webdriver_delay = IntegerField('Wait seconds before extracting text', validators=[validators.Optional(), validators.NumberRange(min=1,
@@ -378,15 +404,15 @@
 #   @todo move to JS? ajax fetch new field?
 #    remove_button = SubmitField('-', render_kw={"type": "button", "class": "pure-button pure-button-primary", 'title': 'Remove'})
 #    add_button = SubmitField('+', render_kw={"type": "button", "class": "pure-button pure-button-primary", 'title': 'Add new step after'})
 
 class watchForm(commonSettingsForm):
 
     url = fields.URLField('URL', validators=[validateURL()])
-    tag = StringField('Group tag', [validators.Optional()], default='')
+    tags = StringTagUUID('Group tag', [validators.Optional()], default='')
 
     time_between_check = FormField(TimeBetweenCheckForm)
 
     include_filters = StringListField('CSS/JSONPath/JQ/XPath Filters', [ValidateCSSJSONXPATHInput()], default='')
 
     subtractive_selectors = StringListField('Remove elements', [ValidateCSSJSONXPATHInput(allow_xpath=False, allow_json=False)])
```

## changedetectionio/importer.py

```diff
@@ -81,15 +81,16 @@
             ):
 
         import json
         good = 0
         now = time.time()
         self.new_uuids=[]
 
-
+        # @todo Use JSONSchema like in the API to validate here.
+        
         try:
             data = json.loads(data.strip())
         except json.decoder.JSONDecodeError:
             flash("Unable to read JSON file, was it broken?", 'error')
             return
 
         if not data.get('data'):
@@ -116,19 +117,16 @@
                     else:
                         extras['include_filters'].append(d_config['selections'][0]['frames'][0]['includes'][0]['expr'])
                 except KeyError:
                     pass
                 except IndexError:
                     pass
 
-
-                if d.get('tags', False):
-                    extras['tag'] = ", ".join(d['tags'])
-
                 new_uuid = datastore.add_watch(url=d['uri'].strip(),
+                                               tag=",".join(d.get('tags', [])),
                                                extras=extras,
                                                write_to_disk_now=False)
 
                 if new_uuid:
                     # Straight into the queue.
                     self.new_uuids.append(new_uuid)
                     good += 1
```

## changedetectionio/notification.py

```diff
@@ -182,16 +182,21 @@
 def create_notification_parameters(n_object, datastore):
     from copy import deepcopy
 
     # in the case we send a test notification from the main settings, there is no UUID.
     uuid = n_object['uuid'] if 'uuid' in n_object else ''
 
     if uuid != '':
-        watch_title = datastore.data['watching'][uuid]['title']
-        watch_tag = datastore.data['watching'][uuid]['tag']
+        watch_title = datastore.data['watching'][uuid].get('title', '')
+        tag_list = []
+        tags = datastore.get_all_tags_for_watch(uuid)
+        if tags:
+            for tag_uuid, tag in tags.items():
+                tag_list.append(tag.get('title'))
+        watch_tag = ', '.join(tag_list)
     else:
         watch_title = 'Change Detection'
         watch_tag = ''
 
     # Create URLs to customise the notification with
     base_url = datastore.data['settings']['application']['base_url']
```

## changedetectionio/store.py

```diff
@@ -12,14 +12,16 @@
 import re
 import requests
 import secrets
 import threading
 import time
 import uuid as uuid_builder
 
+dictfilt = lambda x, y: dict([ (i,x[i]) for i in x if i in set(y) ])
+
 # Is there an existing library to ensure some data store (JSON etc) is in sync with CRUD methods?
 # Open a github issue if you know something :)
 # https://stackoverflow.com/questions/6190468/how-to-trigger-function-on-value-change
 class ChangeDetectionStore:
     lock = Lock()
     # For general updates/writes that can wait a few seconds
     needs_write = False
@@ -174,28 +176,14 @@
         # Re #152, Return env base_url if not overriden, @todo also prefer the proxy pass url
         env_base_url = os.getenv('BASE_URL','')
         if not self.__data['settings']['application']['base_url']:
           self.__data['settings']['application']['base_url'] = env_base_url.strip('" ')
 
         return self.__data
 
-    def get_all_tags(self):
-        tags = []
-        for uuid, watch in self.data['watching'].items():
-            if watch['tag'] is None:
-                continue
-            # Support for comma separated list of tags.
-            for tag in watch['tag'].split(','):
-                tag = tag.strip()
-                if tag not in tags:
-                    tags.append(tag)
-
-        tags.sort()
-        return tags
-
     # Delete a single watch by UUID
     def delete(self, uuid):
         import pathlib
         import shutil
 
         with self.lock:
             if uuid == 'all':
@@ -213,18 +201,17 @@
                     shutil.rmtree(path)
                 del self.data['watching'][uuid]
 
         self.needs_write_urgent = True
 
     # Clone a watch by UUID
     def clone(self, uuid):
-        url = self.data['watching'][uuid]['url']
-        tag = self.data['watching'][uuid]['tag']
+        url = self.data['watching'][uuid].get('url')
         extras = self.data['watching'][uuid]
-        new_uuid = self.add_watch(url=url, tag=tag, extras=extras)
+        new_uuid = self.add_watch(url=url, extras=extras)
         return new_uuid
 
     def url_exists(self, url):
 
         # Probably their should be dict...
         for watch in self.data['watching'].values():
             if watch['url'] == url:
@@ -251,24 +238,22 @@
             unlink(item)
 
         # Force the attr to recalculate
         bump = self.__data['watching'][uuid].history
 
         self.needs_write_urgent = True
 
-    def add_watch(self, url, tag="", extras=None, write_to_disk_now=True):
+    def add_watch(self, url, tag='', extras=None, tag_uuids=None, write_to_disk_now=True):
 
         if extras is None:
             extras = {}
-        # should always be str
-        if tag is None or not tag:
-            tag = ''
 
         # Incase these are copied across, assume it's a reference and deepcopy()
         apply_extras = deepcopy(extras)
+        apply_extras['tags'] = [] if not apply_extras.get('tags') else apply_extras.get('tags')
 
         # Was it a share link? try to fetch the data
         if (url.startswith("https://changedetection.io/share/")):
             try:
                 r = requests.request(method="GET",
                                      url=url,
                                      # So we know to return the JSON instead of the human-friendly "help" page
@@ -287,14 +272,15 @@
                     'include_filters',
                     'method',
                     'paused',
                     'previous_md5',
                     'processor',
                     'subtractive_selectors',
                     'tag',
+                    'tags',
                     'text_should_not_be_present',
                     'title',
                     'trigger_text',
                     'url',
                     'webdriver_js_execute_code',
                 ]:
                     if res.get(k):
@@ -309,33 +295,44 @@
                 flash("Error fetching metadata for {}".format(url), 'error')
                 return False
         from .model.Watch import is_safe_url
         if not is_safe_url(url):
             flash('Watch protocol is not permitted by SAFE_PROTOCOL_REGEX', 'error')
             return None
 
-        with self.lock:
-            # #Re 569
-            new_watch = Watch.model(datastore_path=self.datastore_path, default={
-                'url': url,
-                'tag': tag,
-                'date_created': int(time.time())
-            })
-
-            new_uuid = new_watch['uuid']
-            logging.debug("Added URL {} - {}".format(url, new_uuid))
-
-            for k in ['uuid', 'history', 'last_checked', 'last_changed', 'newest_history_key', 'previous_md5', 'viewed']:
-                if k in apply_extras:
-                    del apply_extras[k]
+        if tag and type(tag) == str:
+            # Then it's probably a string of the actual tag by name, split and add it
+            for t in tag.split(','):
+                # for each stripped tag, add tag as UUID
+                for a_t in t.split(','):
+                    tag_uuid = self.add_tag(a_t)
+                    apply_extras['tags'].append(tag_uuid)
+
+        # Or if UUIDs given directly
+        if tag_uuids:
+            apply_extras['tags'] = list(set(apply_extras['tags'] + tag_uuids))
+
+        # Make any uuids unique
+        if apply_extras.get('tags'):
+            apply_extras['tags'] = list(set(apply_extras.get('tags')))
+
+        new_watch = Watch.model(datastore_path=self.datastore_path, url=url)
+
+        new_uuid = new_watch.get('uuid')
+
+        logging.debug("Added URL {} - {}".format(url, new_uuid))
+
+        for k in ['uuid', 'history', 'last_checked', 'last_changed', 'newest_history_key', 'previous_md5', 'viewed']:
+            if k in apply_extras:
+                del apply_extras[k]
+
+        new_watch.update(apply_extras)
+        new_watch.ensure_data_dir_exists()
+        self.__data['watching'][new_uuid] = new_watch
 
-            new_watch.update(apply_extras)
-            self.__data['watching'][new_uuid] = new_watch
-
-        self.__data['watching'][new_uuid].ensure_data_dir_exists()
 
         if write_to_disk_now:
             self.sync_to_json()
 
         return new_uuid
 
     def visualselector_data_is_ready(self, watch_uuid):
@@ -507,27 +504,107 @@
         return None
 
     @property
     def has_extra_headers_file(self):
         filepath = os.path.join(self.datastore_path, 'headers.txt')
         return os.path.isfile(filepath)
 
-    def get_all_headers(self):
+    def get_all_base_headers(self):
+        from .model.App import parse_headers_from_text_file
+        headers = {}
+        # Global app settings
+        headers.update(self.data['settings'].get('headers', {}))
+
+        return headers
+
+    def get_all_headers_in_textfile_for_watch(self, uuid):
         from .model.App import parse_headers_from_text_file
-        headers = copy(self.data['settings'].get('headers', {}))
+        headers = {}
 
+        # Global in /datastore/headers.txt
         filepath = os.path.join(self.datastore_path, 'headers.txt')
         try:
             if os.path.isfile(filepath):
                 headers.update(parse_headers_from_text_file(filepath))
         except Exception as e:
             print(f"ERROR reading headers.txt at {filepath}", str(e))
 
+        watch = self.data['watching'].get(uuid)
+        if watch:
+
+            # In /datastore/xyz-xyz/headers.txt
+            filepath = os.path.join(watch.watch_data_dir, 'headers.txt')
+            try:
+                if os.path.isfile(filepath):
+                    headers.update(parse_headers_from_text_file(filepath))
+            except Exception as e:
+                print(f"ERROR reading headers.txt at {filepath}", str(e))
+
+            # In /datastore/tag-name.txt
+            tags = self.get_all_tags_for_watch(uuid=uuid)
+            for tag_uuid, tag in tags.items():
+                fname = "headers-"+re.sub(r'[\W_]', '', tag.get('title')).lower().strip() + ".txt"
+                filepath = os.path.join(self.datastore_path, fname)
+                try:
+                    if os.path.isfile(filepath):
+                        headers.update(parse_headers_from_text_file(filepath))
+                except Exception as e:
+                    print(f"ERROR reading headers.txt at {filepath}", str(e))
+
         return headers
 
+    def get_tag_overrides_for_watch(self, uuid, attr):
+        tags = self.get_all_tags_for_watch(uuid=uuid)
+        ret = []
+
+        if tags:
+            for tag_uuid, tag in tags.items():
+                if attr in tag and tag[attr]:
+                    ret=[*ret, *tag[attr]]
+
+        return ret
+
+    def add_tag(self, name):
+        # If name exists, return that
+        n = name.strip().lower()
+        print (f">>> Adding new tag - '{n}'")
+        if not n:
+            return False
+
+        for uuid, tag in self.__data['settings']['application'].get('tags', {}).items():
+            if n == tag.get('title', '').lower().strip():
+                print (f">>> Tag {name} already exists")
+                return uuid
+
+        # Eventually almost everything todo with a watch will apply as a Tag
+        # So we use the same model as a Watch
+        with self.lock:
+            new_tag = Watch.model(datastore_path=self.datastore_path, default={
+                'title': name.strip(),
+                'date_created': int(time.time())
+            })
+
+            new_uuid = new_tag.get('uuid')
+
+            self.__data['settings']['application']['tags'][new_uuid] = new_tag
+
+        return new_uuid
+
+    def get_all_tags_for_watch(self, uuid):
+        """This should be in Watch model but Watch doesn't have access to datastore, not sure how to solve that yet"""
+        watch = self.data['watching'].get(uuid)
+
+        # Should return a dict of full tag info linked by UUID
+        if watch:
+            return dictfilt(self.__data['settings']['application']['tags'], watch.get('tags', []))
+
+        return {}
+
+    def tag_exists_by_name(self, tag_name):
+        return any(v.get('title', '').lower() == tag_name.lower() for k, v in self.__data['settings']['application']['tags'].items())
 
     # Run all updates
     # IMPORTANT - Each update could be run even when they have a new install and the schema is correct
     #             So therefor - each `update_n` should be very careful about checking if it needs to actually run
     #             Probably we should bump the current update schema version with each tag release version?
     def run_updates(self):
         import inspect
@@ -706,7 +783,20 @@
         i = 0
         for uuid, watch in self.data['watching'].items():
             if not watch.get('date_created'):
                 watch['date_created'] = i
             i+=1
         return
 
+    # Create tag objects and their references from existing tag text
+    def update_12(self):
+        i = 0
+        for uuid, watch in self.data['watching'].items():
+            # Split out and convert old tag string
+            tag = watch.get('tag')
+            if tag:
+                tag_uuids = []
+                for t in tag.split(','):
+                    tag_uuids.append(self.add_tag(name=t))
+
+                self.data['watching'][uuid]['tags'] = tag_uuids
+
```

## changedetectionio/update_worker.py

```diff
@@ -22,89 +22,125 @@
         logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)
         self.q = q
         self.app = app
         self.notification_q = notification_q
         self.datastore = datastore
         super().__init__(*args, **kwargs)
 
-    def send_content_changed_notification(self, t, watch_uuid):
+    def queue_notification_for_watch(self, n_object, watch):
 
         from changedetectionio import diff
 
+        watch_history = watch.history
+        dates = list(watch_history.keys())
+
+        # HTML needs linebreak, but MarkDown and Text can use a linefeed
+        if n_object['notification_format'] == 'HTML':
+            line_feed_sep = "<br>"
+        else:
+            line_feed_sep = "\n"
+
+        # Add text that was triggered
+        snapshot_contents = watch.get_history_snapshot(dates[-1])
+        trigger_text = watch.get('trigger_text', [])
+        triggered_text = ''
+
+        if len(trigger_text):
+            from . import html_tools
+            triggered_text = html_tools.get_triggered_text(content=snapshot_contents, trigger_text=trigger_text)
+            if triggered_text:
+                triggered_text = line_feed_sep.join(triggered_text)
+
+
+        n_object.update({
+            'current_snapshot': snapshot_contents,
+            'diff': diff.render_diff(watch.get_history_snapshot(dates[-2]), watch.get_history_snapshot(dates[-1]), line_feed_sep=line_feed_sep),
+            'diff_added': diff.render_diff(watch.get_history_snapshot(dates[-2]), watch.get_history_snapshot(dates[-1]), include_removed=False, line_feed_sep=line_feed_sep),
+            'diff_full': diff.render_diff(watch.get_history_snapshot(dates[-2]), watch.get_history_snapshot(dates[-1]), include_equal=True, line_feed_sep=line_feed_sep),
+            'diff_removed': diff.render_diff(watch.get_history_snapshot(dates[-2]), watch.get_history_snapshot(dates[-1]), include_added=False, line_feed_sep=line_feed_sep),
+            'screenshot': watch.get_screenshot() if watch.get('notification_screenshot') else None,
+            'triggered_text': triggered_text,
+            'uuid': watch.get('uuid'),
+            'watch_url': watch.get('url'),
+        })
+        logging.info (">> SENDING NOTIFICATION")
+        self.notification_q.put(n_object)
+
+    # Prefer - Individual watch settings > Tag settings >  Global settings (in that order)
+    def _check_cascading_vars(self, var_name, watch):
+
         from changedetectionio.notification import (
-            default_notification_format_for_watch
+            default_notification_format_for_watch,
+            default_notification_body,
+            default_notification_title,
         )
 
+
+        # Would be better if this was some kind of Object where Watch can reference the parent datastore etc
+        v = watch.get(var_name)
+        if v and not watch.get('notification_muted'):
+            return v
+
+        tags = self.datastore.get_all_tags_for_watch(uuid=watch.get('uuid'))
+        if tags:
+            for tag_uuid, tag in tags.items():
+                v = tag.get(var_name)
+                if v and not tag.get('notification_muted'):
+                    return v
+
+        if self.datastore.data['settings']['application'].get(var_name):
+            return self.datastore.data['settings']['application'].get(var_name)
+
+        # Otherwise could be defaults
+        if var_name == 'notification_format':
+            return default_notification_format_for_watch
+        if var_name == 'notification_body':
+            return default_notification_body
+        if var_name == 'notification_title':
+            return default_notification_title
+
+        return None
+
+    def send_content_changed_notification(self, watch_uuid):
+
         n_object = {}
-        watch = self.datastore.data['watching'].get(watch_uuid, False)
+        watch = self.datastore.data['watching'].get(watch_uuid)
         if not watch:
             return
 
         watch_history = watch.history
         dates = list(watch_history.keys())
         # Theoretically it's possible that this could be just 1 long,
         # - In the case that the timestamp key was not unique
         if len(dates) == 1:
             raise ValueError(
                 "History index had 2 or more, but only 1 date loaded, timestamps were not unique? maybe two of the same timestamps got written, needs more delay?"
             )
 
-        n_object['notification_urls'] = watch['notification_urls'] if len(watch['notification_urls']) else \
-            self.datastore.data['settings']['application']['notification_urls']
-
-        n_object['notification_title'] = watch['notification_title'] if watch['notification_title'] else \
-            self.datastore.data['settings']['application']['notification_title']
+        # Should be a better parent getter in the model object
 
-        n_object['notification_body'] = watch['notification_body'] if watch['notification_body'] else \
-            self.datastore.data['settings']['application']['notification_body']
+        # Prefer - Individual watch settings > Tag settings >  Global settings (in that order)
+        n_object['notification_urls'] = self._check_cascading_vars('notification_urls', watch)
+        n_object['notification_title'] = self._check_cascading_vars('notification_title', watch)
+        n_object['notification_body'] = self._check_cascading_vars('notification_body', watch)
+        n_object['notification_format'] = self._check_cascading_vars('notification_format', watch)
+
+        # (Individual watch) Only prepare to notify if the rules above matched
+        queued = False
+        if n_object and n_object.get('notification_urls'):
+            queued = True
+            self.queue_notification_for_watch(n_object, watch)
 
-        n_object['notification_format'] = watch['notification_format'] if watch['notification_format'] != default_notification_format_for_watch else \
-            self.datastore.data['settings']['application']['notification_format']
+        return queued
 
 
-        # Only prepare to notify if the rules above matched
-        if 'notification_urls' in n_object and n_object['notification_urls']:
-            # HTML needs linebreak, but MarkDown and Text can use a linefeed
-            if n_object['notification_format'] == 'HTML':
-                line_feed_sep = "<br>"
-            else:
-                line_feed_sep = "\n"
-
-            # Add text that was triggered
-            snapshot_contents = watch.get_history_snapshot(dates[-1])
-            trigger_text = watch.get('trigger_text', [])
-            triggered_text = ''
-
-            if len(trigger_text):
-                from . import html_tools
-                triggered_text = html_tools.get_triggered_text(content=snapshot_contents, trigger_text=trigger_text)
-                if triggered_text:
-                    triggered_text = line_feed_sep.join(triggered_text)
-
-
-            n_object.update({
-                'current_snapshot': snapshot_contents,
-                'diff': diff.render_diff(watch.get_history_snapshot(dates[-2]), watch.get_history_snapshot(dates[-1]), line_feed_sep=line_feed_sep),
-                'diff_added': diff.render_diff(watch.get_history_snapshot(dates[-2]), watch.get_history_snapshot(dates[-1]), include_removed=False, line_feed_sep=line_feed_sep),
-                'diff_full': diff.render_diff(watch.get_history_snapshot(dates[-2]), watch.get_history_snapshot(dates[-1]), include_equal=True, line_feed_sep=line_feed_sep),
-                'diff_removed': diff.render_diff(watch.get_history_snapshot(dates[-2]), watch.get_history_snapshot(dates[-1]), include_added=False, line_feed_sep=line_feed_sep),
-                'screenshot': watch.get_screenshot() if watch.get('notification_screenshot') else None,
-                'triggered_text': triggered_text,
-                'uuid': watch_uuid,
-                'watch_url': watch['url'],
-            })
-            logging.info (">> SENDING NOTIFICATION")
-            self.notification_q.put(n_object)
-        else:
-            logging.info (">> NO Notification sent, notification_url was empty in both watch and system")
-
     def send_filter_failure_notification(self, watch_uuid):
 
         threshold = self.datastore.data['settings']['application'].get('filter_failure_notification_threshold_attempts')
-        watch = self.datastore.data['watching'].get(watch_uuid, False)
+        watch = self.datastore.data['watching'].get(watch_uuid)
         if not watch:
             return
 
         n_object = {'notification_title': 'Changedetection.io - Alert - CSS/xPath filter was not present in the page',
                     'notification_body': "Your configured CSS/xPath filters of '{}' for {{{{watch_url}}}} did not appear on the page after {} attempts, did the page change layout?\n\nLink: {{{{base_url}}}}/edit/{{{{watch_uuid}}}}\n\nThanks - Your omniscient changedetection.io installation :)\n".format(
                         ", ".join(watch['include_filters']),
                         threshold),
@@ -173,15 +209,15 @@
             except queue.Empty:
                 pass
 
             else:
                 uuid = queued_item_data.item.get('uuid')
                 self.current_uuid = uuid
 
-                if uuid in list(self.datastore.data['watching'].keys()):
+                if uuid in list(self.datastore.data['watching'].keys()) and self.datastore.data['watching'][uuid].get('url'):
                     changed_detected = False
                     contents = b''
                     process_changedetection_results = True
                     update_obj = {}
                     print("> Processing UUID {} Priority {} URL {}".format(uuid, queued_item_data.priority,
                                                                            self.datastore.data['watching'][uuid]['url']))
                     now = time.time()
@@ -356,15 +392,15 @@
                             # A change was detected
                             if changed_detected:
                                 print (">> Change detected in UUID {} - {}".format(uuid, watch['url']))
 
                                 # Notifications should only trigger on the second time (first time, we gather the initial snapshot)
                                 if watch.history_n >= 2:
                                     if not self.datastore.data['watching'][uuid].get('notification_muted'):
-                                        self.send_content_changed_notification(self, watch_uuid=uuid)
+                                        self.send_content_changed_notification(watch_uuid=uuid)
 
 
                         except Exception as e:
                             # Catch everything possible here, so that if a worker crashes, we don't lose it until restart!
                             print("!!!! Exception in update_worker !!!\n", e)
                             self.app.logger.error("Exception reached processing watch UUID: %s - %s", uuid, str(e))
                             self.datastore.update_watch(uuid=uuid, update_obj={'last_error': str(e)})
```

## changedetectionio/api/api_v1.py

```diff
@@ -214,17 +214,24 @@
 
         if json_data.get('proxy'):
             plist = self.datastore.proxy_list
             if not json_data.get('proxy') in plist:
                 return "Invalid proxy choice, currently supported proxies are '{}'".format(', '.join(plist)), 400
 
         extras = copy.deepcopy(json_data)
+
+        # Because we renamed 'tag' to 'tags' but don't want to change the API (can do this in v2 of the API)
+        tags = None
+        if extras.get('tag'):
+            tags = extras.get('tag')
+            del extras['tag']
+
         del extras['url']
 
-        new_uuid = self.datastore.add_watch(url=url, extras=extras)
+        new_uuid = self.datastore.add_watch(url=url, extras=extras, tag=tags)
         if new_uuid:
             self.update_q.put(queuedWatchMetaData.PrioritizedItem(priority=1, item={'uuid': new_uuid, 'skip_when_checksum_same': True}))
             return {'uuid': new_uuid}, 201
         else:
             return "Invalid or unsupported URL", 400
 
     @auth.check_token
@@ -255,21 +262,24 @@
         @apiParam {String} [tag]               Optional name of tag to limit results
         @apiName ListWatches
         @apiGroup Watch Management
         @apiSuccess (200) {String} OK JSON dict
         """
         list = {}
 
-        tag_limit = request.args.get('tag', None)
-        for k, watch in self.datastore.data['watching'].items():
-            if tag_limit:
-                if not tag_limit.lower() in watch.all_tags:
-                    continue
+        tag_limit = request.args.get('tag', '').lower()
+
+
+        for uuid, watch in self.datastore.data['watching'].items():
+            # Watch tags by name (replace the other calls?)
+            tags = self.datastore.get_all_tags_for_watch(uuid=uuid)
+            if tag_limit and not any(v.get('title').lower() == tag_limit for k, v in tags.items()):
+                continue
 
-            list[k] = {'url': watch['url'],
+            list[uuid] = {'url': watch['url'],
                        'title': watch['title'],
                        'last_checked': watch['last_checked'],
                        'last_changed': watch.last_changed,
                        'last_error': watch['last_error']}
 
         if request.args.get('recheck_all'):
             for uuid in self.datastore.data['watching'].keys():
```

## changedetectionio/model/App.py

```diff
@@ -39,14 +39,15 @@
                     'notification_urls': [], # Apprise URL list
                     'pager_size': 50,
                     'password': False,
                     'render_anchor_tag_content': False,
                     'schema_version' : 0,
                     'shared_diff_access': False,
                     'webdriver_delay': None , # Extra delay in seconds before extracting text
+                    'tags': {} #@todo use Tag.model initialisers
                 }
             }
         }
 
     def __init__(self, *arg, **kw):
         super(model, self).__init__(*arg, **kw)
         self.update(self.base_config)
```

## changedetectionio/model/Watch.py

```diff
@@ -48,15 +48,16 @@
     'notification_screenshot': False,  # Include the latest screenshot if available and supported by the apprise URL
     'notification_urls': [],  # List of URLs to add to the notification Queue (Usually AppRise)
     'paused': False,
     'previous_md5': False,
     'previous_md5_before_filters': False,  # Used for skipping changedetection entirely
     'proxy': None,  # Preferred proxy connection
     'subtractive_selectors': [],
-    'tag': None,
+    'tag': '', # Old system of text name for a tag, to be removed
+    'tags': [], # list of UUIDs to App.Tags
     'text_should_not_be_present': [],  # Text that should not present
     # Re #110, so then if this is set to None, we know to use the default value instead
     # Requires setting to None on submit if it's the same as the default
     # Should be all None by default, so we use the system default in this case.
     'time_between_check': {'weeks': None, 'days': None, 'hours': None, 'minutes': None, 'seconds': None},
     'title': None,
     'trigger_text': [],  # List of text or regex to wait for until a change is detected
@@ -451,66 +452,28 @@
                             csv_writer.writerow(row)
 
         if f:
             f.close()
 
         return csv_output_filename
 
-    @property
-    # Return list of tags, stripped and lowercase, used for searching
-    def all_tags(self):
-        return [s.strip().lower() for s in self.get('tag','').split(',')]
 
     def has_special_diff_filter_options_set(self):
 
         # All False - nothing would be done, so act like it's not processable
         if not self.get('filter_text_added', True) and not self.get('filter_text_replaced', True) and not self.get('filter_text_removed', True):
             return False
 
         # Or one is set
         if not self.get('filter_text_added', True) or not self.get('filter_text_replaced', True) or not self.get('filter_text_removed', True):
             return True
 
         # None is set
         return False
 
-    @property
-    def has_extra_headers_file(self):
-        if os.path.isfile(os.path.join(self.watch_data_dir, 'headers.txt')):
-            return True
-
-        for f in self.all_tags:
-            fname = "headers-"+re.sub(r'[\W_]', '', f).lower().strip() + ".txt"
-            filepath = os.path.join(self.__datastore_path, fname)
-            if os.path.isfile(filepath):
-                return True
-
-        return False
-
-    def get_all_headers(self):
-        from .App import parse_headers_from_text_file
-        headers = self.get('headers', {}).copy()
-        # Available headers on the disk could 'headers.txt' in the watch data dir
-        filepath = os.path.join(self.watch_data_dir, 'headers.txt')
-        try:
-            if os.path.isfile(filepath):
-                headers.update(parse_headers_from_text_file(filepath))
-        except Exception as e:
-            print(f"ERROR reading headers.txt at {filepath}", str(e))
-
-        # Or each by tag, as tagname.txt in the main datadir
-        for f in self.all_tags:
-            fname = "headers-"+re.sub(r'[\W_]', '', f).lower().strip() + ".txt"
-            filepath = os.path.join(self.__datastore_path, fname)
-            try:
-                if os.path.isfile(filepath):
-                    headers.update(parse_headers_from_text_file(filepath))
-            except Exception as e:
-                print(f"ERROR reading headers.txt at {filepath}", str(e))
-        return headers
 
     def get_last_fetched_before_filters(self):
         import brotli
         filepath = os.path.join(self.watch_data_dir, 'last-fetched.br')
 
         if not os.path.isfile(filepath):
             # If a previous attempt doesnt yet exist, just snarf the previous snapshot instead
```

## changedetectionio/processors/restock_diff.py

```diff
@@ -38,19 +38,18 @@
         if re.search(r'^file', watch.get('url', ''), re.IGNORECASE) and not os.getenv('ALLOW_FILE_URI', False):
             raise Exception(
                 "file:// type access is denied for security reasons."
             )
 
         # Unset any existing notification error
         update_obj = {'last_notification_error': False, 'last_error': False}
-        extra_headers = watch.get('headers', [])
 
-        # Tweak the base config with the per-watch ones
-        request_headers = deepcopy(self.datastore.data['settings']['headers'])
-        request_headers.update(extra_headers)
+        request_headers = watch.get('headers', [])
+        request_headers.update(self.datastore.get_all_base_headers())
+        request_headers.update(self.datastore.get_all_headers_in_textfile_for_watch(uuid=uuid))
 
         # https://github.com/psf/requests/issues/4525
         # Requests doesnt yet support brotli encoding, so don't put 'br' here, be totally sure that the user cannot
         # do this by accident.
         if 'Accept-Encoding' in request_headers and "br" in request_headers['Accept-Encoding']:
             request_headers['Accept-Encoding'] = request_headers['Accept-Encoding'].replace(', br', '')
```

## changedetectionio/processors/text_json_diff.py

```diff
@@ -53,31 +53,30 @@
     def run(self, uuid, skip_when_checksum_same=True):
         changed_detected = False
         screenshot = False  # as bytes
         stripped_text_from_html = ""
 
         # DeepCopy so we can be sure we don't accidently change anything by reference
         watch = deepcopy(self.datastore.data['watching'].get(uuid))
-
         if not watch:
             raise Exception("Watch no longer exists.")
 
         # Protect against file:// access
         if re.search(r'^file', watch.get('url', ''), re.IGNORECASE) and not os.getenv('ALLOW_FILE_URI', False):
             raise Exception(
                 "file:// type access is denied for security reasons."
             )
 
         # Unset any existing notification error
         update_obj = {'last_notification_error': False, 'last_error': False}
 
         # Tweak the base config with the per-watch ones
-        extra_headers = watch.get_all_headers()
-        request_headers = self.datastore.get_all_headers()
-        request_headers.update(extra_headers)
+        request_headers = watch.get('headers', [])
+        request_headers.update(self.datastore.get_all_base_headers())
+        request_headers.update(self.datastore.get_all_headers_in_textfile_for_watch(uuid=uuid))
 
         # https://github.com/psf/requests/issues/4525
         # Requests doesnt yet support brotli encoding, so don't put 'br' here, be totally sure that the user cannot
         # do this by accident.
         if 'Accept-Encoding' in request_headers and "br" in request_headers['Accept-Encoding']:
             request_headers['Accept-Encoding'] = request_headers['Accept-Encoding'].replace(', br', '')
 
@@ -187,29 +186,31 @@
             # @todo may cause problems with non-UTF8?
             metadata = "<p>Added by changedetection.io: Document checksum - {} Filesize - {} bytes</p>".format(
                 hashlib.md5(fetcher.raw_content).hexdigest().upper(),
                 len(fetcher.content))
 
             fetcher.content = fetcher.content.replace('</body>', metadata + '</body>')
 
-
-        include_filters_rule = deepcopy(watch.get('include_filters', []))
-        # include_filters_rule = watch['include_filters']
-        subtractive_selectors = watch.get(
-            "subtractive_selectors", []
-        ) + self.datastore.data["settings"]["application"].get(
-            "global_subtractive_selectors", []
-        )
+        # Better would be if Watch.model could access the global data also
+        # and then use getattr https://docs.python.org/3/reference/datamodel.html#object.__getitem__
+        # https://realpython.com/inherit-python-dict/ instead of doing it procedurely
+        include_filters_from_tags = self.datastore.get_tag_overrides_for_watch(uuid=uuid, attr='include_filters')
+        include_filters_rule = [*watch.get('include_filters', []), *include_filters_from_tags]
+
+        subtractive_selectors = [*self.datastore.get_tag_overrides_for_watch(uuid=uuid, attr='subtractive_selectors'),
+                                 *watch.get("subtractive_selectors", []),
+                                 *self.datastore.data["settings"]["application"].get("global_subtractive_selectors", [])
+                                 ]
 
         # Inject a virtual LD+JSON price tracker rule
         if watch.get('track_ldjson_price_data', '') == PRICE_DATA_TRACK_ACCEPT:
             include_filters_rule.append(html_tools.LD_JSON_PRODUCT_OFFER_SELECTOR)
 
-        has_filter_rule = include_filters_rule and len("".join(include_filters_rule).strip())
-        has_subtractive_selectors = subtractive_selectors and len(subtractive_selectors[0].strip())
+        has_filter_rule = len(include_filters_rule) and len(include_filters_rule[0].strip())
+        has_subtractive_selectors = len(subtractive_selectors) and len(subtractive_selectors[0].strip())
 
         if is_json and not has_filter_rule:
             include_filters_rule.append("json:$")
             has_filter_rule = True
 
         if is_json:
             # Sort the JSON so we dont get false alerts when the content is just re-ordered
```

## changedetectionio/static/js/toggle-theme.js

### js-beautify {}

```diff
@@ -5,21 +5,15 @@
 $(document).ready(function() {
     const button = document.getElementById("toggle-light-mode");
 
     button.onclick = () => {
         const htmlElement = document.getElementsByTagName("html");
         const isDarkMode = htmlElement[0].dataset.darkmode === "true";
         htmlElement[0].dataset.darkmode = !isDarkMode;
-        if (isDarkMode) {
-            button.classList.remove("dark");
-            setCookieValue(false);
-        } else {
-            button.classList.add("dark");
-            setCookieValue(true);
-        }
+        setCookieValue(!isDarkMode);
     };
 
     const setCookieValue = (value) => {
         document.cookie = `css_dark_mode=${value};max-age=31536000;path=/`
     }
 
     // Search input box behaviour
```

## changedetectionio/static/js/watch-overview.js

### js-beautify {}

```diff
@@ -1,13 +1,16 @@
 $(function() {
     // Remove unviewed status when normally clicked
     $('.diff-link').click(function() {
         $(this).closest('.unviewed').removeClass('unviewed');
     });
 
+    $("#checkbox-assign-tag").click(function(e) {
+        $('#op_extradata').val(prompt("Enter a tag name"));
+    });
 
     $('.with-share-link > *').click(function() {
         $("#copied-clipboard").remove();
 
         var range = document.createRange();
         var n = $("#share-link")[0];
         range.selectNode(n);
@@ -18,18 +21,29 @@
 
         $('.with-share-link').append('<span style="font-size: 80%; color: #fff;" id="copied-clipboard">Copied to clipboard</span>');
         $("#copied-clipboard").fadeOut(2500, function() {
             $(this).remove();
         });
     });
 
+    $(".watch-table tr").click(function(event) {
+        var tagName = event.target.tagName.toLowerCase();
+        if (tagName === 'tr' || tagName === 'td') {
+            var x = $('input[type=checkbox]', this);
+            if (x) {
+                $(x).click();
+            }
+        }
+    });
+
     // checkboxes - check all
     $("#check-all").click(function(e) {
         $('input[type=checkbox]').not(this).prop('checked', this.checked);
     });
+
     // checkboxes - show/hide buttons
     $("input[type=checkbox]").click(function(e) {
         if ($('input[type=checkbox]:checked').length) {
             $('#checkbox-operations').slideDown();
         } else {
             $('#checkbox-operations').slideUp();
         }
```

## changedetectionio/static/styles/styles.css

```diff
@@ -279,14 +279,18 @@
   --color-background-tab-hover: rgba(0, 0, 0, 0.5);
   --color-background-snapshot-age: var(--color-grey-200);
   --color-shadow-jump: var(--color-grey-200);
   --color-icon-github: var(--color-white);
   --color-icon-github-hover: var(--color-grey-700);
   --color-watch-table-error: var(--color-light-red);
   --color-watch-table-row-text: var(--color-grey-800); }
+  html[data-darkmode="true"] #toggle-light-mode .icon-light {
+    display: none; }
+  html[data-darkmode="true"] #toggle-light-mode .icon-dark {
+    display: block; }
   html[data-darkmode="true"] .icon-spread {
     filter: hue-rotate(-10deg) brightness(1.5); }
   html[data-darkmode="true"] .watch-table .title-col a[target="_blank"]::after,
   html[data-darkmode="true"] .watch-table .current-diff-url::after {
     filter: invert(0.5) hue-rotate(10deg) brightness(2); }
   html[data-darkmode="true"] .watch-table .watch-controls .state-off img {
     opacity: 0.3; }
@@ -331,18 +335,14 @@
   a.github-link:hover {
     color: var(--color-icon-github-hover); }
 
 #toggle-light-mode {
   width: 3rem; }
   #toggle-light-mode .icon-dark {
     display: none; }
-  #toggle-light-mode.dark .icon-light {
-    display: none; }
-  #toggle-light-mode.dark .icon-dark {
-    display: block; }
 
 #toggle-search {
   width: 2rem; }
 
 #search-q {
   opacity: 0;
   -webkit-transition: all .9s ease;
```

## changedetectionio/templates/base.html

```diff
@@ -55,14 +55,17 @@
         {% endif %}
 
         <ul class="pure-menu-list" id="top-right-menu">
           {% if current_user.is_authenticated or not has_password %}
             {% if not
             current_diff_url %}
               <li class="pure-menu-item">
+                <a href="{{ url_for('tags.tags_overview_page')}}" class="pure-menu-link">GROUPS</a>
+              </li>
+              <li class="pure-menu-item">
                 <a href="{{ url_for('settings_page')}}" class="pure-menu-link">SETTINGS</a>
               </li>
               <li class="pure-menu-item">
                 <a href="{{ url_for('import_page')}}" class="pure-menu-link">IMPORT</a>
               </li>
               <li class="pure-menu-item">
                 <a href="{{ url_for('get_backup')}}" class="pure-menu-link">BACKUP</a>
@@ -82,25 +85,22 @@
               <a href="{{url_for('logout')}}" class="pure-menu-link">LOG OUT</a>
             </li>
           {% endif %}
           <li class="pure-menu-item pure-form" id="search-menu-item">
             <!-- We use GET here so it offers people a chance to set bookmarks etc -->
             <form name="searchForm" action="" method="GET">
               <input id="search-q" class="" name="q" placeholder="URL or Title {% if active_tag %}in '{{ active_tag }}'{% endif %}" required="" type="text" value="">
-              <input name="tag" type="hidden" value="{% if active_tag %}{{active_tag}}{% endif %}">
+              <input name="tags" type="hidden" value="{% if active_tag %}{{active_tag}}{% endif %}">
               <button class="toggle-button " id="toggle-search" type="button" title="Search, or Use Alt+S Key" >
                 {% include "svgs/search-icon.svg" %}
               </button>
             </form>
           </li>
           <li class="pure-menu-item">
-            {% if dark_mode %}
-            {% set darkClass = 'dark' %}
-            {% endif %}
-            <button class="toggle-button {{darkClass}}"  id ="toggle-light-mode" type="button" title="Toggle Light/Dark Mode">
+            <button class="toggle-button" id ="toggle-light-mode" type="button" title="Toggle Light/Dark Mode">
               <span class="visually-hidden">Toggle light/dark mode</span>
               <span class="icon-light">
                 {% include "svgs/light-mode-toggle-icon.svg" %}
               </span>
               <span class="icon-dark">
                 {% include "svgs/dark-mode-toggle-icon.svg" %}
               </span>
```

### html2text {}

```diff
@@ -15,28 +15,28 @@
 {% if has_password and not current_user.is_authenticated %} ChangeDetection.io
 {% else %} ChangeDetection.io {% endif %} {% if current_diff_url %} {
 {_current_diff_url_}} {% else %} {% if new_version_available and not
 (has_password and not current_user.is_authenticated) %}  A_new_version_is
 available  {% endif %} {% endif %}
     * {% if current_user.is_authenticated or not has_password %} {% if not
       current_diff_url %}
+    * GROUPS
     * SETTINGS
     * IMPORT
     * BACKUP
     * {% else %}
     * EDIT
     * {% endif %} {% else %}
     * Website_Change_Detection_and_Notification.
     * {% endif %} {% if current_user.is_authenticated %}
     * LOG_OUT
     * {% endif %}
     * [q                   ]   {% include "svgs/search-icon.svg" %}
-    * {% if dark_mode %} {% set darkClass = 'dark' %} {% endif %}  Toggle
-      light/dark mode  {% include "svgs/light-mode-toggle-icon.svg" %}   {%
-      include "svgs/dark-mode-toggle-icon.svg" %}
+    *  Toggle light/dark mode  {% include "svgs/light-mode-toggle-icon.svg" %}
+      {% include "svgs/dark-mode-toggle-icon.svg" %}
     * {%_include_"svgs/github.svg"_%}
 {% if hosted_sticky %}
 Let_us_host_your_instance!
 {% endif %} {% if left_sticky %}
 Show_current_snapshot
 {% endif %} {% if right_sticky %}
 {{ right_sticky }}
```

## changedetectionio/templates/edit.html

```diff
@@ -71,15 +71,15 @@
                         </span>
 
                     </div>
                     <div class="pure-control-group">
                         {{ render_field(form.title, class="m-d") }}
                     </div>
                     <div class="pure-control-group">
-                        {{ render_field(form.tag) }}
+                        {{ render_field(form.tags) }}
                         <span class="pure-form-message-inline">Organisational tag/group name used in the main listing page</span>
                     </div>
                     <div class="pure-control-group">
                         {{ render_field(form.time_between_check, class="time-check-widget") }}
                         {% if has_empty_checktime %}
                         <span class="pure-form-message-inline">Currently using the <a
                                 href="{{ url_for('settings_page', uuid=uuid) }}">default global settings</a>, change to another value if you want to be specific.</span>
```

### html2text {}

```diff
@@ -20,15 +20,15 @@
 You can use variables in the URL, perfect for inserting the current date and
 other logic, help_and_examples_here
  {% if watch['processor'] == 'text_json_diff' %} Current mode: Webpage Text/
 HTML, JSON and PDF changes.
 Switch_to_re-stock_detection_mode. {% else %} Current mode: Re-stock detection.
 Switch_to_Webpage_Text/HTML,_JSON_and_PDF_changes_mode. {% endif %}
 {{ render_field(form.title, class="m-d") }}
-{{ render_field(form.tag) }} Organisational tag/group name used in the main
+{{ render_field(form.tags) }} Organisational tag/group name used in the main
 listing page
 {{ render_field(form.time_between_check, class="time-check-widget") }} {% if
 has_empty_checktime %} Currently using the default_global_settings, change to
 another value if you want to be specific. {% else %} Set to blank to use the
 default_global_settings. {% endif %}
 {{ render_checkbox_field(form.extract_title_as_title) }}
 {{ render_checkbox_field(form.filter_failure_notification_send) }}  Sends a
```

## changedetectionio/templates/watch-overview.html

```diff
@@ -9,15 +9,15 @@
     <form class="pure-form" action="{{ url_for('form_quick_watch_add') }}" method="POST" id="new-watch-form">
         <input type="hidden" name="csrf_token" value="{{ csrf_token() }}" >
         <fieldset>
             <legend>Add a new change detection watch</legend>
             <div id="watch-add-wrapper-zone">
                 <div>
                     {{ render_simple_field(form.url, placeholder="https://...", required=true) }}
-                    {{ render_simple_field(form.tag, value=active_tag if active_tag else '', placeholder="watch label / tag") }}
+                    {{ render_simple_field(form.tags, value=tags[active_tag].title if active_tag else '', placeholder="watch label / tag") }}
                 </div>
                 <div>
                     {{ render_simple_field(form.watch_submit_button, title="Watch this URL!" ) }}
                     {{ render_simple_field(form.edit_and_watch_submit_button, title="Edit first then Watch") }}
                 </div>
             </div>
             <div id="quick-watch-processor-type">
@@ -26,34 +26,36 @@
 
         </fieldset>
         <span style="color:#eee; font-size: 80%;"><img alt="Create a shareable link" style="height: 1em;display:inline-block;" src="{{url_for('static_content', group='images', filename='spread-white.svg')}}" > Tip: You can also add 'shared' watches. <a href="https://github.com/dgtlmoon/changedetection.io/wiki/Sharing-a-Watch">More info</a></span>
     </form>
 
     <form class="pure-form" action="{{ url_for('form_watch_list_checkbox_operations') }}" method="POST" id="watch-list-form">
     <input type="hidden" name="csrf_token" value="{{ csrf_token() }}" >
+    <input type="hidden" id="op_extradata" name="op_extradata" value="" >
     <div id="checkbox-operations">
         <button class="pure-button button-secondary button-xsmall"  name="op" value="pause">Pause</button>
         <button class="pure-button button-secondary button-xsmall"  name="op" value="unpause">UnPause</button>
         <button class="pure-button button-secondary button-xsmall"  name="op" value="mute">Mute</button>
         <button class="pure-button button-secondary button-xsmall"  name="op" value="unmute">UnMute</button>
         <button class="pure-button button-secondary button-xsmall" name="op" value="recheck">Recheck</button>
+        <button class="pure-button button-secondary button-xsmall" name="op" value="assign-tag" id="checkbox-assign-tag">Tag</button>
         <button class="pure-button button-secondary button-xsmall" name="op" value="mark-viewed">Mark viewed</button>
         <button class="pure-button button-secondary button-xsmall" name="op" value="notification-default">Use default notification</button>
         <button class="pure-button button-secondary button-xsmall" style="background: #dd4242;" name="op" value="clear-history">Clear/reset history</button>
         <button class="pure-button button-secondary button-xsmall" style="background: #dd4242;" name="op" value="delete">Delete</button>
     </div>
     {% if watches|length >= pagination.per_page %}
         {{ pagination.info }}
     {% endif %}
     {% if search_q %}<div id="search-result-info">Searching "<strong><i>{{search_q}}</i></strong>"</div>{% endif %}
     <div>
         <a href="{{url_for('index')}}" class="pure-button button-tag {{'active' if not active_tag }}">All</a>
-        {% for tag in tags %}
+        {% for uuid, tag in tags.items() %}
             {% if tag != "" %}
-                <a href="{{url_for('index', tag=tag) }}" class="pure-button button-tag {{'active' if active_tag == tag }}">{{ tag }}</a>
+                <a href="{{url_for('index', tag=uuid) }}" class="pure-button button-tag {{'active' if active_tag == uuid }}">{{ tag.title }}</a>
             {% endif %}
         {% endfor %}
     </div>
 
     {% set sort_order = sort_order or 'asc' %}
     {% set sort_attribute = sort_attribute or 'last_changed'  %}
     {% set pagination_page = request.args.get('page', 0) %}
@@ -139,17 +141,19 @@
                             {% if watch['in_stock'] %} In stock {% else %} Not in stock {% endif %}
                         {% else %}
                             Not yet checked
                         {% endif %}
                     </span>
                     {% endif %}
 
-                    {% if not active_tag %}
-                    <span class="watch-tag-list">{{ watch.tag}}</span>
-                    {% endif %}
+
+                    {% for watch_tag_uuid, watch_tag in datastore.get_all_tags_for_watch(watch['uuid']).items() %}
+                      <span class="watch-tag-list">{{ watch_tag.title }}</span>
+                    {% endfor %}
+
                 </td>
                 <td class="last-checked">{{watch|format_last_checked_time|safe}}</td>
                 <td class="last-changed">{% if watch.history_n >=2 and watch.last_changed >0 %}
                     {{watch.last_changed|format_timestamp_timeago}}
                     {% else %}
                     Not yet
                     {% endif %}
@@ -174,15 +178,15 @@
             {% if has_unviewed %}
             <li>
                 <a href="{{url_for('mark_all_viewed', tag=request.args.get('tag')) }}" class="pure-button button-tag ">Mark all viewed</a>
             </li>
             {% endif %}
             <li>
                <a href="{{ url_for('form_watch_checknow', tag=active_tag) }}" class="pure-button button-tag ">Recheck
-                all {% if active_tag%}in "{{active_tag}}"{%endif%}</a>
+                all {% if active_tag%} in "{{tags[active_tag].title}}"{%endif%}</a>
             </li>
             <li>
                 <a href="{{ url_for('rss', tag=active_tag , token=app_rss_token)}}"><img alt="RSS Feed" id="feed-icon" src="{{url_for('static_content', group='images', filename='Generic_Feed-icon.svg')}}" height="15"></a>
             </li>
         </ul>
         {{ pagination.links }}
     </div>
```

### html2text {}

```diff
@@ -1,55 +1,57 @@
 {% extends 'base.html' %} {% block content %} {% from '_helpers.jinja' import
 render_simple_field, render_field %}
   Add a new change detection watch
 {{ render_simple_field(form.url, placeholder="https://...", required=true) }} {
-{ render_simple_field(form.tag, value=active_tag if active_tag else '',
-placeholder="watch label / tag") }}
+{ render_simple_field(form.tags, value=tags[active_tag].title if active_tag
+else '', placeholder="watch label / tag") }}
 {{ render_simple_field(form.watch_submit_button, title="Watch this URL!" ) }} {
 { render_simple_field(form.edit_and_watch_submit_button, title="Edit first then
 Watch") }}
 {{ render_simple_field(form.processor, title="Edit first then Watch") }}
  [Create a shareable link] Tip: You can also add 'shared' watches. More_info
-Pause UnPause Mute UnMute Recheck Mark viewed Use default notification Clear/
-reset history Delete
+
+Pause UnPause Mute UnMute Recheck Tag Mark viewed Use default notification
+Clear/reset history Delete
 {% if watches|length >= pagination.per_page %} {{ pagination.info }} {% endif
 %} {% if search_q %}
 Searching "{{search_q}}"
 {% endif %}
-All {% for tag in tags %} {% if tag != "" %} {{_tag_}} {% endif %} {% endfor %}
+All {% for uuid, tag in tags.items() %} {% if tag != "" %} {{_tag.title_}} {%
+endif %} {% endfor %}
 {% set sort_order = sort_order or 'asc' %} {% set sort_attribute =
 sort_attribute or 'last_changed' %} {% set pagination_page = request.args.get
 ('page', 0) %}
  #                                            Website                                                                     Last_Checked                           Last_Changed
 No website watches configured, please add a URL in the box above, or import_a_list.
-                                                                                                                                                                                                                   % if watch.uuid in
-                                                 {{watch.title if watch.title is not none and watch.title|length > 0 else                                                                                          queued_uuids
-                                                 watch.url}}  [{{url_for('static_content',_group='images',                                                                                                         %}disabled="true"{%
-                                                 filename='spread.svg')}}] {% if watch.get_fetch_backend == "html_webdriver"                                                                                       endif %} href="{
-                                                 or ( watch.get_fetch_backend == "system" and system_default_fetcher ==                                                                                            { url_for
-                                                 'html_webdriver' ) %} [{{url_for('static_content', group='images',                                                                                                ('form_watch_checknow',
-                                                 filename='Google-Chrome-icon.png')}}] {% endif %} {%if watch.is_pdf %}[{                                                                                          uuid=watch.uuid,
-                                                 {url_for('static_content', group='images', filename='pdf-icon.svg')}}]{%                                                                                          tag=request.args.get
-                                  {% if not      endif %} {% if watch.last_error is defined and watch.last_error != False %}                                                                                       ('tag')) }}"
-                                  watch.paused   {{ watch.last_error }} {% if '403' in watch.last_error %} {% if has_proxies                                                                                       class="recheck pure-
-                                  %} [Pause      %} Try_other_proxies/location {% endif %} Try_adding_external_proxies/                                           {% if watch.history_n >=2 and                  button pure-button-
- {{ loop.index+pagination.skip checks] {%     locations {% endif %}                                                       {                                      watch.last_changed >0 %} {                     primary">{% if
-}}                                else %}        {% endif %} {% if watch.last_notification_error is defined and              {watch|format_last_checked_time|safe}} {watch.last_changed|format_timestamp_timeago}} watch.uuid in
-                                  [UnPause       watch.last_notification_error != False %}                                                                          {% else %} Not yet {% endif %}                 queued_uuids %}Queued{%
-                                  checks] {%     {{_watch.last_notification_error_}}                                                                                                                               else %}Recheck{% endif
-                                  endif %} [Mute {% endif %} {% if watch['processor'] == 'text_json_diff' %} {% if watch                                                                                           %}
-                                  notifications] ['has_ldjson_price_data'] and not watch['track_ldjson_price_data'] %}                                                                                              Edit {% if
-                                                 Embedded price data detected, follow only price data? Yes No                                                                                                      watch.history_n >= 2 %}
-                                                 {% endif %} {% if watch['track_ldjson_price_data'] == 'accepted' %} [{                                                                                            Diff {% else %} {% if
-                                                 {url_for('static_content', group='images', filename='price-tag-                                                                                                   watch.history_n == 1 or
-                                                 icon.svg')}}] Price {% endif %} {% endif %} {% if watch['processor'] ==                                                                                           (watch.history_n ==0
-                                                 'restock_diff' %}   {% if watch['last_checked'] %} {% if watch['in_stock']                                                                                        and
-                                                 %} In stock {% else %} Not in stock {% endif %} {% else %} Not yet checked                                                                                        watch.error_text_ctime
-                                                 {% endif %}  {% endif %} {% if not active_tag %} {{ watch.tag}} {% endif %}                                                                                       )%} Preview {% endif %}
-                                                                                                                                                                                                                   {% endif %}
+                                                 {{watch.title if watch.title is not none and watch.title|length > 0 else                                                                                          % if watch.uuid in
+                                                 watch.url}}  [{{url_for('static_content',_group='images',                                                                                                         queued_uuids
+                                                 filename='spread.svg')}}] {% if watch.get_fetch_backend == "html_webdriver"                                                                                       %}disabled="true"{%
+                                                 or ( watch.get_fetch_backend == "system" and system_default_fetcher ==                                                                                            endif %} href="{
+                                                 'html_webdriver' ) %} [{{url_for('static_content', group='images',                                                                                                { url_for
+                                                 filename='Google-Chrome-icon.png')}}] {% endif %} {%if watch.is_pdf %}[{                                                                                          ('form_watch_checknow',
+                                                 {url_for('static_content', group='images', filename='pdf-icon.svg')}}]{%                                                                                          uuid=watch.uuid,
+                                                 endif %} {% if watch.last_error is defined and watch.last_error != False %}                                                                                       tag=request.args.get
+                                  {% if not      {{ watch.last_error }} {% if '403' in watch.last_error %} {% if has_proxies                                                                                       ('tag')) }}"
+                                  watch.paused   %} Try_other_proxies/location {% endif %} Try_adding_external_proxies/                                                                                          class="recheck pure-
+                                  %} [Pause      locations {% endif %}                                                                                              {% if watch.history_n >=2 and                  button pure-button-
+ {{ loop.index+pagination.skip checks] {%     {% endif %} {% if watch.last_notification_error is defined and              {                                      watch.last_changed >0 %} {                     primary">{% if
+}}                                else %}        watch.last_notification_error != False %}                                   {watch|format_last_checked_time|safe}} {watch.last_changed|format_timestamp_timeago}} watch.uuid in
+                                  [UnPause       {{_watch.last_notification_error_}}                                                                                {% else %} Not yet {% endif %}                 queued_uuids %}Queued{%
+                                  checks] {%     {% endif %} {% if watch['processor'] == 'text_json_diff' %} {% if watch                                                                                           else %}Recheck{% endif
+                                  endif %} [Mute ['has_ldjson_price_data'] and not watch['track_ldjson_price_data'] %}                                                                                             %}
+                                  notifications] Embedded price data detected, follow only price data? Yes No                                                                                                       Edit {% if
+                                                 {% endif %} {% if watch['track_ldjson_price_data'] == 'accepted' %} [{                                                                                            watch.history_n >= 2 %}
+                                                 {url_for('static_content', group='images', filename='price-tag-                                                                                                   Diff {% else %} {% if
+                                                 icon.svg')}}] Price {% endif %} {% endif %} {% if watch['processor'] ==                                                                                           watch.history_n == 1 or
+                                                 'restock_diff' %}   {% if watch['last_checked'] %} {% if watch['in_stock']                                                                                        (watch.history_n ==0
+                                                 %} In stock {% else %} Not in stock {% endif %} {% else %} Not yet checked                                                                                        and
+                                                 {% endif %}  {% endif %} {% for watch_tag_uuid, watch_tag in                                                                                                      watch.error_text_ctime
+                                                 datastore.get_all_tags_for_watch(watch['uuid']).items() %} {                                                                                                      )%} Preview {% endif %}
+                                                 { watch_tag.title }} {% endfor %}                                                                                                                                 {% endif %}
     * {% if has_unviewed %}
     * Mark_all_viewed
     * {% endif %}
-    * Recheck_all_{%_if_active_tag%}in_"{{active_tag}}"{%endif%}
+    * Recheck_all_{%_if_active_tag%}_in_"{{tags[active_tag].title}}"{%endif%}
     * [RSS_Feed]
 {{ pagination.links }}
 {% endblock %}
```

## changedetectionio/tests/test_access_control.py

```diff
@@ -41,14 +41,23 @@
         # Should be logged out
         assert b"Login" in res.data
 
         # The diff page should return something valid when logged out
         res = client.get(url_for("diff_history_page", uuid="first"))
         assert b'Random content' in res.data
 
+        # Check wrong password does not let us in
+        res = c.post(
+            url_for("login"),
+            data={"password": "WRONG PASSWORD"},
+            follow_redirects=True
+        )
+
+        assert b"LOG OUT" not in res.data
+        assert b"Incorrect password" in res.data
 
 
         # Menu should not be available yet
         #        assert b"SETTINGS" not in res.data
         #        assert b"BACKUP" not in res.data
         #        assert b"IMPORT" not in res.data
```

## changedetectionio/tests/test_add_replace_remove_filter.py

```diff
@@ -1,12 +1,12 @@
 #!/usr/bin/python3
 
 import time
 from flask import url_for
-from .util import live_server_setup
+from .util import live_server_setup, wait_for_all_checks
 from changedetectionio import html_tools
 
 
 def set_original(excluding=None, add_line=None):
     test_return_data = """<html>
      <body>
      <p>Some initial text</p>
@@ -35,82 +35,80 @@
     with open("test-datastore/endpoint-content.txt", "w") as f:
         f.write(test_return_data)
 
 def test_setup(client, live_server):
     live_server_setup(live_server)
 
 def test_check_removed_line_contains_trigger(client, live_server):
-    sleep_time_for_fetch_thread = 3
 
     # Give the endpoint time to spin up
     time.sleep(1)
     set_original()
     # Add our URL to the import page
     test_url = url_for('test_endpoint', _external=True)
     res = client.post(
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={"trigger_text": 'The golden line',
               "url": test_url,
               'fetch_backend': "html_requests",
               'filter_text_removed': 'y'},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
     set_original(excluding='Something irrelevant')
 
     # A line thats not the trigger should not trigger anything
     res = client.get(url_for("form_watch_checknow"), follow_redirects=True)
     assert b'1 watches queued for rechecking.' in res.data
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
     res = client.get(url_for("index"))
     assert b'unviewed' not in res.data
 
     # The trigger line is REMOVED,  this should trigger
     set_original(excluding='The golden line')
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
     res = client.get(url_for("index"))
     assert b'unviewed' in res.data
 
 
     # Now add it back, and we should not get a trigger
     client.get(url_for("mark_all_viewed"), follow_redirects=True)
     set_original(excluding=None)
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
     res = client.get(url_for("index"))
     assert b'unviewed' not in res.data
 
     # Remove it again, and we should get a trigger
     set_original(excluding='The golden line')
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
     res = client.get(url_for("index"))
     assert b'unviewed' in res.data
 
     res = client.get(url_for("form_delete", uuid="all"), follow_redirects=True)
     assert b'Deleted' in res.data
 
 
 def test_check_add_line_contains_trigger(client, live_server):
-
-    sleep_time_for_fetch_thread = 3
+    #live_server_setup(live_server)
 
     # Give the endpoint time to spin up
     time.sleep(1)
     test_notification_url = url_for('test_notification_endpoint', _external=True).replace('http://', 'post://') + "?xxx={{ watch_url }}"
 
     res = client.post(
         url_for("settings_page"),
@@ -132,45 +130,46 @@
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
-
+    wait_for_all_checks(client)
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={"trigger_text": 'Oh yes please',
               "url": test_url,
               'fetch_backend': "html_requests",
               'filter_text_removed': '',
               'filter_text_added': 'y'},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
     set_original(excluding='Something irrelevant')
 
     # A line thats not the trigger should not trigger anything
     res = client.get(url_for("form_watch_checknow"), follow_redirects=True)
     assert b'1 watches queued for rechecking.' in res.data
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
     res = client.get(url_for("index"))
     assert b'unviewed' not in res.data
 
     # The trigger line is ADDED,  this should trigger
     set_original(add_line='<p>Oh yes please</p>')
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
     res = client.get(url_for("index"))
     assert b'unviewed' in res.data
 
+    # Takes a moment for apprise to fire
+    time.sleep(3)
     with open("test-datastore/notification.txt", 'r') as f:
         response= f.read()
         assert '-Oh yes please-' in response
 
 
     res = client.get(url_for("form_delete", uuid="all"), follow_redirects=True)
     assert b'Deleted' in res.data
```

## changedetectionio/tests/test_api.py

```diff
@@ -1,12 +1,12 @@
 #!/usr/bin/python3
 
 import time
 from flask import url_for
-from .util import live_server_setup, extract_api_key_from_UI
+from .util import live_server_setup, extract_api_key_from_UI, wait_for_all_checks
 
 import json
 import uuid
 
 
 def set_original_response():
     test_return_data = """<html>
@@ -53,14 +53,15 @@
         return False
 
 
 def test_setup(client, live_server):
     live_server_setup(live_server)
 
 def test_api_simple(client, live_server):
+    #live_server_setup(live_server)
 
     api_key = extract_api_key_from_UI(client)
 
     # Create a watch
     set_original_response()
 
     # Validate bad URL
@@ -82,15 +83,15 @@
         follow_redirects=True
     )
 
     assert is_valid_uuid(res.json.get('uuid'))
     watch_uuid = res.json.get('uuid')
     assert res.status_code == 201
 
-    time.sleep(3)
+    wait_for_all_checks(client)
 
     # Verify its in the list and that recheck worked
     res = client.get(
         url_for("createwatch", tag="OnE"),
         headers={'x-api-key': api_key}
     )
     assert watch_uuid in res.json.keys()
@@ -103,23 +104,23 @@
     # Check the limit by tag doesnt return anything when nothing found
     res = client.get(
         url_for("createwatch", tag="Something else entirely"),
         headers={'x-api-key': api_key}
     )
     assert len(res.json) == 0
 
-    time.sleep(2)
+    wait_for_all_checks(client)
 
     set_modified_response()
     # Trigger recheck of all ?recheck_all=1
     client.get(
         url_for("createwatch", recheck_all='1'),
         headers={'x-api-key': api_key},
     )
-    time.sleep(3)
+    wait_for_all_checks(client)
 
     # Did the recheck fire?
     res = client.get(
         url_for("createwatch"),
         headers={'x-api-key': api_key},
     )
     after_recheck_info = res.json[watch_uuid]
@@ -262,15 +263,15 @@
     )
     assert b"Settings updated." in res.data
 
 def test_api_watch_PUT_update(client, live_server):
 
     #live_server_setup(live_server)
     api_key = extract_api_key_from_UI(client)
-    time.sleep(1)
+
     # Create a watch
     set_original_response()
     test_url = url_for('test_endpoint', _external=True,
                        headers={'x-api-key': api_key}, )
 
     # Create new
     res = client.post(
@@ -278,29 +279,30 @@
         data=json.dumps({"url": test_url, 'tag': "One, Two", "title": "My test URL", 'headers': {'cookie': 'yum'} }),
         headers={'content-type': 'application/json', 'x-api-key': api_key},
         follow_redirects=True
     )
 
     assert res.status_code == 201
 
-    time.sleep(1)
 
     # Get a listing, it will be the first one
     res = client.get(
         url_for("createwatch"),
         headers={'x-api-key': api_key}
     )
 
     watch_uuid = list(res.json.keys())[0]
 
     # Check in the edit page just to be sure
     res = client.get(
         url_for("edit_page", uuid=watch_uuid),
     )
     assert b"cookie: yum" in res.data, "'cookie: yum' found in 'headers' section"
+    assert b"One" in res.data, "Tag 'One' was found"
+    assert b"Two" in res.data, "Tag 'Two' was found"
 
     # HTTP PUT ( UPDATE an existing watch )
     res = client.put(
         url_for("watch", uuid=watch_uuid),
         headers={'x-api-key': api_key, 'content-type': 'application/json'},
         data=json.dumps({"title": "new title", 'time_between_check': {'minutes': 552}, 'headers': {'cookie': 'all eaten'}}),
     )
@@ -315,15 +317,16 @@
 
     # Check in the edit page just to be sure
     res = client.get(
         url_for("edit_page", uuid=watch_uuid),
     )
     assert b"new title" in res.data, "new title found in edit page"
     assert b"552" in res.data, "552 minutes found in edit page"
-    assert b"One, Two" in res.data, "Tag 'One, Two' was found"
+    assert b"One" in res.data, "Tag 'One' was found"
+    assert b"Two" in res.data, "Tag 'Two' was found"
     assert b"cookie: all eaten" in res.data, "'cookie: all eaten' found in 'headers' section"
 
     ######################################################
 
     # HTTP PUT try a field that doenst exist
 
     # HTTP PUT an update
```

## changedetectionio/tests/test_auth.py

```diff
@@ -20,15 +20,15 @@
     )
     assert b"1 Imported" in res.data
     time.sleep(1)
 
     # Check form validation
     res = client.post(
         url_for("edit_page", uuid="first"),
-        data={"include_filters": "", "url": test_url, "tag": "", "headers": "", 'fetch_backend': "html_requests"},
+        data={"include_filters": "", "url": test_url, "tags": "", "headers": "", 'fetch_backend': "html_requests"},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
 
     time.sleep(1)
     res = client.get(
         url_for("preview_page", uuid="first"),
```

## changedetectionio/tests/test_block_while_text_present.py

```diff
@@ -1,12 +1,12 @@
 #!/usr/bin/python3
 
 import time
 from flask import url_for
-from . util import live_server_setup
+from .util import live_server_setup, wait_for_all_checks
 from changedetectionio import html_tools
 
 def set_original_ignore_response():
     test_return_data = """<html>
        <body>
      Some initial text<br>
      <p>Which is across multiple lines</p>
@@ -57,15 +57,15 @@
     """
 
     with open("test-datastore/endpoint-content.txt", "w") as f:
         f.write(test_return_data)
 
 
 def test_check_block_changedetection_text_NOT_present(client, live_server):
-    sleep_time_for_fetch_thread = 3
+
     live_server_setup(live_server)
     # Use a mix of case in ZzZ to prove it works case-insensitive.
     ignore_text = "out of stoCk\r\nfoobar"
 
     set_original_ignore_response()
 
     # Give the endpoint time to spin up
@@ -77,63 +77,63 @@
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={"text_should_not_be_present": ignore_text,
               "url": test_url,
               'fetch_backend': "html_requests"
               },
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
 
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
     # Check it saved
     res = client.get(
         url_for("edit_page", uuid="first"),
     )
     assert bytes(ignore_text.encode('utf-8')) in res.data
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
 
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     # It should report nothing found (no new 'unviewed' class)
     res = client.get(url_for("index"))
     assert b'unviewed' not in res.data
     assert b'/test-endpoint' in res.data
 
     # The page changed, BUT the text is still there, just the rest of it changes, we should not see a change
     set_modified_original_ignore_response()
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     # It should report nothing found (no new 'unviewed' class)
     res = client.get(url_for("index"))
     assert b'unviewed' not in res.data
     assert b'/test-endpoint' in res.data
 
 
     # Now we set a change where the text is gone, it should now trigger
     set_modified_response_minus_block_text()
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
     res = client.get(url_for("index"))
     assert b'unviewed' in res.data
 
     res = client.get(url_for("form_delete", uuid="all"), follow_redirects=True)
     assert b'Deleted' in res.data
```

## changedetectionio/tests/test_css_selector.py

```diff
@@ -92,15 +92,15 @@
     # Give the thread time to pick it up
     time.sleep(sleep_time_for_fetch_thread)
 
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
-        data={"include_filters": include_filters, "url": test_url, "tag": "", "headers": "", 'fetch_backend': "html_requests"},
+        data={"include_filters": include_filters, "url": test_url, "tags": "", "headers": "", 'fetch_backend': "html_requests"},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
     time.sleep(1)
     # Check it saved
     res = client.get(
         url_for("edit_page", uuid="first"),
@@ -153,15 +153,15 @@
 
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={"include_filters": include_filters,
               "url": test_url,
-              "tag": "",
+              "tags": "",
               "headers": "",
               'fetch_backend': "html_requests"},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
 
     # Give the thread time to pick it up
```

## changedetectionio/tests/test_element_removal.py

```diff
@@ -125,15 +125,15 @@
     # Not sure why \r needs to be added - absent of the #changetext this is not necessary
     subtractive_selectors_data = "header\r\nfooter\r\nnav\r\n#changetext"
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={
             "subtractive_selectors": subtractive_selectors_data,
             "url": test_url,
-            "tag": "",
+            "tags": "",
             "headers": "",
             "fetch_backend": "html_requests",
         },
         follow_redirects=True,
     )
     assert b"Updated watch." in res.data
```

## changedetectionio/tests/test_extract_regex.py

```diff
@@ -87,15 +87,15 @@
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={"include_filters": '',
               'extract_text': '/something.+?6 billion.+?lines/si',
               "url": test_url,
-              "tag": "",
+              "tags": "",
               "headers": "",
               'fetch_backend': "html_requests"
               },
         follow_redirects=True
     )
 
     assert b"Updated watch." in res.data
@@ -142,15 +142,15 @@
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={"include_filters": include_filters,
               'extract_text': '\d+ online\r\n\d+ guests\r\n/somecase insensitive \d+/i\r\n/somecase insensitive (345\d)/i',
               "url": test_url,
-              "tag": "",
+              "tags": "",
               "headers": "",
               'fetch_backend': "html_requests"
               },
         follow_redirects=True
     )
 
     assert b"Updated watch." in res.data
```

## changedetectionio/tests/test_filter_exist_changes.py

```diff
@@ -52,15 +52,15 @@
     time.sleep(1)
     set_response_without_filter()
 
     # Add our URL to the import page
     test_url = url_for('test_endpoint', _external=True)
     res = client.post(
         url_for("form_quick_watch_add"),
-        data={"url": test_url, "tag": 'cinema'},
+        data={"url": test_url, "tags": 'cinema'},
         follow_redirects=True
     )
     assert b"Watch added" in res.data
 
     # Give the thread time to pick up the first version
     time.sleep(3)
 
@@ -85,15 +85,15 @@
                                                    "Diff: {{diff}}\n"
                                                    "Diff Full: {{diff_full}}\n"
                                                    ":-)",
                               "notification_format": "Text"}
 
     notification_form_data.update({
         "url": test_url,
-        "tag": "my tag",
+        "tags": "my tag",
         "title": "my title",
         "headers": "",
         "include_filters": '.ticket-available',
         "fetch_backend": "html_requests"})
 
     res = client.post(
         url_for("edit_page", uuid="first"),
```

## changedetectionio/tests/test_filter_failure_notification.py

```diff
@@ -1,11 +1,11 @@
 import os
 import time
 from flask import url_for
-from .util import set_original_response, live_server_setup, extract_UUID_from_client
+from .util import set_original_response, live_server_setup, extract_UUID_from_client, wait_for_all_checks
 from changedetectionio.model import App
 
 
 def set_response_with_filter():
     test_return_data = """<html>
        <body>
      Some initial text<br>
@@ -33,22 +33,22 @@
     if os.path.isfile("test-datastore/notification.txt"):
         os.unlink("test-datastore/notification.txt")
 
     # Add our URL to the import page
     test_url = url_for('test_endpoint', _external=True)
     res = client.post(
         url_for("form_quick_watch_add"),
-        data={"url": test_url, "tag": ''},
+        data={"url": test_url, "tags": ''},
         follow_redirects=True
     )
 
     assert b"Watch added" in res.data
 
     # Give the thread time to pick up the first version
-    time.sleep(3)
+    wait_for_all_checks(client)
 
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     url = url_for('test_notification_endpoint', _external=True)
     notification_url = url.replace('http', 'json')
 
     print(">>>> Notification URL: " + notification_url)
@@ -67,65 +67,77 @@
                                                    "Diff: {{diff}}\n"
                                                    "Diff Full: {{diff_full}}\n"
                                                    ":-)",
                               "notification_format": "Text"}
 
     notification_form_data.update({
         "url": test_url,
-        "tag": "my tag",
-        "title": "my title",
+        "tags": "my tag",
+        "title": "my title 123",
         "headers": "",
         "filter_failure_notification_send": 'y',
         "include_filters": content_filter,
         "fetch_backend": "html_requests"})
 
     res = client.post(
         url_for("edit_page", uuid="first"),
         data=notification_form_data,
         follow_redirects=True
     )
 
     assert b"Updated watch." in res.data
-    time.sleep(3)
+    wait_for_all_checks(client)
 
     # Now the notification should not exist, because we didnt reach the threshold
     assert not os.path.isfile("test-datastore/notification.txt")
 
-    for i in range(0, App._FILTER_FAILURE_THRESHOLD_ATTEMPTS_DEFAULT):
+    # -2 because we would have checked twice above (on adding and on edit)
+    for i in range(0, App._FILTER_FAILURE_THRESHOLD_ATTEMPTS_DEFAULT-2):
         res = client.get(url_for("form_watch_checknow"), follow_redirects=True)
-        time.sleep(3)
+        wait_for_all_checks(client)
+        assert not os.path.isfile("test-datastore/notification.txt"), f"test-datastore/notification.txt should not exist - Attempt {i}"
 
     # We should see something in the frontend
     assert b'Warning, no filters were found' in res.data
 
+    # One more check should trigger it (see -2 above)
+    client.get(url_for("form_watch_checknow"), follow_redirects=True)
+    wait_for_all_checks(client)
+    client.get(url_for("form_watch_checknow"), follow_redirects=True)
+    wait_for_all_checks(client)
     # Now it should exist and contain our "filter not found" alert
     assert os.path.isfile("test-datastore/notification.txt")
-    notification = False
+
     with open("test-datastore/notification.txt", 'r') as f:
         notification = f.read()
+
     assert 'CSS/xPath filter was not present in the page' in notification
     assert content_filter.replace('"', '\\"') in notification
 
-    # Remove it and prove that it doesnt trigger when not expected
+    # Remove it and prove that it doesn't trigger when not expected
+    # It should register a change, but no 'filter not found'
     os.unlink("test-datastore/notification.txt")
     set_response_with_filter()
 
+    # Try several times, it should NOT have 'filter not found'
     for i in range(0, App._FILTER_FAILURE_THRESHOLD_ATTEMPTS_DEFAULT):
         client.get(url_for("form_watch_checknow"), follow_redirects=True)
-        time.sleep(3)
+        wait_for_all_checks(client)
 
     # It should have sent a notification, but..
     assert os.path.isfile("test-datastore/notification.txt")
-    # but it should not contain the info about the failed filter
+    # but it should not contain the info about a failed filter (because there was none in this case)
     with open("test-datastore/notification.txt", 'r') as f:
         notification = f.read()
     assert not 'CSS/xPath filter was not present in the page' in notification
 
-    # Re #1247 - All tokens got replaced
+    # Re #1247 - All tokens got replaced correctly in the notification
+    res = client.get(url_for("index"))
     uuid = extract_UUID_from_client(client)
+    # UUID is correct, but notification contains tag uuid as UUIID wtf
     assert uuid in notification
 
     # cleanup for the next
     client.get(
         url_for("form_delete", uuid="all"),
         follow_redirects=True
     )
@@ -133,15 +145,15 @@
 
 
 def test_setup(live_server):
     live_server_setup(live_server)
 
 def test_check_include_filters_failure_notification(client, live_server):
     set_original_response()
-    time.sleep(1)
+    wait_for_all_checks(client)
     run_filter_test(client, '#nope-doesnt-exist')
 
 def test_check_xpath_filter_failure_notification(client, live_server):
     set_original_response()
     time.sleep(1)
     run_filter_test(client, '//*[@id="nope-doesnt-exist"]')
```

## changedetectionio/tests/test_ignore_text.py

```diff
@@ -1,12 +1,12 @@
 #!/usr/bin/python3
 
 import time
 from flask import url_for
-from . util import live_server_setup
+from .util import live_server_setup, wait_for_all_checks
 from changedetectionio import html_tools
 
 def test_setup(live_server):
     live_server_setup(live_server)
 
 # Unit test of the stripper
 # Always we are dealing in utf-8
@@ -80,15 +80,14 @@
     """
 
     with open("test-datastore/endpoint-content.txt", "w") as f:
         f.write(test_return_data)
 
 
 def test_check_ignore_text_functionality(client, live_server):
-    sleep_time_for_fetch_thread = 3
 
     # Use a mix of case in ZzZ to prove it works case-insensitive.
     ignore_text = "XXXXX\r\nYYYYY\r\nzZzZZ\r\nnew ignore stuff"
     set_original_ignore_response()
 
     # Give the endpoint time to spin up
     time.sleep(1)
@@ -99,15 +98,15 @@
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={"ignore_text": ignore_text, "url": test_url, 'fetch_backend': "html_requests"},
         follow_redirects=True
@@ -120,42 +119,42 @@
     )
     assert bytes(ignore_text.encode('utf-8')) in res.data
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
 
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     # It should report nothing found (no new 'unviewed' class)
     res = client.get(url_for("index"))
     assert b'unviewed' not in res.data
     assert b'/test-endpoint' in res.data
 
     #  Make a change
     set_modified_ignore_response()
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     # It should report nothing found (no new 'unviewed' class)
     res = client.get(url_for("index"))
     assert b'unviewed' not in res.data
     assert b'/test-endpoint' in res.data
 
 
 
 
 
     # Just to be sure.. set a regular modified change..
     set_modified_original_ignore_response()
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     res = client.get(url_for("index"))
     assert b'unviewed' in res.data
 
     # Check the preview/highlighter, we should be able to see what we ignored, but it should be highlighted
     # We only introduce the "modified" content that includes what we ignore so we can prove the newest version also displays
     # at /preview
@@ -163,15 +162,14 @@
     # We should be able to see what we ignored
     assert b'<div class="ignored">new ignore stuff' in res.data
 
     res = client.get(url_for("form_delete", uuid="all"), follow_redirects=True)
     assert b'Deleted' in res.data
 
 def test_check_global_ignore_text_functionality(client, live_server):
-    sleep_time_for_fetch_thread = 3
 
     # Give the endpoint time to spin up
     time.sleep(1)
 
     ignore_text = "XXXXX\r\nYYYYY\r\nZZZZZ"
     set_original_ignore_response()
 
@@ -194,15 +192,15 @@
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
 
     # Goto the edit page of the item, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={"ignore_text": "something irrelevent but just to check", "url": test_url, 'fetch_backend': "html_requests"},
@@ -216,15 +214,15 @@
     )
     assert bytes(ignore_text.encode('utf-8')) in res.data
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
 
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     # so that we are sure everything is viewed and in a known 'nothing changed' state
     res = client.get(url_for("diff_history_page", uuid="first"))
 
     # It should report nothing found (no new 'unviewed' class)
     res = client.get(url_for("index"))
     assert b'unviewed' not in res.data
@@ -233,23 +231,23 @@
 
     #  Make a change which includes the ignore text
     set_modified_ignore_response()
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     # It should report nothing found (no new 'unviewed' class)
     res = client.get(url_for("index"))
     assert b'unviewed' not in res.data
     assert b'/test-endpoint' in res.data
 
     # Just to be sure.. set a regular modified change that will trigger it
     set_modified_original_ignore_response()
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
     res = client.get(url_for("index"))
     assert b'unviewed' in res.data
 
     res = client.get(url_for("form_delete", uuid="all"), follow_redirects=True)
     assert b'Deleted' in res.data
```

## changedetectionio/tests/test_ignorestatuscode.py

```diff
@@ -1,12 +1,12 @@
 #!/usr/bin/python3
 
 import time
 from flask import url_for
-from . util import live_server_setup
+from .util import live_server_setup, wait_for_all_checks
 
 
 def test_setup(live_server):
     live_server_setup(live_server)
 
 
 def set_original_response():
@@ -36,15 +36,15 @@
     """
 
     with open("test-datastore/endpoint-content.txt", "w") as f:
         f.write(test_return_data)
 
 
 def test_normal_page_check_works_with_ignore_status_code(client, live_server):
-    sleep_time_for_fetch_thread = 3
+
 
     # Give the endpoint time to spin up
     time.sleep(1)
 
     set_original_response()
 
     # Goto the settings page, add our ignore text
@@ -64,23 +64,23 @@
     res = client.post(
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     set_some_changed_response()
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
 
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     # It should report nothing found (no new 'unviewed' class)
     res = client.get(url_for("index"))
     assert b'unviewed' in res.data
     assert b'/test-endpoint' in res.data
 
 
@@ -105,28 +105,28 @@
     # Give the thread time to pick it up
     time.sleep(sleep_time_for_fetch_thread)
 
     # Goto the edit page, check our ignore option
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
-        data={"ignore_status_codes": "y", "url": test_url, "tag": "", "headers": "", 'fetch_backend': "html_requests"},
+        data={"ignore_status_codes": "y", "url": test_url, "tags": "", "headers": "", 'fetch_backend': "html_requests"},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
 
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     #  Make a change
     set_some_changed_response()
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
     # Give the thread time to pick it up
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     # It should have 'unviewed' still
     # Because it should be looking at only that 'sametext' id
     res = client.get(url_for("index"))
     assert b'unviewed' in res.data
```

## changedetectionio/tests/test_import.py

```diff
@@ -108,13 +108,14 @@
     # embedded_d=json.loads(d['data'][0]['config'])
     # x=html.escape(embedded_d['selections'][0]['frames'][0]['includes'][0]['expr']).encode('utf-8')
     assert b"xpath:(//div[@id=&#39;App&#39;]/div[contains(@class,&#39;flex&#39;)]/main[contains(@class,&#39;relative&#39;)]/section[contains(@class,&#39;relative&#39;)]/div[@class=&#39;container&#39;]/div[contains(@class,&#39;flex&#39;)]/div[contains(@class,&#39;w-full&#39;)])[1]" in res.data
 
     # did the tags work?
     res = client.get( url_for("index"))
 
+    # check tags
     assert b"nice stuff" in res.data
     assert b"nerd-news" in res.data
 
     res = client.get(url_for("form_delete", uuid="all"), follow_redirects=True)
     # Clear flask alerts
     res = client.get(url_for("index"))
```

## changedetectionio/tests/test_jinja2.py

```diff
@@ -16,15 +16,15 @@
     test_url = url_for('test_return_query', _external=True)
 
     # because url_for() will URL-encode the var, but we dont here
     full_url = "{}?{}".format(test_url,
                               "date={% now 'Europe/Berlin', '%Y' %}.{% now 'Europe/Berlin', '%m' %}.{% now 'Europe/Berlin', '%d' %}", )
     res = client.post(
         url_for("form_quick_watch_add"),
-        data={"url": full_url, "tag": "test"},
+        data={"url": full_url, "tags": "test"},
         follow_redirects=True
     )
     assert b"Watch added" in res.data
     time.sleep(3)
     # It should report nothing found (no new 'unviewed' class)
     res = client.get(
         url_for("preview_page", uuid="first"),
```

## changedetectionio/tests/test_jsonpath_jq_selector.py

```diff
@@ -204,15 +204,15 @@
     client.post(
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
 
     # Give the thread time to pick it up
-    time.sleep(3)
+    wait_for_all_checks(client)
 
     res = client.get(
         url_for("preview_page", uuid="first"),
         follow_redirects=True
     )
 
     # Should still see '"html": "<b>"'
@@ -234,45 +234,45 @@
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
     # Give the thread time to pick it up
-    time.sleep(3)
+    wait_for_all_checks(client)
 
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={"include_filters": json_filter,
               "url": test_url,
-              "tag": "",
+              "tags": "",
               "headers": "",
               "fetch_backend": "html_requests"
               },
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
 
     # Check it saved
     res = client.get(
         url_for("edit_page", uuid="first"),
     )
     assert bytes(escape(json_filter).encode('utf-8')) in res.data
 
     # Give the thread time to pick it up
-    time.sleep(3)
+    wait_for_all_checks(client)
     #  Make a change
     set_modified_response()
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
     # Give the thread time to pick it up
-    time.sleep(4)
+    wait_for_all_checks(client)
 
     # It should have 'unviewed' still
     res = client.get(url_for("index"))
     assert b'unviewed' in res.data
 
     # Should not see this, because its not in the JSONPath we entered
     res = client.get(url_for("diff_history_page", uuid="first"))
@@ -302,38 +302,38 @@
     res = client.post(
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
-    time.sleep(3)
+    wait_for_all_checks(client)
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={"include_filters": json_filter,
               "url": test_url,
-              "tag": "",
+              "tags": "",
               "headers": "",
               "fetch_backend": "html_requests"
               },
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
 
     # Give the thread time to pick it up
-    time.sleep(3)
+    wait_for_all_checks(client)
     #  Make a change
     set_modified_response()
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
     # Give the thread time to pick it up
-    time.sleep(3)
+    wait_for_all_checks(client)
 
     res = client.get(url_for("diff_history_page", uuid="first"))
     # But the change should be there, tho its hard to test the change was detected because it will show old and new versions
     assert b'false' in res.data
 
     res = client.get(url_for("form_delete", uuid="all"), follow_redirects=True)
     assert b'Deleted' in res.data
@@ -362,45 +362,45 @@
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
     # Give the thread time to pick it up
-    time.sleep(3)
+    wait_for_all_checks(client)
 
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={"include_filters": json_filter,
               "url": test_url,
-              "tag": "",
+              "tags": "",
               "headers": "",
               "fetch_backend": "html_requests"
               },
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
 
     # Check it saved
     res = client.get(
         url_for("edit_page", uuid="first"),
     )
     assert bytes(escape(json_filter).encode('utf-8')) in res.data
 
     # Give the thread time to pick it up
-    time.sleep(3)
+    wait_for_all_checks(client)
     #  Make a change
     set_modified_ext_response()
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
     # Give the thread time to pick it up
-    time.sleep(4)
+    wait_for_all_checks(client)
 
     # It should have 'unviewed'
     res = client.get(url_for("index"))
     assert b'unviewed' in res.data
 
     res = client.get(url_for("diff_history_page", uuid="first"))
 
@@ -424,33 +424,33 @@
     res = client.post(
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
-    time.sleep(2)
+    wait_for_all_checks(client)
 
     with open("test-datastore/endpoint-content.txt", "w") as f:
         f.write('{"world" : 123, "hello": 123}')
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
-    time.sleep(2)
+    wait_for_all_checks(client)
 
     res = client.get(url_for("index"))
     assert b'unviewed' not in res.data
 
     # Just to be sure it still works
     with open("test-datastore/endpoint-content.txt", "w") as f:
         f.write('{"world" : 123, "hello": 124}')
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
-    time.sleep(2)
+    wait_for_all_checks(client)
 
     res = client.get(url_for("index"))
     assert b'unviewed' in res.data
 
     res = client.get(url_for("form_delete", uuid="all"), follow_redirects=True)
     assert b'Deleted' in res.data
```

## changedetectionio/tests/test_notification.py

```diff
@@ -1,13 +1,13 @@
 import json
 import os
 import time
 import re
 from flask import url_for
-from . util import set_original_response, set_modified_response, set_more_modified_response, live_server_setup
+from .util import set_original_response, set_modified_response, set_more_modified_response, live_server_setup, wait_for_all_checks
 from . util import  extract_UUID_from_client
 import logging
 import base64
 
 from changedetectionio.notification import (
     default_notification_body,
     default_notification_format,
@@ -17,19 +17,17 @@
 
 def test_setup(live_server):
     live_server_setup(live_server)
 
 # Hard to just add more live server URLs when one test is already running (I think)
 # So we add our test here (was in a different file)
 def test_check_notification(client, live_server):
+    #live_server_setup(live_server)
     set_original_response()
 
-    # Give the endpoint time to spin up
-    time.sleep(3)
-
     # Re 360 - new install should have defaults set
     res = client.get(url_for("settings_page"))
     notification_url = url_for('test_notification_endpoint', _external=True).replace('http', 'json')
 
     assert default_notification_body.encode() in res.data
     assert default_notification_title.encode() in res.data
 
@@ -58,21 +56,21 @@
         logging.debug(">>> SKIPPING BASE_URL check")
 
     # re #242 - when you edited an existing new entry, it would not correctly show the notification settings
     # Add our URL to the import page
     test_url = url_for('test_endpoint', _external=True)
     res = client.post(
         url_for("form_quick_watch_add"),
-        data={"url": test_url, "tag": ''},
+        data={"url": test_url, "tags": ''},
         follow_redirects=True
     )
     assert b"Watch added" in res.data
 
     # Give the thread time to pick up the first version
-    time.sleep(3)
+    wait_for_all_checks(client)
 
     # We write the PNG to disk, but a JPEG should appear in the notification
     # Write the last screenshot png
     testimage_png = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
 
 
     uuid = extract_UUID_from_client(client)
@@ -101,15 +99,15 @@
                                                    "Diff Full: {{diff_full}}\n"
                                                    ":-)",
                               "notification_screenshot": True,
                               "notification_format": "Text"}
 
     notification_form_data.update({
         "url": test_url,
-        "tag": "my tag",
+        "tags": "my tag, my second tag",
         "title": "my title",
         "headers": "",
         "fetch_backend": "html_requests"})
 
     res = client.post(
         url_for("edit_page", uuid="first"),
         data=notification_form_data,
@@ -124,42 +122,42 @@
         url_for("edit_page", uuid="first"))
     assert bytes(notification_url.encode('utf-8')) in res.data
     assert bytes("New ChangeDetection.io Notification".encode('utf-8')) in res.data
 
 
 
     ## Now recheck, and it should have sent the notification
-    time.sleep(3)
+    wait_for_all_checks(client)
     set_modified_response()
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
     time.sleep(3)
     # Verify what was sent as a notification, this file should exist
     with open("test-datastore/notification.txt", "r") as f:
         notification_submission = f.read()
     os.unlink("test-datastore/notification.txt")
 
     # Did we see the URL that had a change, in the notification?
     # Diff was correctly executed
-    assert test_url in notification_submission
-    assert ':-)' in notification_submission
+
     assert "Diff Full: Some initial text" in notification_submission
     assert "Diff: (changed) Which is across multiple lines" in notification_submission
     assert "(into) which has this one new line" in notification_submission
     # Re #342 - check for accidental python byte encoding of non-utf8/string
     assert "b'" not in notification_submission
     assert re.search('Watch UUID: [0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}', notification_submission, re.IGNORECASE)
     assert "Watch title: my title" in notification_submission
-    assert "Watch tag: my tag" in notification_submission
+    assert "Watch tag: my tag, my second tag" in notification_submission
     assert "diff/" in notification_submission
     assert "preview/" in notification_submission
     assert ":-)" in notification_submission
     assert "New ChangeDetection.io Notification - {}".format(test_url) in notification_submission
-
+    assert test_url in notification_submission
+    assert ':-)' in notification_submission
     # Check the attachment was added, and that it is a JPEG from the original PNG
     notification_submission_object = json.loads(notification_submission)
     # We keep PNG screenshots for now
     assert notification_submission_object['attachments'][0]['filename'] == 'last-screenshot.png'
     assert len(notification_submission_object['attachments'][0]['base64'])
     assert notification_submission_object['attachments'][0]['mimetype'] == 'image/png'
     jpeg_in_attachment = base64.b64decode(notification_submission_object['attachments'][0]['base64'])
@@ -189,31 +187,31 @@
 
     # Prove that "content constantly being marked as Changed with no Updating causes notification" is not a thing
     # https://github.com/dgtlmoon/changedetection.io/discussions/192
     os.unlink("test-datastore/notification.txt")
 
     # Trigger a check
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
-    time.sleep(1)
+    wait_for_all_checks(client)
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
-    time.sleep(1)
+    wait_for_all_checks(client)
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
-    time.sleep(1)
+    wait_for_all_checks(client)
     assert os.path.exists("test-datastore/notification.txt") == False
 
     res = client.get(url_for("notification_logs"))
     # be sure we see it in the output log
     assert b'New ChangeDetection.io Notification - ' + test_url.encode('utf-8') in res.data
 
     set_original_response()
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={
         "url": test_url,
-        "tag": "my tag",
+        "tags": "my tag",
         "title": "my title",
         "notification_urls": '',
         "notification_title": '',
         "notification_body": '',
         "notification_format": default_notification_format,
         "fetch_backend": "html_requests"},
         follow_redirects=True
@@ -239,15 +237,15 @@
     time.sleep(1)
 
     # re #242 - when you edited an existing new entry, it would not correctly show the notification settings
     # Add our URL to the import page
     test_url = url_for('test_endpoint', _external=True)
     res = client.post(
         url_for("form_quick_watch_add"),
-        data={"url": test_url, "tag": 'nice one'},
+        data={"url": test_url, "tags": 'nice one'},
         follow_redirects=True
     )
 
     assert b"Watch added" in res.data
 
     # Re #360 some validation
 #    res = client.post(
@@ -299,21 +297,21 @@
         url_for("form_delete", uuid="all"),
         follow_redirects=True
     )
     # Add a watch and trigger a HTTP POST
     test_url = url_for('test_endpoint', _external=True)
     res = client.post(
         url_for("form_quick_watch_add"),
-        data={"url": test_url, "tag": 'nice one'},
+        data={"url": test_url, "tags": 'nice one'},
         follow_redirects=True
     )
 
     assert b"Watch added" in res.data
 
-    time.sleep(2)
+    wait_for_all_checks(client)
     set_modified_response()
 
     client.get(url_for("form_watch_checknow"), follow_redirects=True)
     time.sleep(2)
 
 
     with open("test-datastore/notification.txt", 'r') as f:
```

## changedetectionio/tests/test_notification_errors.py

```diff
@@ -13,30 +13,30 @@
     # Give the endpoint time to spin up
     time.sleep(2)
 
     # Set a URL and fetch it, then set a notification URL which is going to give errors
     test_url = url_for('test_endpoint', _external=True)
     res = client.post(
         url_for("form_quick_watch_add"),
-        data={"url": test_url, "tag": ''},
+        data={"url": test_url, "tags": ''},
         follow_redirects=True
     )
     assert b"Watch added" in res.data
 
     time.sleep(2)
     set_modified_response()
 
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={"notification_urls": "jsons://broken-url-xxxxxxxx123/test",
               "notification_title": "xxx",
               "notification_body": "xxxxx",
               "notification_format": "Text",
               "url": test_url,
-              "tag": "",
+              "tags": "",
               "title": "",
               "headers": "",
               "time_between_check-minutes": "180",
               "fetch_backend": "html_requests"},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
```

## changedetectionio/tests/test_request.py

```diff
@@ -21,15 +21,15 @@
     res = client.post(
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
-    time.sleep(1)
+    wait_for_all_checks(client)
 
     res = client.post(
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
@@ -39,15 +39,15 @@
 
 
     # Add some headers to a request
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={
               "url": test_url,
-              "tag": "",
+              "tags": "",
               "fetch_backend": 'html_webdriver' if os.getenv('PLAYWRIGHT_DRIVER_URL') else 'html_requests',
               "headers": "xxx:ooo\ncool:yeah\r\ncookie:"+cookie_header},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
 
 
@@ -91,46 +91,46 @@
     res = client.post(
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
-    time.sleep(3)
+    wait_for_all_checks(client)
 
     # add the first 'version'
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={
               "url": test_url,
-              "tag": "",
+              "tags": "",
               "method": "POST",
               "fetch_backend": "html_requests",
               "body": "something something"},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
 
-    time.sleep(3)
+    wait_for_all_checks(client)
 
     # Now the change which should trigger a change
     body_value = 'Test Body Value'
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={
               "url": test_url,
-              "tag": "",
+              "tags": "",
               "method": "POST",
               "fetch_backend": "html_requests",
               "body": body_value},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
 
-    time.sleep(3)
+    wait_for_all_checks(client)
 
     # The service should echo back the body
     res = client.get(
         url_for("preview_page", uuid="first"),
         follow_redirects=True
     )
 
@@ -159,15 +159,15 @@
     assert watches_with_body==1
 
     # Attempt to add a body with a GET method
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={
               "url": test_url,
-              "tag": "",
+              "tags": "",
               "method": "GET",
               "fetch_backend": "html_requests",
               "body": "invalid"},
         follow_redirects=True
     )
     assert b"Body must be empty when Request Method is set to GET" in res.data
 
@@ -183,61 +183,61 @@
     res = client.post(
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
-    time.sleep(2)
+    wait_for_all_checks(client)
     res = client.post(
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
-    time.sleep(2)
+    wait_for_all_checks(client)
 
     # Attempt to add a method which is not valid
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={
             "url": test_url,
-            "tag": "",
+            "tags": "",
             "fetch_backend": "html_requests",
             "method": "invalid"},
         follow_redirects=True
     )
     assert b"Not a valid choice" in res.data
 
     # Add a properly formatted body
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={
             "url": test_url,
-            "tag": "",
+            "tags": "",
             "fetch_backend": "html_requests",
             "method": "PATCH"},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
 
     # Give the thread time to pick up the first version
-    time.sleep(2)
+    wait_for_all_checks(client)
 
     # The service should echo back the request verb
     res = client.get(
         url_for("preview_page", uuid="first"),
         follow_redirects=True
     )
 
     # The test call service will return the verb as the body
     assert b"PATCH" in res.data
 
-    time.sleep(2)
+    wait_for_all_checks(client)
 
     watches_with_method = 0
     with open('test-datastore/url-watches.json') as f:
         app_struct = json.load(f)
         for uuid in app_struct['watching']:
             if app_struct['watching'][uuid]['method'] == 'PATCH':
                 watches_with_method += 1
@@ -261,23 +261,23 @@
     res = client.post(
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
 
-    time.sleep(1)
+    wait_for_all_checks(client)
 
 
     # Add some headers to a request
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={
               "url": test_url,
-              "tag": "testtag",
+              "tags": "testtag",
               "fetch_backend": 'html_webdriver' if os.getenv('PLAYWRIGHT_DRIVER_URL') else 'html_requests',
               "headers": "xxx:ooo\ncool:yeah\r\n"},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
     wait_for_all_checks(client)
```

## changedetectionio/tests/test_security.py

```diff
@@ -14,52 +14,52 @@
     assert b"1 Imported" in res.data
 
     # Attempt to add a body with a GET method
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={
               "url": 'javascript:alert(document.domain)',
-              "tag": "",
+              "tags": "",
               "method": "GET",
               "fetch_backend": "html_requests",
               "body": ""},
         follow_redirects=True
     )
 
     assert b'Watch protocol is not permitted by SAFE_PROTOCOL_REGEX' in res.data
 
     res = client.post(
         url_for("form_quick_watch_add"),
-        data={"url": '            javascript:alert(123)', "tag": ''},
+        data={"url": '            javascript:alert(123)', "tags": ''},
         follow_redirects=True
     )
 
     assert b'Watch protocol is not permitted by SAFE_PROTOCOL_REGEX' in res.data
 
     res = client.post(
         url_for("form_quick_watch_add"),
-        data={"url": '%20%20%20javascript:alert(123)%20%20', "tag": ''},
+        data={"url": '%20%20%20javascript:alert(123)%20%20', "tags": ''},
         follow_redirects=True
     )
 
     assert b'Watch protocol is not permitted by SAFE_PROTOCOL_REGEX' in res.data
 
 
     res = client.post(
         url_for("form_quick_watch_add"),
-        data={"url": ' source:javascript:alert(document.domain)', "tag": ''},
+        data={"url": ' source:javascript:alert(document.domain)', "tags": ''},
         follow_redirects=True
     )
 
     assert b'Watch protocol is not permitted by SAFE_PROTOCOL_REGEX' in res.data
 
     # file:// is permitted by default, but it will be caught by ALLOW_FILE_URI
 
     client.post(
         url_for("form_quick_watch_add"),
-        data={"url": 'file:///tasty/disk/drive', "tag": ''},
+        data={"url": 'file:///tasty/disk/drive', "tags": ''},
         follow_redirects=True
     )
     time.sleep(1)
     res = client.get(url_for("index"))
 
     assert b'file:// type access is denied for security reasons.' in res.data
```

## changedetectionio/tests/test_share_watch.py

```diff
@@ -25,15 +25,15 @@
 
     assert b"1 Imported" in res.data
 
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
-        data={"include_filters": include_filters, "url": test_url, "tag": "", "headers": "", 'fetch_backend': "html_requests"},
+        data={"include_filters": include_filters, "url": test_url, "tags": "", "headers": "", 'fetch_backend': "html_requests"},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
     # Check it saved
     res = client.get(
         url_for("edit_page", uuid="first"),
     )
```

## changedetectionio/tests/test_source.py

```diff
@@ -1,13 +1,13 @@
 #!/usr/bin/python3
 
 import time
 from flask import url_for
 from urllib.request import urlopen
-from .util import set_original_response, set_modified_response, live_server_setup
+from .util import set_original_response, set_modified_response, live_server_setup, wait_for_all_checks
 
 sleep_time_for_fetch_thread = 3
 
 def test_setup(live_server):
     live_server_setup(live_server)
 
 def test_check_basic_change_detection_functionality_source(client, live_server):
@@ -38,15 +38,15 @@
     # Make a change
     set_modified_response()
 
     # Force recheck
     res = client.get(url_for("form_watch_checknow"), follow_redirects=True)
     assert b'1 watches queued for rechecking.' in res.data
 
-    time.sleep(5)
+    wait_for_all_checks(client)
 
     # Now something should be ready, indicated by having a 'unviewed' class
     res = client.get(url_for("index"))
     assert b'unviewed' in res.data
 
     res = client.get(
         url_for("diff_history_page", uuid="first"),
@@ -56,33 +56,33 @@
     assert b'&lt;title&gt;modified head title' in res.data
 
 
 
 # `subtractive_selectors` should still work in `source:` type requests
 def test_check_ignore_elements(client, live_server):
     set_original_response()
-    time.sleep(2)
+    time.sleep(1)
     test_url = 'source:'+url_for('test_endpoint', _external=True)
     # Add our URL to the import page
     res = client.post(
         url_for("import_page"),
         data={"urls": test_url},
         follow_redirects=True
     )
 
     assert b"1 Imported" in res.data
 
-    time.sleep(sleep_time_for_fetch_thread)
+    wait_for_all_checks(client)
 
     #####################
     # We want <span> and <p> ONLY, but ignore span with .foobar-detection
 
     client.post(
         url_for("edit_page", uuid="first"),
-        data={"include_filters": 'span,p', "url": test_url, "tag": "", "subtractive_selectors": ".foobar-detection", 'fetch_backend': "html_requests"},
+        data={"include_filters": 'span,p', "url": test_url, "tags": "", "subtractive_selectors": ".foobar-detection", 'fetch_backend': "html_requests"},
         follow_redirects=True
     )
 
     time.sleep(sleep_time_for_fetch_thread)
 
     res = client.get(
         url_for("preview_page", uuid="first"),
```

## changedetectionio/tests/test_watch_fields_storage.py

```diff
@@ -22,15 +22,15 @@
         url_for("edit_page", uuid="first"),
         data={ "notification_urls": "json://127.0.0.1:30000\r\njson://128.0.0.1\r\n",
                "time_between_check-minutes": 126,
                "include_filters" : ".fooclass",
                "title" : "My title",
                "ignore_text" : "ignore this",
                "url": test_url,
-               "tag": "woohoo",
+               "tags": "woohoo",
                "headers": "curl:foo",
                'fetch_backend': "html_requests"
                },
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
```

## changedetectionio/tests/test_xpath_selector.py

```diff
@@ -85,15 +85,15 @@
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
     time.sleep(1)
     res = client.post(
         url_for("edit_page", uuid="first"),
-        data={"include_filters": filter, "url": test_url, "tag": "", "headers": "", 'fetch_backend': "html_requests"},
+        data={"include_filters": filter, "url": test_url, "tags": "", "headers": "", 'fetch_backend': "html_requests"},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
     time.sleep(3)
     res = client.get(url_for("index"))
     assert b'Unicode strings with encoding declaration are not supported.' not in res.data
     res = client.get(url_for("form_delete", uuid="all"), follow_redirects=True)
@@ -139,15 +139,15 @@
         data={"urls": test_url},
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
     time.sleep(1)
     res = client.post(
         url_for("edit_page", uuid="first"),
-        data={"include_filters": filter, "url": test_url, "tag": "", "headers": "", 'fetch_backend': "html_requests"},
+        data={"include_filters": filter, "url": test_url, "tags": "", "headers": "", 'fetch_backend': "html_requests"},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
     time.sleep(3)
     res = client.get(url_for("index"))
     assert b'Unicode strings with encoding declaration are not supported.' not in res.data
 
@@ -185,15 +185,15 @@
     # Give the thread time to pick it up
     time.sleep(sleep_time_for_fetch_thread)
 
     # Goto the edit page, add our ignore text
     # Add our URL to the import page
     res = client.post(
         url_for("edit_page", uuid="first"),
-        data={"include_filters": xpath_filter, "url": test_url, "tag": "", "headers": "", 'fetch_backend': "html_requests"},
+        data={"include_filters": xpath_filter, "url": test_url, "tags": "", "headers": "", 'fetch_backend': "html_requests"},
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
 
     # Give the thread time to pick it up
     time.sleep(sleep_time_for_fetch_thread)
 
@@ -227,15 +227,15 @@
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
     time.sleep(2)
 
     res = client.post(
         url_for("edit_page", uuid="first"),
-        data={"include_filters": "/something horrible", "url": test_url, "tag": "", "headers": "", 'fetch_backend': "html_requests"},
+        data={"include_filters": "/something horrible", "url": test_url, "tags": "", "headers": "", 'fetch_backend': "html_requests"},
         follow_redirects=True
     )
     assert b"is not a valid XPath expression" in res.data
     res = client.get(url_for("form_delete", uuid="all"), follow_redirects=True)
     assert b'Deleted' in res.data
 
 
@@ -257,15 +257,15 @@
         follow_redirects=True
     )
     assert b"1 Imported" in res.data
     time.sleep(3)
 
     res = client.post(
         url_for("edit_page", uuid="first"),
-        data={"include_filters":  "xpath://*[contains(@class, 'sametext')]", "url": test_url, "tag": "", "headers": "", 'fetch_backend': "html_requests"},
+        data={"include_filters":  "xpath://*[contains(@class, 'sametext')]", "url": test_url, "tags": "", "headers": "", 'fetch_backend': "html_requests"},
         follow_redirects=True
     )
 
     assert b"Updated watch." in res.data
     time.sleep(3)
 
     res = client.get(
```

## changedetectionio/tests/util.py

```diff
@@ -66,14 +66,24 @@
     )
     # <span id="api-key">{{api_key}}</span>
 
     m = re.search('<span id="api-key">(.+?)</span>', str(res.data))
     api_key = m.group(1)
     return api_key.strip()
 
+
+# kinda funky, but works for now
+def get_UUID_for_tag_name(client, name):
+    app_config = client.application.config.get('DATASTORE').data
+    for uuid, tag in app_config['settings']['application'].get('tags', {}).items():
+        if name == tag.get('title', '').lower().strip():
+            return uuid
+    return None
+
+
 # kinda funky, but works for now
 def extract_rss_token_from_UI(client):
     import re
     res = client.get(
         url_for("index"),
     )
     m = re.search('token=(.+?)"', str(res.data))
```

## changedetectionio/tests/proxy_list/test_multiple_proxy.py

```diff
@@ -24,15 +24,15 @@
     res = client.post(
         url_for("edit_page", uuid="first"),
         data={
                 "include_filters": "",
                 "fetch_backend": "html_requests",
                 "headers": "",
                 "proxy": "proxy-two",
-                "tag": "",
+                "tags": "",
                 "url": url,
               },
         follow_redirects=True
     )
     assert b"Updated watch." in res.data
     time.sleep(2)
     # Now the request should appear in the second-squid logs
```

## changedetectionio/tests/restock/test_restock.py

```diff
@@ -73,15 +73,15 @@
     )
     # Add our URL to the import page, because the docker container (playwright/selenium) wont be able to connect to our usual test url
     test_url = url_for('test_endpoint', _external=True).replace('http://localhost', 'http://changedet')
 
 
     client.post(
         url_for("form_quick_watch_add"),
-        data={"url": test_url, "tag": '', 'processor': 'restock_diff'},
+        data={"url": test_url, "tags": '', 'processor': 'restock_diff'},
         follow_redirects=True
     )
 
     # Is it correctly show as NOT in stock?
     wait_for_all_checks(client)
     res = client.get(url_for("index"))
     assert b'not-in-stock' in res.data
```

## changedetectionio/tests/visualselector/test_fetch_data.py

```diff
@@ -15,24 +15,24 @@
 
 
     # Add our URL to the import page, because the docker container (playwright/selenium) wont be able to connect to our usual test url
     test_url = "https://changedetection.io/ci-test/test-runjs.html"
 
     res = client.post(
         url_for("form_quick_watch_add"),
-        data={"url": test_url, "tag": '', 'edit_and_watch_submit_button': 'Edit > Watch'},
+        data={"url": test_url, "tags": '', 'edit_and_watch_submit_button': 'Edit > Watch'},
         follow_redirects=True
     )
     assert b"Watch added in Paused state, saving will unpause" in res.data
 
     res = client.post(
         url_for("edit_page", uuid="first", unpause_on_save=1),
         data={
               "url": test_url,
-              "tag": "",
+              "tags": "",
               "headers": "",
               'fetch_backend': "html_webdriver",
               'webdriver_js_execute_code': 'document.querySelector("button[name=test-button]").click();'
         },
         follow_redirects=True
     )
     assert b"unpaused" in res.data
```

## Comparing `changedetection.io-0.42.3.data/scripts/changedetection.py` & `changedetection.io-0.43.1.data/scripts/changedetection.py`

 * *Files identical despite different names*

## Comparing `changedetection.io-0.42.3.dist-info/LICENSE` & `changedetection.io-0.43.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `changedetection.io-0.42.3.dist-info/METADATA` & `changedetection.io-0.43.1.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: changedetection.io
-Version: 0.42.3
+Version: 0.43.1
 Summary: Website change detection and monitoring service
 Home-page: https://changedetection.io
 Author: dgtlmoon
 License: Apache License 2.0
 Keywords: website change monitor for changes notification change detection alerts tracking website tracker change alert website and monitoring
 Classifier: Intended Audience :: Customer Service
 Classifier: Intended Audience :: Developers
```

## Comparing `changedetection.io-0.42.3.dist-info/RECORD` & `changedetection.io-0.43.1.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,36 +1,42 @@
-changedetection.io-0.42.3.data/scripts/changedetection.py,sha256=YY22uDRAqrejy-nHejf7I9PjFwy275WU0s-7VMDgDCA,1609
-changedetectionio/__init__.py,sha256=8Wa9mQhsqBnsRpMqYvTeLpNRS_N8fGHiqd_RpQfyeFY,70346
+changedetection.io-0.43.1.data/scripts/changedetection.py,sha256=YY22uDRAqrejy-nHejf7I9PjFwy275WU0s-7VMDgDCA,1609
+changedetectionio/__init__.py,sha256=jLLu-uU6lDBe4l0g2bcVqdotSNnQonIfjB7c8368UTQ,71367
 changedetectionio/apprise_asset.py,sha256=R5yQ8k8VB_J7WME5qit8iBQtCB4F657w3cwYjHP3O_M,519
 changedetectionio/changedetection.py,sha256=JXL1IoY3om1SHiNIRA_HArD7wM-1M0vOtjU_jJ-lBiM,5056
 changedetectionio/content_fetcher.py,sha256=E4SLJbtmnXqWrlkAz40xCP0mmiZdd1RDrrbYjQzIzOc,31711
 changedetectionio/diff.py,sha256=dZIc9JUjQ7D2Gt2R2l970DSD_UasiznTlcpSHW7H_W4,2890
-changedetectionio/forms.py,sha256=O6kzD3nSvkbiRqdcMBD1q98TL6-M27s6dpKrnd1nISw,22301
+changedetectionio/forms.py,sha256=pjzuIA9qEMgPOjJZtePUwtKIgB66Rhfzt0sGPExULbQ,23129
 changedetectionio/html_tools.py,sha256=3xP_TxlGLwAyQpNe0OpfDoz8FmcBhV0tygrd5qz9dLc,11235
-changedetectionio/importer.py,sha256=XoSmQm4-UU1eL86YoI3sLgLv_xX2tikeQ4_SoCwYhUE,4491
-changedetectionio/notification.py,sha256=8wEzQ7oL7LM4ndxR1PQawl9brK1Q5YQ1IArgGyB23Rg,9741
+changedetectionio/importer.py,sha256=V-3KHLBBmRrVX0QA6KJ1FtScz8PkQYvq0q-3oE4cJYw,4544
+changedetectionio/notification.py,sha256=lk9iVpibbZZ28DFv8bpnNsw5MtvVTsCksif97zuVmpY,9919
 changedetectionio/queuedWatchMetaData.py,sha256=IS-FHSwxp5M9asO5gUu1t0HjVhBhVd1toqVhEsgr4eg,280
-changedetectionio/store.py,sha256=yNVE0CmpSuJ1d61anCTMdAphNY1LbpsKeY6RJDHm65A,29091
-changedetectionio/update_worker.py,sha256=pC2oJkpGjoDIY96KhstgXO2NvzSlLZWX1-KHPut1KLE,22972
+changedetectionio/store.py,sha256=FZmNfDjM3T7ye66A5tJNhrqxQj-bmegFb6d7e_IZqJ0,32711
+changedetectionio/update_worker.py,sha256=vI-YCtUqxf4cgMSwUW34vsCvxuk91lLiCmRY9tlPm-E,24023
 changedetectionio/api/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 changedetectionio/api/api_schema.py,sha256=gsL8TFVe5mBCTHtn1Ou1mjqJgT7birNtjs-70UR-5Qg,3907
-changedetectionio/api/api_v1.py,sha256=oaxpF-XNZhgwpWx4nRU4v4WI-8NHEU-AlKHjHub-HCc,14662
+changedetectionio/api/api_v1.py,sha256=8wH8yDnIvJjHdymyP9PRKai1GN5vtjnOnH8D0tloQB8,15052
 changedetectionio/api/auth.py,sha256=3L10t83Hx3iaSY5JNbw0w_WO4C8CTOtLW8kAHqu9ulQ,966
 changedetectionio/blueprint/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 changedetectionio/blueprint/browser_steps/__init__.py,sha256=BJPSm4atXQrQCDv3Ee4x0w1iZTfPiBJw2pa-qI4Hh4w,9313
 changedetectionio/blueprint/browser_steps/browser_steps.py,sha256=05cd1DB1o5X9aNRcOHG4dGrMTrAQyqYEY8rVs_I6G9c,12037
 changedetectionio/blueprint/browser_steps/nonContext.py,sha256=Nibto8YjJDOWPCVDNyzi6anvdOTOboh_tUC4d4tUcFY,824
 changedetectionio/blueprint/price_data_follower/__init__.py,sha256=Ml498MDTIj_onpFZPdf3Fg9VyhushF76oRl5klmrDvg,1229
-changedetectionio/model/App.py,sha256=4vs-IZniCNYyJ0hYFKjEnJfWEhJIRt-IOcOSiN4pu7s,2856
-changedetectionio/model/Watch.py,sha256=-fwAcQCBch_07sw4xjIPz8gdgtrl7CcUujG0sjGQJR8,20125
+changedetectionio/blueprint/tags/README.md,sha256=whLB7bXtt8J0AtJjdarLjWOnEIxDjxwu0FPeV83B5cc,265
+changedetectionio/blueprint/tags/__init__.py,sha256=oCf69MHFpHOa6IB1mysrfyUrHFvSc5o-w70aJb2ct7I,5551
+changedetectionio/blueprint/tags/form.py,sha256=apPIikBCGyJFT-xRTA_15ZUrZGbzUnZn42gz0cWAoP8,397
+changedetectionio/blueprint/tags/templates/edit-tag.html,sha256=Gby7Mc0nozNAeRhpgRbm-teHwF-awNgAf2UhS0kl8N8,7541
+changedetectionio/blueprint/tags/templates/groups-overview.html,sha256=14dFtCItqXEQN-sslkUCxPGKyJ7euXXEnVe5pWo5mFY,2930
+changedetectionio/model/App.py,sha256=QPZ-etNYwXjn46nUYNVSJ09GmREfCihkG4CTS5Px_lE,2921
+changedetectionio/model/Tag.py,sha256=86fGOS-JVLM-YwIe5szqLsJuj8ZHydEn3hXFoWIA9Bc,406
+changedetectionio/model/Watch.py,sha256=VnQrUCzMJmcdCXrPrwDbeG05qCxcbLu6D-sf5qD2UU4,18593
 changedetectionio/model/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 changedetectionio/processors/README.md,sha256=VcbqdQUGrYJoBho4eMdBezUy5PqJWqSj_bibuT64Nvc,461
 changedetectionio/processors/__init__.py,sha256=I28GEMVm6YzggLhDOL1U4rED8VbyrSdQ9w9zCocah7s,773
-changedetectionio/processors/restock_diff.py,sha256=rs0fdkhVtahwySVyM0kzh9Vc3UPa8RhQMThtG5LK0hU,5731
-changedetectionio/processors/text_json_diff.py,sha256=ewrwYmSq6kj5HBpCGaoec6F44gzHA5h_AwDINHl3bT8,20285
+changedetectionio/processors/restock_diff.py,sha256=iqxiRAv1v4K6kBLBBT1Chx6ZiBabGHHr-Jd71w89p8M,5718
+changedetectionio/processors/text_json_diff.py,sha256=qvneuuTCwj8WmGYZIiu8-L1zOWLOf_2JZsfIOpDch7E,20836
 changedetectionio/res/puppeteer_fetch.js,sha256=rYQC0B6sdPyTZNHZCtQlzo6OxpHOnU3Wpcq_fFew_H8,6602
 changedetectionio/res/stock-not-in-stock.js,sha256=P2W1DL-56_lSBK-t3APtCFtX0FuWsmw91Ozoq3rCCxM,3247
 changedetectionio/res/xpath_element_scraper.js,sha256=NuzdLLIHv6YKYSAXmV248VMCF1DqIGb1AHchnrFk_As,8772
 changedetectionio/static/favicons/android-chrome-192x192.png,sha256=vw2gays5lkeXg8C8PJKHiDo0J7STMHbYLcI-SJ7nbaU,33807
 changedetectionio/static/favicons/android-chrome-256x256.png,sha256=mVRp7YblKuDS7eUtflLzJaOnlyTWF4Qq9qCNP6vMSJI,41104
 changedetectionio/static/favicons/apple-touch-icon.png,sha256=h2lF4Y6pOhQkmBiPs0YX7s3lPHM38eSQG027pP1QqLM,31932
 changedetectionio/static/favicons/browserconfig.xml,sha256=iemEy_8s5zR5gHYcW4ymEdMLHoxAWo4rFXM3_dXjNSU,254
@@ -63,120 +69,122 @@
 changedetectionio/static/js/diff.min.js,sha256=Oim9k3SyGb1pZFUAhc3fa2L8QHOJPT8lHB1h7x6la38,17458
 changedetectionio/static/js/global-settings.js,sha256=etMIEU9MMkaiGdOb_9kEWKGRUEdAKMCtcxnosCqPLCk,1061
 changedetectionio/static/js/jquery-3.6.0.min.js,sha256=_xUj-3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej_m4,89501
 changedetectionio/static/js/limit.js,sha256=zXVwR5WnRb5rOEAKcD9okJcW3jnL_aqVMaVMZikNnUQ,1805
 changedetectionio/static/js/notifications.js,sha256=Fbyfiutqr51_lO0FrF388Bx7nIzh4RPWJkLkqHo7KB4,1525
 changedetectionio/static/js/stepper.js,sha256=LFPCvtuZ11Q3cl0XOT3lFLHrShypoBCLldvFezOQGLs,861
 changedetectionio/static/js/tabs.js,sha256=bFJ_Fk_a64hxgfa93-b37KK0AbVcQCvv8dlivFVoju8,1424
-changedetectionio/static/js/toggle-theme.js,sha256=XfceX8hcOTKymM7CJGegvJxShF1ZDHZXdFyviqt7Ch4,1420
+changedetectionio/static/js/toggle-theme.js,sha256=MI8DX-R3K_Tajtm1cHao5T3SijZHZPYoB3cq2hacPzQ,1280
 changedetectionio/static/js/visual-selector.js,sha256=y3vKzI4nLefafy6F7iG9z0BZ1UxnybY5By7rFYFtV98,9649
-changedetectionio/static/js/watch-overview.js,sha256=lok_b4q-l7-XT-OunuWfzsUP9H0swZx4-d00IKByfTI,1205
+changedetectionio/static/js/watch-overview.js,sha256=KdZJLZhydSJcsNQeebZeXsU2CUNfYoG3gBFAK7K3Jfc,1666
 changedetectionio/static/js/watch-settings.js,sha256=noweuvlhGNTHf3BdlijytjPN2Porac-KGx7MdT31w_A,1711
 changedetectionio/static/styles/.dockerignore,sha256=dhOTU89FUS9S_97-eWDUqBTWFZHAsUJjNr9YFLan8VQ,32
 changedetectionio/static/styles/.gitignore,sha256=dhOTU89FUS9S_97-eWDUqBTWFZHAsUJjNr9YFLan8VQ,32
 changedetectionio/static/styles/diff.css,sha256=R6PTqoYrIbumyemsfSA2ydeOrgwH8LC_WRBKtzP-vfM,7543
 changedetectionio/static/styles/package-lock.json,sha256=3fshnaxtrd1JAgVtemCqAYuiCcApc_UqZgHclcbk_ng,167549
 changedetectionio/static/styles/package.json,sha256=CyM75k3q_DgumXtDfLwkk9Tsmy8EB883cG2rOwvYjAE,339
 changedetectionio/static/styles/pure-min.css,sha256=LQsRzJWwRtq9q5pbvpwwNdLbHXA25kSsu54At8Y58_Y,16789
-changedetectionio/static/styles/styles.css,sha256=You5cpbVOON7_WAqhUJCz2-SkxMzL4LqBSY87QKm5aw,32178
+changedetectionio/static/styles/styles.css,sha256=aqlAl6g7mOsJ_THifu67pTexSFbGvMPENA2Qh_MqB94,32222
 changedetectionio/static/styles/scss/diff.scss,sha256=rJ7UNUBJ-d3ylA2iVtsmrl53eo5W8dbg8RbR6qwTbbs,1590
 changedetectionio/static/styles/scss/styles.scss,sha256=6KKT1MviPoKj35UCsAQR2qMLs_uj3Gyw0JPbkMlGrDI,20984
 changedetectionio/static/styles/scss/parts/_arrows.scss,sha256=Xv7eUJR_9MXM-S-HSMhHHxPrQRykMSyWFTFWye3a_sU,464
 changedetectionio/static/styles/scss/parts/_browser-steps.scss,sha256=HBSMiLq1WzLYhBJRe9Lu6Wq-9-Dq9yzlFPZb6u0JvpQ,1462
 changedetectionio/static/styles/scss/parts/_extra_proxies.scss,sha256=RBDY_maJH9gt6c5azv__3Z03JNOGtoF_l05RakpEZBE,242
 changedetectionio/static/styles/scss/parts/_pagination.scss,sha256=TiKjmEBj-ORkQmNPnhyHMaZY2aE5eXEwizddmPYIfoQ,504
 changedetectionio/static/styles/scss/parts/_spinners.scss,sha256=FPZta6-8u8ETgab4mWpFyn8JB5BCI3h0qM3Ku7ujHxQ,966
 changedetectionio/static/styles/scss/parts/_variables.scss,sha256=kz8yXTRuSRyHyGAWO1fWsrMyZkJ0JOyKMU7pHIu9xLQ,5845
 changedetectionio/templates/_common_fields.jinja,sha256=DP5mJWs8fFYpFOwF6K8UbgmeZgnZHs2e3ZqZ1JjpAR4,9205
 changedetectionio/templates/_helpers.jinja,sha256=kfiunm-jkPIaXhN1esa_6AU2m5tKEPVVUL1EpfoU13c,1525
-changedetectionio/templates/base.html,sha256=-EfsfjXTbIInWBbAGQm_-1L9NMxT4i3H2r_lf2SKf_s,7553
+changedetectionio/templates/base.html,sha256=Av3BvGWtPDWo5wmiNLZluHBm4j8e37EwiCS5BS-liLI,7605
 changedetectionio/templates/clear_all_history.html,sha256=naqYFfD8aI0ohOcZpzW6-c1pPciqakWuFgvaLeP0Nck,1478
 changedetectionio/templates/diff.html,sha256=uq4kOqAqzCtt8SoxGQ87cI3SqtPrz6wK1d2kd_miOv8,7322
-changedetectionio/templates/edit.html,sha256=-PCtpCAUlpQ6QEX2z7izrTh04KkSd-oiQdtjWSPF46k,30025
+changedetectionio/templates/edit.html,sha256=79rHEsfWFzHatJuyjwV_8bHSuaB5LwcFwSn2SJbyTZY,30026
 changedetectionio/templates/import.html,sha256=_V0b-gujpp639ZrO9PrrSlcncx4pni8uvbwD2LfGDhU,4270
 changedetectionio/templates/login.html,sha256=HnvfuD7PUhcnf8fYGBZO4oqsq8KoFT6m6rJoyAY1I08,857
 changedetectionio/templates/notification-log.html,sha256=yqyKa8pLjeLAaOquuAIEYOswS8EoBf9hYwk0Osom3pU,482
 changedetectionio/templates/preview.html,sha256=npRVszlxoWImWCiF0sFfg3xN-Q7IFIQBdacPXYbBNHc,2955
 changedetectionio/templates/settings.html,sha256=yxVox0BZJEgN_mYUQTbYxMoZpmiNX7Ln30OMv59RBDA,13385
-changedetectionio/templates/watch-overview.html,sha256=G8kY2oEUq5iPF_9CTa9SaZfKokiQrJr5p_fH2GNtFMQ,13764
+changedetectionio/templates/watch-overview.html,sha256=WjCziRQJ5QEOL9MxT6-5XNoa_T_GD6YC6GjiBGDww4o,14103
 changedetectionio/templates/svgs/dark-mode-toggle-icon.svg,sha256=j6wbTFZTWhfPYHQUsz4Fjiaqe92ZzabvMD2crwn9ytQ,1602
 changedetectionio/templates/svgs/github.svg,sha256=1L8WyDwhHBbsHlrWJ9Sf75me8QuXd4LilavAnOCSpXY,749
 changedetectionio/templates/svgs/light-mode-toggle-icon.svg,sha256=uXv8hbBmqPg0jlecQF75qms18zGLfE6mjDCVhIM09Js,2806
 changedetectionio/templates/svgs/search-icon.svg,sha256=Qh_JvOIVCvbTNOh7YviE0ETWrhPeQKtB0adkLL7yz38,1605
 changedetectionio/tests/__init__.py,sha256=vEKqIjT09-nnu664epetAleV5FJVm1xyrH20_hlBZXE,26
 changedetectionio/tests/conftest.py,sha256=lyrizJY9BdB4NOK7PtlkGR3VG2R_8FT4JjXoyLkeQRQ,1703
 changedetectionio/tests/test.pdf,sha256=YGzULzGl_fQIOGdfkUYPtlNrVg7XJV49tbsQFW2_COs,7408
-changedetectionio/tests/test_access_control.py,sha256=9QUgwpLvxcr2atMRzEQBSNNGT82y42EQR0U61S0mKms,5455
-changedetectionio/tests/test_add_replace_remove_filter.py,sha256=ndVkZ3_JlG5TcZqG91pReBl7R8Q7EyZOSMmhrhK0R-g,6089
-changedetectionio/tests/test_api.py,sha256=OF0H1aweNuHu9gTRLM2uwTUsKY6aKXJOxstWMS8Xtco,10415
-changedetectionio/tests/test_auth.py,sha256=S1uBNf3WPthEg0U-nTLMo4DXcHnOj9fon7fVbth8zBk,1005
+changedetectionio/tests/test_access_control.py,sha256=z8LFxM_28Vv-gjhu0Cha7By1630eC27GhWfz6vShpEU,5742
+changedetectionio/tests/test_add_replace_remove_filter.py,sha256=jHCtpdrkeNzernay9NUVZX-Dps3gDXZW2aiSgsxbTt0,6011
+changedetectionio/tests/test_api.py,sha256=tzQ8fWxVrsT2dzm-F6E8Rjzx288tEmUPR8lOwkgKPfg,10628
+changedetectionio/tests/test_auth.py,sha256=98oWbDKMn7vfJXQUKhlk4moKJHhfsmw9xnHphfj9nyM,1006
 changedetectionio/tests/test_automatic_follow_ldjson_price.py,sha256=txOr-msWe2RZzvUumdWYdX38GV6EEYcN2-ah8LcGYLQ,4737
 changedetectionio/tests/test_backend.py,sha256=Ps3i5rhq3LVQSv0JTE0XC2sPJMTGabh_ch2YrO4XHuw,4977
 changedetectionio/tests/test_backup.py,sha256=HYPkZfbC6LcanQhz4T5qCAiBWmVKpZXQgo3L-Ym9UTU,1353
-changedetectionio/tests/test_block_while_text_present.py,sha256=UYA--jVcKat-w7KGRP14YQMA31dGBlhq4RCr6QmxZt4,4011
+changedetectionio/tests/test_block_while_text_present.py,sha256=3XS04FPFFw0SMYcVnv8YN03UTURYBCpcLANN6mJwAYw,3936
 changedetectionio/tests/test_clone.py,sha256=fZH_rHUgZkY4qCvgXYr1WKx68RXheu0HaG2aa4nZB48,605
-changedetectionio/tests/test_css_selector.py,sha256=SRKHptZt-aLXAS2UPvuDs0zIQX94J1N1O8-a7Izlnik,5236
-changedetectionio/tests/test_element_removal.py,sha256=ATJAXlw7MGQC3p9TfE9xwXYhDRdZ4Bp5CD4-_K_MGn8,4037
+changedetectionio/tests/test_css_selector.py,sha256=O4JKqmgSe_OQ1xZvtLGscU5F4ZueFblf0JyKU5-Hng4,5238
+changedetectionio/tests/test_element_removal.py,sha256=o33PhaO-uHXDcg-x-CQwLyRU4SmS4J2BfMtoHrtmmfE,4038
 changedetectionio/tests/test_encoding.py,sha256=Macl6Hz8EFaSi-t7EXwxuXNBJUA5HVH0900Ve3yE3jg,2220
 changedetectionio/tests/test_errorhandling.py,sha256=n1Z6NvJkwhhy1Z03rDeUc8PeTuVhPuQCP1hGg96e7CY,4211
 changedetectionio/tests/test_extract_csv.py,sha256=9SHunmKtcMcoxyJ0aXpd_oR-AiF0Vgdk_05VWsrp7Wk,2152
-changedetectionio/tests/test_extract_regex.py,sha256=RV-BqA9SROH3gtvMkntfY3ZoBJipZdzKaexYryUgP1k,5402
-changedetectionio/tests/test_filter_exist_changes.py,sha256=MWP7UNJ5MwKzF0-YU4nNik1eyKaZURp7NqRa6UkOo8M,4259
-changedetectionio/tests/test_filter_failure_notification.py,sha256=CxnkFIRppfSsMcARA7qme36cSfOpQjMIUcP3uyzjwS4,5428
+changedetectionio/tests/test_extract_regex.py,sha256=Wg9vzc_Bi6jD3T-d3cF08-H1wWo0D8VpoPnkDE1FOXI,5404
+changedetectionio/tests/test_filter_exist_changes.py,sha256=J_DZf3I8qwyRrgBdn86frKFWJCT08KcjJQBbI46Um5g,4261
+changedetectionio/tests/test_filter_failure_notification.py,sha256=8PGv_Z2bkNGxg9rsiSC97PnDgt3gvC4lhfPByF6LoM4,6274
+changedetectionio/tests/test_group.py,sha256=IqLi593WB5ZT5depVf-trZeVmv5fGIvI-W3Jk2YcTMs,11163
 changedetectionio/tests/test_history_consistency.py,sha256=rVvvCuyvWI1nG5TZu5WNEGej5JLkbjr38XVZZjGH0Zw,3290
 changedetectionio/tests/test_html_to_text.py,sha256=LhIb2QzvFX_ELaP5edmiStgND89_9sSybWtEbpV9Uds,1276
 changedetectionio/tests/test_ignore_regex_text.py,sha256=LmLi2-GoW1fOtUPqU5oOR_f0Zdjl72Cy61PfgyCnrE0,892
-changedetectionio/tests/test_ignore_text.py,sha256=LniCbJP7VwXlqAnO_5cU_OR9eUzz7yrOAOomLjlVouE,7556
+changedetectionio/tests/test_ignore_text.py,sha256=9jP0_wSKWUUTi6K2_LP0gTleuqHkoE1ouaGIebzmLoo,7408
 changedetectionio/tests/test_ignorehyperlinks.py,sha256=zYXv2Mo2NxsAzgh3NrrQsr7irnPFMyc6JzGtJBq_3hQ,3735
-changedetectionio/tests/test_ignorestatuscode.py,sha256=gJdIiYKmTfDAB9S8osU5K58oV31sTQM48AxarLjaxq8,3624
+changedetectionio/tests/test_ignorestatuscode.py,sha256=3TW_0GjDjch1uV8bdYq_F7tjdDQYGIw1bpHWM2aP_qY,3550
 changedetectionio/tests/test_ignorewhitespace.py,sha256=intYNgjUfaWCVGU3YMfhW7VoN9SbK_qdlyyOhnCObxc,2478
-changedetectionio/tests/test_import.py,sha256=G15Wg-isMfLtGs3NolfCyScrbTu7XU-jrTNnpnClmv0,3918
-changedetectionio/tests/test_jinja2.py,sha256=dxCRP69gW8BQIHUHz-ODFY2j6eNbbvkQGfPWkchY8EQ,1076
-changedetectionio/tests/test_jsonpath_jq_selector.py,sha256=IGmeXnYDnXtRWrjWe7znaeTFLmDKMnMuLpv1ojVrCgg,16495
+changedetectionio/tests/test_import.py,sha256=k484CwusmGsdB49sv5T8BHqzpgHtYREcYU268pLgVDI,3935
+changedetectionio/tests/test_jinja2.py,sha256=5dSOwGu258FyqbY6wp_y2TCyvYE195qcq3_3Y9eS9N0,1077
+changedetectionio/tests/test_jsonpath_jq_selector.py,sha256=vv8o31xyzDVfGALLcd6VCBzAKg-xhr8ZZ-vVEhnHWXQ,16680
 changedetectionio/tests/test_nonrenderable_pages.py,sha256=lbnWo3CNEGK1YgY3sbqLb6GDoMR0-UkMCyA0OsM4yzk,2892
-changedetectionio/tests/test_notification.py,sha256=YleNG_V8Yk-h1oc8mbNp6RFjUM8yahGAmT122gbjgO0,13120
-changedetectionio/tests/test_notification_errors.py,sha256=cKuis_t4fP_9aAP3nz6AhdPVrKz7vzPzaI6zPuX6bdM,1954
+changedetectionio/tests/test_notification.py,sha256=6A0q3FnVwsud5lEFdFTgu7ySA0sb_fBXd5PN6ssnPr8,13236
+changedetectionio/tests/test_notification_errors.py,sha256=K3p9nPCZKh6lYJSjhrdGo9fMJBM1yaizgakM0ZmH78U,1956
 changedetectionio/tests/test_obfuscations.py,sha256=r9-JB_HaVwjo5dMwKIvlYtqfggweu1_DCIVb7gb-NOc,1022
 changedetectionio/tests/test_pdf.py,sha256=nFD2_18X7kiT_uWydcOJ3IneojU937oLbUth0HEEbmY,1233
-changedetectionio/tests/test_request.py,sha256=1kwdWAuqDG0CPjzcU9fPHJpcbPhBkk5l_KBBKluQ7k8,10121
+changedetectionio/tests/test_request.py,sha256=dno6SBLnYryppbBLfgpqpMxkreUVMlKciVjKZWGQG08,10254
 changedetectionio/tests/test_rss.py,sha256=cm7q7Fcu1-g9ymWA6Bpm7NNK7iwncpTsnDBioTfgNRA,1121
-changedetectionio/tests/test_security.py,sha256=Vy7f5pl1QmsktmvXaccmkoqkWo0sOiz2Pc0ZTFEZ4Rg,1951
-changedetectionio/tests/test_share_watch.py,sha256=4MSYtff4zuMPbP8cp9ygKGuwn17tOgaj7c6MMY3UzwM,2318
-changedetectionio/tests/test_source.py,sha256=PQLr_I-KJltdbAr1BLnFOTRj09Gm0tyi0fkGE849uzY,2637
+changedetectionio/tests/test_search.py,sha256=v0Zvho819GDA-Y4wfEGDKaYPgjk5PIIcFVXCWNYCbwI,2406
+changedetectionio/tests/test_security.py,sha256=pdij_lnbq26sWSQCcJTgCjnCjBZGvGV7O1uXiawJr-o,1956
+changedetectionio/tests/test_share_watch.py,sha256=YG9my65XSLhFUNqI_XAK8u8r6lwRhdVzjw05f0A-rYc,2319
+changedetectionio/tests/test_source.py,sha256=H6i1z8bfeCM-MExmBLpp3Et8Ddp5jFuLDZLUe-Z6oi8,2661
 changedetectionio/tests/test_trigger.py,sha256=_vELPmdXCaKSQbcWXMXFLs1iJlc7W4Vc9qlN-dRRVMk,4115
 changedetectionio/tests/test_trigger_regex.py,sha256=uEnRYiphnU4ESWBemCHNl8U-e3GfnaXho7sNM2v7ghc,2390
 changedetectionio/tests/test_trigger_regex_with_filter.py,sha256=iT-Cg-cUXdw8Z2BazngUEXMwHQSd6IxpNqnnZxzNVLg,2486
 changedetectionio/tests/test_unique_lines.py,sha256=qVEFl3whXNM1PzGxBY50DKRFjSrckXoEYZorrd59p7M,2852
-changedetectionio/tests/test_watch_fields_storage.py,sha256=CG3xg0sL1ibEAO0v4Njz3MVSAk65D4jBkp3yfgk9SMg,4528
-changedetectionio/tests/test_xpath_selector.py,sha256=tMnUA7KJP5u6GjVWZx4xqDDmFlJlyK4rVP7cZTLfS2Q,9442
-changedetectionio/tests/util.py,sha256=Yv-qCi164mMoQdplM7m8cGrwdRqxT--3hCG1Q4QlsMY,6255
+changedetectionio/tests/test_watch_fields_storage.py,sha256=H9vX86tjyW_T3MCpCbNpZAsIB16nOn-PmnRYcH-zcN8,4529
+changedetectionio/tests/test_xpath_selector.py,sha256=tg5H202osVjVmazblxamdcV-9qDH-yenqiW3wOVIeMY,9447
+changedetectionio/tests/util.py,sha256=F-9AV4PPiGTwbUWOAr5c1KFpV2tGHd-zSizc2QihYqk,6578
 changedetectionio/tests/fetchers/__init__.py,sha256=vEKqIjT09-nnu664epetAleV5FJVm1xyrH20_hlBZXE,26
 changedetectionio/tests/fetchers/conftest.py,sha256=f_l5j9qzU9r5GtKJVNFNRVkXBDLH9jMpaiNpg3r-7Ro,44
 changedetectionio/tests/fetchers/test_content.py,sha256=9GnDNHSBWjhkr46qLdPDNIKACzifFyFXfTKI-sa2TLo,1118
 changedetectionio/tests/proxy_list/__init__.py,sha256=vEKqIjT09-nnu664epetAleV5FJVm1xyrH20_hlBZXE,26
 changedetectionio/tests/proxy_list/conftest.py,sha256=Kf96FNCZ_CjO1_dkqwyAALi31C5Q8nJPctK-Rg_RSPM,539
 changedetectionio/tests/proxy_list/proxies.json-example,sha256=Q4CoaMzn7Kz0zkFOOejCMYN5wcGT7NiBeLnLxUNQqfs,169
 changedetectionio/tests/proxy_list/squid-auth.conf,sha256=FHMaVYEBDEeicpxsmjW7_0-FPD6CYFBoKPYm1RC19Go,2068
 changedetectionio/tests/proxy_list/squid-passwords.txt,sha256=5PuVjdbhCmiLj98EzJfkY4sxjOtutq9ItHNbVNrMD6o,43
 changedetectionio/tests/proxy_list/squid.conf,sha256=jtDfcVUVXioYLyAS6x7WW8vNqSfFz6UpVku2nWv9TKQ,1884
-changedetectionio/tests/proxy_list/test_multiple_proxy.py,sha256=v_DSq3v2AOKg9PGqSi0Jq69gXypGxWNlAtA_UYDhGCw,1033
+changedetectionio/tests/proxy_list/test_multiple_proxy.py,sha256=BvC3LHOvjdtFqTeCzG1W6DBbxMzHs_AD84cFuG4ti2c,1034
 changedetectionio/tests/proxy_list/test_proxy.py,sha256=95s4OfABUgOHcJ-rXfA7TdHmPjOtBqyOfuWe1gpkd6o,669
 changedetectionio/tests/proxy_list/test_select_custom_proxy.py,sha256=kf2Ctcbm8uz5JONylv5axAglXmSTPrvnJrp6akLIAC0,1665
 changedetectionio/tests/restock/__init__.py,sha256=vEKqIjT09-nnu664epetAleV5FJVm1xyrH20_hlBZXE,26
 changedetectionio/tests/restock/conftest.py,sha256=f_l5j9qzU9r5GtKJVNFNRVkXBDLH9jMpaiNpg3r-7Ro,44
-changedetectionio/tests/restock/test_restock.py,sha256=BVOKK381GjIpG6qW23vjNZSfHrhGxc0qj5oSVTJPDMo,3697
+changedetectionio/tests/restock/test_restock.py,sha256=jQ1ZD4RvdVoch30WaV81OQx0JOCrI4x18kr88QTpg8o,3698
 changedetectionio/tests/unit/__init__.py,sha256=EtWbObEPbfMdf0YcAYnhjZQKEMJgu6jZsD4cexhI3fM,30
 changedetectionio/tests/unit/test_notification_diff.py,sha256=6_PlIrazStPHX8xy8vOmZz3cbUFsMex-EoRTy0LPJRU,2740
 changedetectionio/tests/unit/test-content/README.md,sha256=pKrusHd0289J-5TUUJY03Zix8hwsGVR15bc3B8sLxFM,276
 changedetectionio/tests/unit/test-content/after-2.txt,sha256=Ep-eHdLGWXU1LZAV7yZV19Si8teMl0VLDkWYYepwvm4,94
 changedetectionio/tests/unit/test-content/after.txt,sha256=nqmYxYNF-4QUn7wu6h2eWtSwdCo78dKyji8sdFwbNCY,198
 changedetectionio/tests/unit/test-content/before.txt,sha256=KKw8Dvj1mr0D25zQG_SgrGZizEHWhrOW5qPYTJ0sn3o,170
 changedetectionio/tests/visualselector/__init__.py,sha256=vEKqIjT09-nnu664epetAleV5FJVm1xyrH20_hlBZXE,26
 changedetectionio/tests/visualselector/conftest.py,sha256=f_l5j9qzU9r5GtKJVNFNRVkXBDLH9jMpaiNpg3r-7Ro,44
-changedetectionio/tests/visualselector/test_fetch_data.py,sha256=dN17CUlzoowqisoQ0XL9DNwasXaaoZtxvpuFA7katbM,2346
-changedetection.io-0.42.3.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-changedetection.io-0.42.3.dist-info/METADATA,sha256=gVHRElUAXhRvU8SHuScxi1pTjLHHJVnNDqRF_Xyz-jY,5593
-changedetection.io-0.42.3.dist-info/WHEEL,sha256=g4nMs7d-Xl9-xC9XovUrsDHGXt-FT0E17Yqo92DEfvY,92
-changedetection.io-0.42.3.dist-info/entry_points.txt,sha256=1kYfo1qNUYfVNdcHOb_yL15A4W0GkabDmsC7WzWrXQc,78
-changedetection.io-0.42.3.dist-info/top_level.txt,sha256=7E6A1XK3M85XKA-kml0-ATltdSeVkOvugbVFsGCp8uA,18
-changedetection.io-0.42.3.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
-changedetection.io-0.42.3.dist-info/RECORD,,
+changedetectionio/tests/visualselector/test_fetch_data.py,sha256=g1wrrs9TbW7BDd6KfxhFHMg5Ee77wAD_eAQQckh36aQ,2348
+changedetection.io-0.43.1.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+changedetection.io-0.43.1.dist-info/METADATA,sha256=x-aN44ViDYBLpQbOpz5HdyeFQZv6BbVVhQnvuhSKZdo,5593
+changedetection.io-0.43.1.dist-info/WHEEL,sha256=g4nMs7d-Xl9-xC9XovUrsDHGXt-FT0E17Yqo92DEfvY,92
+changedetection.io-0.43.1.dist-info/entry_points.txt,sha256=1kYfo1qNUYfVNdcHOb_yL15A4W0GkabDmsC7WzWrXQc,78
+changedetection.io-0.43.1.dist-info/top_level.txt,sha256=7E6A1XK3M85XKA-kml0-ATltdSeVkOvugbVFsGCp8uA,18
+changedetection.io-0.43.1.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
+changedetection.io-0.43.1.dist-info/RECORD,,
```

